<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Polygram · Trade Predictions</title>
  <script src="https://telegram.org/js/telegram-web-app.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/5.7.2/ethers.umd.min.js"></script>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=DM+Sans:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    @font-face {
      font-family: 'Benzin';
      src: url('https://fonts.cdnfonts.com/s/29189/Benzin-ExtraBold.woff') format('woff');
      font-weight: 800;
      font-style: normal;
    }
    
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    :root {
      --bg: #d4eef4;
      --card: #c8e8f0;
      --text: #1a3a4a;
      --text-muted: #4a7080;
      --accent: #1e3a5f;
      --accent-light: #a8f0c8;
      --accent-pink: #ec4899;
      --green: #7cf0a8;
      --green-soft: #a8f0c8;
      --red: #ef4444;
      --border: #b8dce8;
      --bg-secondary: #e0f4f8;
      --card-hover: #b8e0e8;
      --radius: 24px;
      --radius-sm: 16px;
      --shadow: none;
    }

    body {
      font-family: 'DM Sans', -apple-system, BlinkMacSystemFont, sans-serif;
      background: var(--bg);
      color: var(--text);
      min-height: 100vh;
      overflow-x: hidden;
      -webkit-font-smoothing: antialiased;
    }

    /* Splash Screen */
    .splash-screen {
      position: fixed;
      inset: 0;
      background: var(--bg);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 9999;
      transition: opacity 0.4s ease;
    }
    .splash-screen.hidden { opacity: 0; pointer-events: none; }
    
    .splash-logo {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 32px;
    }
    .splash-logo-icon {
      font-size: 32px;
    }
    .splash-logo-text {
      font-family: 'Benzin', 'DM Sans', sans-serif;
      font-size: 42px;
      font-weight: 800;
      color: var(--text);
      letter-spacing: -0.02em;
    }
    
    .splash-spinner {
      width: 32px;
      height: 32px;
      border: 3px solid var(--border);
      border-top-color: var(--accent);
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    @keyframes spin { to { transform: rotate(360deg); } }

    /* Onboarding Screen */
    .onboarding-screen {
      position: fixed;
      inset: 0;
      background: var(--bg);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 9998;
      padding: 20px;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s ease;
    }
    .onboarding-screen.visible { opacity: 1; pointer-events: auto; }
    
    .onboarding-card {
      background: var(--card);
      border-radius: var(--radius);
      padding: 32px;
      max-width: 360px;
      width: 100%;
      text-align: center;
    }
    .onboarding-logo {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
      margin-bottom: 20px;
    }
    .onboarding-logo-icon {
      font-size: 24px;
    }
    .onboarding-logo-text {
      font-family: 'Benzin', 'DM Sans', sans-serif;
      font-size: 28px;
      font-weight: 800;
      color: var(--text);
    }
    .onboarding-title {
      font-size: 20px;
      font-weight: 700;
      margin-bottom: 8px;
      color: var(--text);
    }
    .onboarding-subtitle {
      font-size: 14px;
      color: var(--text-muted);
      margin-bottom: 24px;
      line-height: 1.5;
    }
    
    .feature-list {
      text-align: left;
      margin-bottom: 24px;
    }
    .feature-item {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 12px;
      background: var(--bg);
      border-radius: var(--radius-sm);
      margin-bottom: 10px;
    }
    .feature-icon {
      width: 36px;
      height: 36px;
      border-radius: 10px;
      background: var(--accent);
      color: white;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
      flex-shrink: 0;
    }
    .feature-text {
      font-size: 13px;
      color: var(--text);
      line-height: 1.4;
    }
    
    .passkey-input {
      width: 100%;
      padding: 14px;
      font-size: 15px;
      font-family: inherit;
      border: 2px solid var(--border);
      border-radius: var(--radius-sm);
      background: var(--bg);
      text-align: center;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      margin-bottom: 12px;
      transition: border-color 0.2s;
    }
    .passkey-input:focus {
      outline: none;
      border-color: var(--accent);
    }
    .passkey-input.error {
      border-color: var(--red);
      animation: shake 0.4s ease;
    }
    @keyframes shake {
      0%, 100% { transform: translateX(0); }
      25% { transform: translateX(-8px); }
      75% { transform: translateX(8px); }
    }
    
    .passkey-error {
      color: var(--red);
      font-size: 12px;
      margin-bottom: 12px;
      display: none;
    }
    .passkey-error.visible { display: block; }
    
    .passkey-btn {
      width: 100%;
      padding: 14px;
      font-size: 15px;
      font-weight: 600;
      font-family: inherit;
      background: var(--accent);
      color: white;
      border: none;
      border-radius: var(--radius-sm);
      cursor: pointer;
      transition: transform 0.2s, opacity 0.2s;
    }
    .passkey-btn:active { transform: scale(0.98); }
    .passkey-btn:disabled { opacity: 0.6; cursor: not-allowed; }
    
    .passkey-hint {
      margin-top: 16px;
      font-size: 12px;
      color: var(--text-muted);
    }
    .passkey-hint a {
      color: var(--accent);
      text-decoration: none;
    }

    /* Main App */
    .app-shell {
      padding: 20px 16px 100px;
      max-width: 480px;
      margin: 0 auto;
      opacity: 0;
      transition: opacity 0.3s ease;
    }
    .app-shell.visible { opacity: 1; }

    /* Header */
    .header {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 20px;
      padding: 8px 0;
    }
    .header-logo {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .header-logo-icon {
      font-size: 20px;
    }
    .header-logo-text {
      font-family: 'Benzin', 'DM Sans', sans-serif;
      font-size: 26px;
      font-weight: 800;
      color: var(--text);
      letter-spacing: -0.02em;
    }

    /* Cards */
    .card {
      background: var(--card);
      border-radius: var(--radius);
      padding: 20px;
      margin-bottom: 16px;
    }
    .card-label {
      font-size: 11px;
      font-weight: 600;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.1em;
      margin-bottom: 6px;
    }

    /* Balance Card */
    .balance-card {
      position: relative;
    }
    .balance-top-bar {
      background: var(--green);
      height: 48px;
      border-radius: 30px;
      margin-bottom: 16px;
    }
    .balance-amount {
      font-size: 36px;
      font-weight: 700;
      margin-bottom: 8px;
      color: var(--text);
    }
    .balance-breakdown {
      background: var(--bg);
      padding: 14px 18px;
      border-radius: 30px;
      font-size: 13px;
      color: var(--text-muted);
      margin-bottom: 12px;
    }
    .balance-dot {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      background: var(--accent);
    }

    /* Wallet Card */
    .wallet-title {
      font-size: 16px;
      font-weight: 600;
      margin-bottom: 12px;
      color: var(--text);
    }
    .wallet-section {
      display: flex;
      flex-direction: column;
      gap: 12px;
      margin-bottom: 12px;
    }
    .wallet-row {
      background: var(--bg);
      border-radius: 16px;
      padding: 12px 16px;
    }
    .wallet-label {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 12px;
      font-weight: 600;
      color: var(--text-muted);
      margin-bottom: 6px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    .wallet-icon {
      font-size: 14px;
      font-weight: 700;
    }
    .wallet-address-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
    }
    .wallet-address {
      font-size: 13px;
      font-family: 'SF Mono', Monaco, monospace;
      color: var(--text);
      flex: 1;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      cursor: pointer;
      padding: 4px 8px;
      border-radius: 6px;
      transition: all 0.2s;
      user-select: all;
    }
    .wallet-address:hover {
      background: var(--bg);
    }
    .wallet-address:active {
      background: var(--card);
    }
    .copy-btn {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 6px 8px;
      cursor: pointer;
      color: var(--text-muted);
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s;
      flex-shrink: 0;
    }
    .copy-btn:hover {
      background: var(--green);
      color: var(--text);
      border-color: var(--green);
    }
    .copy-btn:active {
      transform: scale(0.95);
    }
    .copy-btn.copied {
      background: var(--green);
      color: var(--text);
      border-color: var(--green);
    }
    .wallet-status {
      background: var(--accent);
      color: white;
      height: 40px;
      border-radius: 30px;
      padding: 0 18px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 13px;
      margin-bottom: 12px;
    }
    .wallet-actions {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
      margin-top: 8px;
    }
    .wallet-action-btn {
      padding: 10px 16px;
      border-radius: var(--radius-sm);
      font-size: 13px;
      font-weight: 600;
      border: 1px solid var(--border);
      background: var(--bg);
      color: var(--text);
      cursor: pointer;
      transition: all 0.2s;
    }
    .wallet-action-btn:hover {
      background: var(--card);
    }
    .wallet-action-btn:active {
      transform: scale(0.98);
    }

    /* Fund Modal */
    .fund-info {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }
    .fund-currency-selector {
      display: flex;
      gap: 8px;
    }
    .currency-btn {
      flex: 1;
      padding: 10px;
      border-radius: var(--radius-sm);
      font-size: 14px;
      font-weight: 600;
      border: 1px solid var(--border);
      background: var(--bg);
      color: var(--text);
      cursor: pointer;
      transition: all 0.2s;
    }
    .currency-btn.active {
      background: var(--accent);
      color: white;
      border-color: var(--accent);
    }
    .fund-amount input {
      width: 100%;
      padding: 12px;
      border-radius: var(--radius-sm);
      border: 1px solid var(--border);
      background: var(--bg);
      font-size: 16px;
      font-weight: 600;
    }
    .fund-address-section {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .fund-address-section label {
      font-size: 12px;
      color: var(--text-muted);
      font-weight: 500;
    }
    .fund-address-display {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 12px;
      background: var(--bg);
      border-radius: var(--radius-sm);
      border: 1px solid var(--border);
    }
    .fund-address-display code {
      flex: 1;
      font-size: 12px;
      font-family: 'Courier New', monospace;
      word-break: break-all;
      color: var(--text);
    }
    .fund-instructions {
      padding: 12px;
      background: var(--bg);
      border-radius: var(--radius-sm);
      font-size: 13px;
      color: var(--text-muted);
      line-height: 1.5;
    }
    .fund-summary {
      display: flex;
      flex-direction: column;
      gap: 8px;
      padding: 12px;
      background: var(--bg);
      border-radius: var(--radius-sm);
    }
    .fund-summary-row {
      display: flex;
      justify-content: space-between;
      font-size: 13px;
    }
    .fund-summary-row span:first-child {
      color: var(--text-muted);
    }
    .fund-summary-row span:last-child {
      font-weight: 600;
      color: var(--text);
    }
    .modal-close-btn {
      width: 100%;
      padding: 12px;
      margin-top: 8px;
      border-radius: var(--radius-sm);
      border: 1px solid var(--border);
      background: var(--bg);
      color: var(--text);
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s;
    }
    .modal-close-btn:hover {
      background: var(--card);
    }

    /* Positions */
    .position-item {
      padding: 12px;
      background: var(--bg);
      border-radius: var(--radius-sm);
      margin-bottom: 8px;
      border: 1px solid var(--border);
    }
    .position-header {
      display: flex;
      justify-content: space-between;
      align-items: start;
      margin-bottom: 8px;
    }
    .position-question {
      font-size: 13px;
      font-weight: 500;
      color: var(--text);
      flex: 1;
    }
    .position-side {
      padding: 4px 8px;
      border-radius: 12px;
      font-size: 11px;
      font-weight: 600;
      text-transform: uppercase;
    }
    .position-side.yes {
      background: var(--green-soft);
      color: var(--text);
    }
    .position-side.no {
      background: var(--bg);
      color: var(--text-muted);
    }
    .position-details {
      display: flex;
      justify-content: space-between;
      font-size: 12px;
      color: var(--text-muted);
    }
    .position-value {
      font-weight: 600;
      color: var(--text);
    }
    .position-value.winning {
      color: var(--green);
    }
    .payout-item {
      padding: 12px;
      background: var(--bg);
      border-radius: var(--radius-sm);
      margin-bottom: 8px;
      border: 1px solid var(--border);
    }
    .payout-header {
      display: flex;
      justify-content: space-between;
      align-items: start;
      margin-bottom: 8px;
    }
    .payout-amount {
      font-size: 18px;
      font-weight: 700;
      color: var(--green);
    }
    .payout-btn {
      width: 100%;
      padding: 10px;
      margin-top: 8px;
      border-radius: var(--radius-sm);
      background: var(--green);
      color: white;
      font-size: 13px;
      font-weight: 600;
      border: none;
      cursor: pointer;
      transition: all 0.2s;
    }
    .payout-btn:hover {
      opacity: 0.9;
    }
    .payout-btn:active {
      transform: scale(0.98);
    }
    .payout-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    /* Legacy wallet actions (kept for compatibility) */
    .wallet-actions {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      margin-bottom: 10px;
    }
    .wallet-actions-bottom {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }
    .wallet-btn {
      padding: 16px;
      border-radius: 30px;
      font-size: 14px;
      font-weight: 600;
      font-family: inherit;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      transition: transform 0.2s;
      border: none;
    }
    .wallet-btn:active { transform: scale(0.98); }
    .wallet-btn.green {
      background: var(--green);
      color: var(--text);
    }
    .wallet-btn.dark {
      background: var(--accent);
      color: white;
    }

    /* Markets Card */
    .markets-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 16px;
    }
    .markets-title {
      font-size: 16px;
      font-weight: 600;
      color: var(--text);
    }
    
    /* Category Scroll Container */
    .category-scroll-container {
      position: relative;
      margin-bottom: 16px;
      overflow: hidden;
    }
    .category-scroll {
      display: flex;
      gap: 10px;
      overflow-x: auto;
      overflow-y: hidden;
      scroll-behavior: smooth;
      -webkit-overflow-scrolling: touch;
      padding: 4px 0;
      scrollbar-width: none; /* Firefox */
      -ms-overflow-style: none; /* IE/Edge */
    }
    .category-scroll::-webkit-scrollbar {
      display: none; /* Chrome/Safari */
    }
    .category-chip {
      padding: 10px 18px;
      border-radius: 30px;
      font-size: 13px;
      font-weight: 600;
      font-family: inherit;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      background: var(--accent);
      border: none;
      color: white;
      transition: all 0.2s;
      white-space: nowrap;
      flex-shrink: 0;
      min-height: 40px;
    }
    .category-chip:hover {
      opacity: 0.9;
    }
    .category-chip:active {
      transform: scale(0.95);
    }
    .category-chip.active {
      background: var(--green);
      color: var(--text);
    }
    
    /* Legacy mode-chips (keeping for backward compatibility) */
    .mode-chips {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      margin-bottom: 16px;
    }
    .mode-chip {
      padding: 14px 16px;
      border-radius: 30px;
      font-size: 13px;
      font-weight: 600;
      font-family: inherit;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      background: var(--accent);
      border: none;
      color: white;
      transition: all 0.2s;
    }
    .mode-chip.active {
      background: var(--green);
      color: var(--text);
    }
    
    .markets-list {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    /* Market Item */
    .market-item {
      display: flex;
      gap: 12px;
      padding: 14px;
      background: var(--bg);
      border-radius: var(--radius-sm);
      cursor: pointer;
      transition: transform 0.2s;
    }
    .market-item:active { transform: scale(0.99); }
    .market-image {
      width: 40px;
      height: 40px;
      border-radius: 8px;
      object-fit: cover;
      flex-shrink: 0;
      background: var(--bg-secondary);
    }
    .market-image.hidden {
      display: none;
    }
    .market-info {
      flex: 1;
      min-width: 0;
    }
    .market-question {
      font-size: 14px;
      font-weight: 500;
      line-height: 1.4;
      margin-bottom: 6px;
      color: var(--text);
      display: -webkit-box;
      -webkit-line-clamp: 2;
      line-clamp: 2;
      -webkit-box-orient: vertical;
      overflow: hidden;
    }
    .market-meta {
      display: flex;
      align-items: center;
      gap: 12px;
      font-size: 12px;
      color: var(--text-muted);
    }
    .market-odds {
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      gap: 4px;
    }
    .odds-yes {
      background: var(--green);
      color: var(--text);
      padding: 6px 12px;
      border-radius: 20px;
      font-size: 13px;
      font-weight: 600;
    }
    .odds-vol {
      font-size: 11px;
      color: var(--text-muted);
    }

    /* Event Grouping (for NFL games) */
    .event-group {
      background: var(--bg);
      border-radius: var(--radius-sm);
      margin-bottom: 12px;
      overflow: hidden;
    }
    .event-header {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 14px;
      border-bottom: 1px solid var(--border);
      cursor: pointer;
      user-select: none;
      transition: background 0.2s;
      flex-wrap: nowrap;
      overflow: hidden;
    }
    .event-header:hover {
      background: var(--card);
    }
    .event-header.collapsed {
      border-bottom: none;
    }
    .event-info {
      flex: 1;
      min-width: 0;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    .event-title {
      font-size: 15px;
      font-weight: 600;
      line-height: 1.4;
      color: var(--text);
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
      word-break: break-word;
      overflow-wrap: break-word;
      white-space: normal;
    }
    .event-title-text {
      display: inline-block;
      word-break: break-word;
      overflow-wrap: break-word;
      white-space: normal;
    }
    .event-meta {
      display: flex;
      align-items: center;
      gap: 12px;
      font-size: 12px;
      color: var(--text-muted);
    }
    .event-primary-prices {
      display: flex;
      gap: 6px;
      flex-shrink: 0;
      margin-left: auto;
      margin-right: 8px;
    }
    .event-price-btn {
      padding: 6px 12px;
      border-radius: 8px;
      border: none;
      font-weight: 600;
      font-size: 12px;
      cursor: pointer;
      white-space: nowrap;
      transition: opacity 0.2s;
      flex-shrink: 0;
    }
    @media (max-width: 480px) {
      .event-primary-prices {
        flex-direction: column;
        gap: 4px;
      }
      .event-price-btn {
        padding: 4px 8px;
        font-size: 11px;
      }
      .event-title {
        font-size: 14px;
      }
      .event-header {
        padding: 12px;
        gap: 8px;
      }
      .event-image {
        width: 40px;
        height: 40px;
      }
    }
    .event-collapse-icon {
      font-size: 18px;
      color: var(--text-muted);
      transition: transform 0.2s;
      flex-shrink: 0;
      width: 24px;
      height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .event-header.collapsed .event-collapse-icon {
      transform: rotate(-90deg);
    }
    .event-price-btn:hover {
      opacity: 0.8;
    }
    .event-price-btn-1 {
      background: var(--accent);
      color: white;
    }
    .event-price-btn-2 {
      background: var(--bg-secondary);
      color: var(--text);
      border: 1px solid var(--border);
    }
    .event-markets {
      padding: 0;
      max-height: 2000px;
      overflow: hidden;
      transition: max-height 0.3s ease, padding 0.3s ease;
    }
    .event-group.collapsed .event-markets {
      max-height: 0;
      padding: 0;
    }
    .event-image {
      width: 48px;
      height: 48px;
      border-radius: 8px;
      object-fit: cover;
      flex-shrink: 0;
      background: var(--bg-secondary);
    }
    .event-image.hidden {
      display: none;
    }
    .week-tag {
      background: var(--bg-secondary);
      color: var(--text-muted);
      padding: 2px 8px;
      border-radius: 12px;
      font-size: 11px;
      font-weight: 500;
      text-transform: uppercase;
      flex-shrink: 0;
    }
    .event-markets {
      padding: 0;
    }
    .market-item.nested {
      border-radius: 0;
      border-bottom: 1px solid var(--border);
      margin: 0;
    }
    .market-item.nested:last-child {
      border-bottom: none;
    }
    .market-item.nested .market-question {
      font-size: 13px;
    }

    /* Market Card (New Design) */
    .market-card {
      background: var(--card);
      border-radius: var(--radius-sm);
      padding: 16px;
      margin-bottom: 12px;
      transition: all 0.2s ease;
      cursor: pointer;
    }
    .market-card:active {
      transform: scale(0.99);
    }
    .market-card-header {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 16px;
    }
    .market-card-header .market-image {
      width: 48px;
      height: 48px;
      border-radius: 8px;
      object-fit: cover;
      flex-shrink: 0;
      background: var(--bg);
    }
    .market-title {
      flex: 1;
      font-size: 16px;
      font-weight: 600;
      color: var(--text);
      line-height: 1.4;
    }
    .market-outcomes {
      display: flex;
      flex-direction: column;
      gap: 10px;
      margin-bottom: 12px;
    }
    .market-outcome-item {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .outcome-label {
      font-size: 14px;
      color: var(--text-muted);
      margin-bottom: 4px;
    }
    .outcome-buttons {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }
    .outcome-button-group {
      display: flex;
      align-items: center;
      gap: 8px;
      flex: 1;
      min-width: 120px;
    }
    .outcome-price {
      font-size: 14px;
      font-weight: 600;
      color: var(--text);
      min-width: 45px;
    }
    .outcome-btn {
      flex: 1;
      padding: 10px 16px;
      border-radius: var(--radius-sm);
      font-size: 14px;
      font-weight: 500;
      border: 1px solid var(--border);
      background: var(--bg);
      color: var(--text);
      cursor: pointer;
      transition: all 0.2s ease;
      min-width: 60px;
    }
    .outcome-btn:active {
      transform: scale(0.95);
    }
    .outcome-yes {
      background: var(--accent-pink);
      color: white;
      border-color: var(--accent-pink);
    }
    .outcome-yes:active {
      opacity: 0.9;
    }
    .outcome-no {
      background: var(--bg);
      color: var(--text);
      border-color: var(--border);
    }
    .outcome-no:active {
      background: var(--card);
    }
    .market-card-footer {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding-top: 12px;
      border-top: 1px solid var(--border);
    }
    .market-volume {
      font-size: 12px;
      color: var(--text-muted);
      font-weight: 500;
    }
    .market-icon {
      font-size: 16px;
      opacity: 0.6;
    }

    /* Modal */
    .modal-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.4);
      display: flex;
      align-items: flex-end;
      justify-content: center;
      z-index: 1000;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s;
    }
    .modal-overlay.visible {
      opacity: 1;
      pointer-events: auto;
    }
    .modal {
      background: var(--card);
      border-radius: var(--radius) var(--radius) 0 0;
      padding: 24px;
      width: 100%;
      max-width: 480px;
      max-height: 85vh;
      overflow-y: auto;
      transform: translateY(100%);
      transition: transform 0.3s ease;
    }
    .modal-overlay.visible .modal {
      transform: translateY(0);
    }
    .modal-handle {
      width: 40px;
      height: 4px;
      background: var(--border);
      border-radius: 2px;
      margin: 0 auto 20px;
    }
    .modal-title {
      font-size: 20px;
      font-weight: 700;
      margin-bottom: 8px;
      color: var(--text);
    }
    .modal-subtitle {
      font-size: 14px;
      color: var(--text-muted);
      margin-bottom: 20px;
    }
    .modal-close {
      position: absolute;
      top: 20px;
      right: 20px;
      width: 32px;
      height: 32px;
      border-radius: 50%;
      background: var(--bg);
      border: none;
      font-size: 18px;
      cursor: pointer;
    }

    /* Trade Modal */
    .trade-market-info {
      display: flex;
      gap: 12px;
      padding: 16px;
      background: var(--bg);
      border-radius: var(--radius-sm);
      margin-bottom: 20px;
    }
    .trade-market-img {
      width: 64px;
      height: 64px;
      border-radius: 12px;
      object-fit: cover;
      flex-shrink: 0;
    }
    .trade-market-question {
      font-size: 14px;
      font-weight: 500;
      line-height: 1.4;
      color: var(--text);
    }
    
    .trade-outcomes {
      display: flex;
      flex-direction: column;
      gap: 12px;
      margin-bottom: 20px;
    }
    .trade-outcome {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 14px 16px;
      border-radius: var(--radius-sm);
      cursor: pointer;
      border: 2px solid var(--border);
      transition: all 0.2s;
      background: var(--bg);
    }
    .trade-outcome.active { 
      border-color: var(--green); 
      background: var(--green-soft);
    }
    .trade-outcome-left {
      display: flex;
      align-items: center;
      gap: 12px;
      flex: 1;
    }
    .trade-outcome-label {
      font-size: 15px;
      font-weight: 600;
      color: var(--text);
      flex: 1;
    }
    .trade-outcome-percent {
      font-size: 16px;
      font-weight: 700;
      color: var(--text);
      min-width: 50px;
      text-align: right;
    }
    .trade-outcome-price {
      font-size: 18px;
      font-weight: 700;
      color: var(--green);
      min-width: 60px;
      text-align: right;
    }
    .trade-outcome.active .trade-outcome-price {
      color: var(--accent);
    }
    
    .trade-amount {
      margin-bottom: 20px;
    }
    .trade-amount label {
      display: block;
      font-size: 12px;
      font-weight: 600;
      color: var(--text-muted);
      text-transform: uppercase;
      margin-bottom: 8px;
    }
    .trade-amount input {
      width: 100%;
      padding: 16px;
      font-size: 18px;
      font-family: inherit;
      border: 2px solid var(--border);
      border-radius: var(--radius-sm);
      text-align: center;
      background: var(--bg);
    }
    .trade-amount input:focus {
      outline: none;
      border-color: var(--accent);
    }
    
    .trade-summary {
      padding: 16px;
      background: var(--bg);
      border-radius: var(--radius-sm);
      margin-bottom: 20px;
    }
    .trade-summary-row {
      display: flex;
      justify-content: space-between;
      margin-bottom: 8px;
      font-size: 14px;
    }
    .trade-summary-row:last-child { margin-bottom: 0; }
    .trade-summary-row span:first-child { color: var(--text-muted); }
    .trade-summary-row span:last-child { font-weight: 600; color: var(--text); }
    
    .trade-submit {
      width: 100%;
      padding: 16px;
      font-size: 16px;
      font-weight: 600;
      font-family: inherit;
      background: var(--accent);
      color: white;
      border: none;
      border-radius: 30px;
      cursor: pointer;
    }
    .trade-submit:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    /* Loading State */
    .loading {
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 40px;
      color: var(--text-muted);
      font-size: 14px;
    }
  </style>
</head>
<body>
  <!-- Splash Screen -->
  <div class="splash-screen" id="splashScreen">
    <div class="splash-logo">
      <span class="splash-logo-icon">✦</span>
      <span class="splash-logo-text">Polygram</span>
    </div>
    <div class="splash-spinner"></div>
  </div>

  <!-- Onboarding Screen -->
  <div class="onboarding-screen" id="onboardingScreen">
    <div class="onboarding-card">
      <div class="onboarding-logo">
        <span class="onboarding-logo-icon">✦</span>
        <span class="onboarding-logo-text">Polygram</span>
      </div>
      <h2 class="onboarding-title">Welcome to Polygram</h2>
      <p class="onboarding-subtitle">Trade prediction markets directly from Telegram. Fast, simple, powerful.</p>
      
      <div class="feature-list">
        <div class="feature-item">
          <div class="feature-icon"></div>
          <div class="feature-text">Instant trades on Polymarket via custodial wallet</div>
        </div>
        <div class="feature-item">
          <div class="feature-icon"></div>
          <div class="feature-text">Real-time markets, trending events, live odds</div>
        </div>
        <div class="feature-item">
          <div class="feature-icon"></div>
          <div class="feature-text">Secure wallet with USDC on Polygon network</div>
        </div>
      </div>
      
      <input type="text" class="passkey-input" id="passkeyInput" placeholder="Enter passkey" maxlength="20" />
      <div class="passkey-error" id="passkeyError">Invalid passkey. Please try again.</div>
      <button class="passkey-btn" id="passkeyBtn">Continue</button>
      
      <p class="passkey-hint">Don't have a passkey? <a href="https://t.me/publiclabs" target="_blank">Join our Telegram</a></p>
    </div>
  </div>

  <!-- Main App -->
  <div class="app-shell" id="appShell">
    <!-- Header -->
    <header class="header">
      <div class="header-logo">
        <span class="header-logo-icon">✦</span>
        <span class="header-logo-text">Polygram</span>
      </div>
    </header>

    <!-- Balance Card -->
    <div class="card balance-card">
      <div class="balance-top-bar"></div>
      <div class="balance-amount" id="totalBalance">$0.00</div>
      <div class="balance-breakdown" id="balanceBreakdown">
        USDC: <span id="usdcBalance">$0.00</span> | Positions: <span id="positionsValue">$0.00</span>
      </div>
      <div class="balance-dot"></div>
    </div>

    <!-- Wallet Card -->
    <div class="card">
      <div class="wallet-section">
        <div class="wallet-row">
          <div class="wallet-label">
            <span class="wallet-icon">◎</span>
            <span>SOL Wallet</span>
          </div>
          <div class="wallet-address-row">
            <span class="wallet-address" id="solWalletAddress" title="Click to copy">Loading...</span>
            <button class="copy-btn" id="copySolBtn" title="Copy SOL address">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
              </svg>
            </button>
          </div>
        </div>
        <div class="wallet-row">
          <div class="wallet-label">
            <span class="wallet-icon">$</span>
            <span>USDC Wallet</span>
          </div>
          <div class="wallet-address-row">
            <span class="wallet-address" id="usdcWalletAddress" title="Click to copy">Loading...</span>
            <button class="copy-btn" id="copyUsdcBtn" title="Copy USDC address">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
              </svg>
            </button>
          </div>
        </div>
      </div>
      <div class="wallet-status" id="walletStatusBar">Checking status...</div>
      </div>

    <!-- Positions Card -->
    <div class="card" id="positionsCard" style="display: none;">
      <h3 style="margin-bottom: 12px; font-size: 16px; font-weight: 600;">Active Positions</h3>
      <div id="positionsList">
        <div class="loading" style="padding: 10px;">No active positions</div>
      </div>
    </div>

    <!-- Markets Card -->
    <div class="card">
      <div class="category-scroll-container">
        <div class="category-scroll" id="categoryScroll">
          <div class="loading" style="padding: 10px;">Loading categories...</div>
        </div>
      </div>
      
      <div class="markets-list" id="marketsList">
        <div class="loading">Loading markets...</div>
      </div>
    </div>
  </div>

  <!-- Trade Modal -->
  <div class="modal-overlay" id="tradeModal">
    <div class="modal">
      <div class="modal-handle"></div>
      <h3 class="modal-title">Place Trade</h3>
      <p class="modal-subtitle">Select your position and amount</p>
      
      <div class="trade-market-info" id="tradeMarketInfo">
        <img class="trade-market-img" id="tradeMarketImg" src="" alt="" onerror="this.style.display='none'" />
        <div class="trade-market-question" id="tradeMarketQuestion"></div>
      </div>
      
      <div class="trade-outcomes" id="tradeOutcomes">
        <!-- Outcomes will be dynamically generated -->
      </div>
      
      <div class="trade-amount">
        <label>Amount (USDC)</label>
        <input type="number" id="tradeAmount" placeholder="10.00" min="1" step="1" />
      </div>
      
      <div class="trade-summary">
        <div class="trade-summary-row">
          <span>Shares</span>
          <span id="tradeShares">0</span>
        </div>
        <div class="trade-summary-row">
          <span>Avg Price</span>
          <span id="tradeAvgPrice">--¢</span>
        </div>
        <div class="trade-summary-row">
          <span>Potential Return</span>
          <span id="tradePotential">$0.00</span>
        </div>
      </div>
      
      <button class="trade-submit" id="tradeSubmit" disabled>Connect Wallet First</button>
    </div>
  </div>

  <!-- Fund Modal -->
  <div class="modal-overlay" id="fundModal">
    <div class="modal">
      <div class="modal-handle"></div>
      <h3 class="modal-title" id="fundModalTitle">Fund Wallet</h3>
      <p class="modal-subtitle" id="fundModalSubtitle">Send funds to your wallet address</p>
      
      <div class="fund-info" id="fundInfo">
        <div class="fund-currency-selector">
          <button class="currency-btn active" data-currency="usdc">USDC</button>
          <button class="currency-btn" data-currency="sol">SOL</button>
        </div>
        
        <div class="fund-amount">
          <label>Amount</label>
          <input type="number" id="fundAmount" placeholder="10.00" min="1" step="0.01" />
        </div>
        
        <div class="fund-address-section">
          <label>Send to this address:</label>
          <div class="fund-address-display">
            <code id="fundAddress">Loading...</code>
            <button class="copy-btn" id="copyFundAddressBtn">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
              </svg>
            </button>
          </div>
        </div>
        
        <div class="fund-instructions" id="fundInstructions">
          <p>Send USDC (Polygon network) to the address above. Minimum deposit: $10</p>
        </div>
        
        <div class="fund-summary">
          <div class="fund-summary-row">
            <span>Network</span>
            <span id="fundNetwork">Polygon</span>
          </div>
          <div class="fund-summary-row">
            <span>Minimum</span>
            <span id="fundMinimum">$10.00</span>
          </div>
        </div>
      </div>
      
      <button class="trade-submit" id="fundSubmitBtn">I've Sent the Funds</button>
      <button class="modal-close-btn" id="closeFundModal">Cancel</button>
    </div>
  </div>

  <!-- Payout Modal -->
  <div class="modal-overlay" id="payoutModal">
    <div class="modal">
      <div class="modal-handle"></div>
      <h3 class="modal-title">Claim Payout</h3>
      <p class="modal-subtitle">Withdraw winnings from your winning positions</p>
      
      <div class="payout-list" id="payoutList">
        <!-- Payout items will be dynamically generated -->
      </div>
      
      <button class="modal-close-btn" id="closePayoutModal">Close</button>
    </div>
  </div>

  <script>
    // =====================
    // STATE
    // =====================
    const state = {
      telegramId: null,
      wallet: null,
      markets: [],
      selectedMarket: null,
      selectedCategory: null,
      selectedSportType: null, // 'games' or 'props'
      tradeSide: 'yes',
      selectedOutcomeIndex: 0,
    };

    // =====================
    // HAPTIC FEEDBACK
    // =====================
    function hapticFeedback(type = 'light') {
      if (window.Telegram?.WebApp?.HapticFeedback) {
        const haptic = window.Telegram.WebApp.HapticFeedback;
        switch(type) {
          case 'light':
            haptic.impactOccurred('light');
            break;
          case 'medium':
            haptic.impactOccurred('medium');
            break;
          case 'heavy':
            haptic.impactOccurred('heavy');
            break;
          case 'success':
            haptic.notificationOccurred('success');
            break;
          case 'error':
            haptic.notificationOccurred('error');
            break;
          case 'warning':
            haptic.notificationOccurred('warning');
            break;
        }
      } else if (navigator.vibrate) {
        // Fallback for non-Telegram environments
        const patterns = {
          light: 10,
          medium: 20,
          heavy: 30,
          success: [10, 50, 10],
          error: [20, 50, 20, 50, 20],
          warning: [10, 50, 20]
        };
        navigator.vibrate(patterns[type] || 10);
      }
    }

    // =====================
    // TELEGRAM INIT
    // =====================
    function initTelegram() {
      if (window.Telegram?.WebApp) {
        const tg = window.Telegram.WebApp;
        tg.ready();
        tg.expand();
        
        // Get Telegram user ID - try multiple methods
        const userId = tg.initDataUnsafe?.user?.id || 
                      tg.initData?.user?.id ||
                      tg.initDataUnsafe?.user_id ||
                      null;
        
        if (userId) {
          // Ensure it's a string and valid
          state.telegramId = String(userId);
          console.log('Telegram user ID:', state.telegramId);
          console.log('Telegram user data:', tg.initDataUnsafe?.user);
      } else {
          // Fallback for testing/development
          const demoId = localStorage.getItem('demo_telegram_id') || `demo_${Date.now()}`;
          localStorage.setItem('demo_telegram_id', demoId);
          state.telegramId = demoId;
          console.warn('No Telegram user ID found, using demo ID:', state.telegramId);
        }
      } else {
        // Fallback for non-Telegram environments
        const demoId = localStorage.getItem('demo_telegram_id') || `demo_${Date.now()}`;
        localStorage.setItem('demo_telegram_id', demoId);
        state.telegramId = demoId;
        console.warn('Not running in Telegram, using demo ID:', state.telegramId);
      }
      
      console.log('Final Telegram ID:', state.telegramId);
    }

    // =====================
    // UTILS
    // =====================
    function shortAddr(addr) {
      if (!addr) return '...';
      return `${addr.slice(0, 6)}...${addr.slice(-4)}`;
    }

    function formatUSD(num) {
      return `$${Number(num || 0).toFixed(2)}`;
    }

    function formatVolume(num) {
      if (!num) return '$0';
      if (num >= 1000000) return `$${(num / 1000000).toFixed(1)}M`;
      if (num >= 1000) return `$${(num / 1000).toFixed(1)}K`;
      return `$${num.toFixed(0)}`;
    }

    // =====================
    // ONBOARDING FLOW
    // =====================
    const STORAGE_KEY = 'polygram_access';
    const VALID_PASSKEYS = ['EARLYBIRD', 'POLYGRAM2024', 'TRADEPRO', 'BETAACCESS', 'PUBLICLABS'];

    function checkAccess() {
      const urlParams = new URLSearchParams(window.location.search);
      if (urlParams.get('bypass') === 'true') return true;
      
      const stored = localStorage.getItem(STORAGE_KEY);
      if (stored) {
        try {
          const data = JSON.parse(stored);
          if (data.validated) return true;
        } catch (e) {}
      }
      return false;
    }

    function grantAccess(passkey) {
      localStorage.setItem(STORAGE_KEY, JSON.stringify({
        validated: true,
        passkey: passkey,
        timestamp: Date.now()
      }));
    }

    function showSplash() {
      document.getElementById('splashScreen').classList.remove('hidden');
    }

    function hideSplash() {
      document.getElementById('splashScreen').classList.add('hidden');
    }

    function showOnboarding() {
      document.getElementById('onboardingScreen').classList.add('visible');
    }

    function hideOnboarding() {
      document.getElementById('onboardingScreen').classList.remove('visible');
    }

    function showMainApp() {
      document.getElementById('appShell').classList.add('visible');
      bootstrapApp();
    }

    function initOnboarding() {
      const input = document.getElementById('passkeyInput');
      const btn = document.getElementById('passkeyBtn');
      const error = document.getElementById('passkeyError');

      btn.addEventListener('click', () => {
        const passkey = input.value.trim().toUpperCase();
        
        if (VALID_PASSKEYS.includes(passkey)) {
          btn.textContent = '✓';
          grantAccess(passkey);
          setTimeout(() => {
            hideOnboarding();
            showMainApp();
          }, 500);
        } else {
          input.classList.add('error');
          error.classList.add('visible');
          setTimeout(() => {
            input.classList.remove('error');
          }, 400);
        }
      });

      input.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') btn.click();
      });

      input.addEventListener('input', () => {
        error.classList.remove('visible');
      });
    }

    // =====================
    // WALLET MANAGEMENT
    // =====================
    // =====================
    // WALLET - CLIENT SIDE
    // =====================
    const WALLET_STORAGE_KEY = 'polygram_wallet';

    function generateSolanaAddress() {
      const chars = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
      let result = '';
      for (let i = 0; i < 44; i++) {
        result += chars.charAt(Math.floor(Math.random() * chars.length));
      }
      return result;
    }

    function getOrCreateWallet() {
      // Check localStorage first
      const stored = localStorage.getItem(WALLET_STORAGE_KEY);
      if (stored) {
        try {
          const wallet = JSON.parse(stored);
          if (wallet.polygon && wallet.solana) {
            console.log('Loaded existing wallet from localStorage');
            return wallet;
          }
        } catch (e) {
          console.error('Failed to parse stored wallet:', e);
        }
      }

      // Generate new wallets
      console.log('Generating new wallets...');
      
      // Generate Polygon wallet using ethers.js
      const polygonWallet = ethers.Wallet.createRandom();
      
      // Generate Solana-style address
      const solanaAddress = generateSolanaAddress();

      const wallet = {
        polygon: polygonWallet.address,
        polygonPrivateKey: polygonWallet.privateKey, // Store encrypted in production!
        solana: solanaAddress,
        solanaPrivateKey: 'sol_' + solanaAddress.substring(0, 32), // Placeholder
        userId: state.telegramId,
        createdAt: new Date().toISOString(),
      };

      // Save to localStorage
      localStorage.setItem(WALLET_STORAGE_KEY, JSON.stringify(wallet));
      console.log('New wallet created and saved');
      
      return wallet;
    }

    async function loadWallet() {
      try {
        console.log('Loading/creating wallet for:', state.telegramId);
        
        // Call API to get or create wallet
        const resp = await fetch(`/api/wallet?telegram_id=${encodeURIComponent(state.telegramId)}`);
        
        if (!resp.ok) {
          let errorData;
          try {
            errorData = await resp.json();
          } catch (e) {
            errorData = { message: `HTTP ${resp.status}: ${resp.statusText}` };
          }
          
          // Check for specific error types
          if (errorData.error === 'encryption_key_error' || errorData.code === 'ENCRYPTION_KEY_MISSING' || errorData.code === 'ENCRYPTION_KEY_INVALID_LENGTH') {
            throw new Error('SERVER_CONFIG_ERROR');
          }
          
          throw new Error(errorData.message || `HTTP ${resp.status}: Failed to load wallet`);
        }
        
        const data = await resp.json();
        
        if (!data.success || !data.wallet) {
          // Check if there's a warning (like missing Supabase)
          if (data.warning) {
            console.warn('Wallet warning:', data.warning);
          }
          throw new Error('Invalid wallet response from server');
        }
        
        const wallet = {
          solana: data.wallet.solana,
          polygon: data.wallet.polygon,
          userId: data.wallet.userId,
          createdAt: data.wallet.createdAt
        };
        
        state.wallet = wallet;
        
        console.log('Wallet loaded:', wallet.polygon, wallet.solana, data.isNew ? '(new)' : '(existing)');
        
        // Display SOL wallet
        const solEl = document.getElementById('solWalletAddress');
        if (solEl) solEl.textContent = wallet.solana;
        
        // Display USDC wallet (Polygon)
        const usdcEl = document.getElementById('usdcWalletAddress');
        if (usdcEl) usdcEl.textContent = wallet.polygon;
        
        // Update status
        const statusEl = document.getElementById('walletStatusBar');
        if (statusEl) {
          // Check for warnings (like encryption key missing)
          if (data.warning || data.error === 'encryption_key_missing') {
            statusEl.textContent = '⚠ Wallets created (not saved - config issue)';
            statusEl.style.background = 'var(--yellow)';
            statusEl.style.color = 'var(--text)';
            console.warn('Wallet warning:', data.warning || data.help);
          } else {
            if (data.isNew) {
              statusEl.textContent = '✓ Wallets created - fund to trade';
            } else {
              statusEl.textContent = '✓ Wallets loaded - fund to trade';
            }
            statusEl.style.background = 'var(--accent)';
            statusEl.style.color = 'white';
          }
        }
        
        // Setup copy buttons and make addresses clickable
        setupCopyButton('copySolBtn', wallet.solana);
        setupCopyButton('copyUsdcBtn', wallet.polygon);
        setupClickableAddress('solWalletAddress', wallet.solana);
        setupClickableAddress('usdcWalletAddress', wallet.polygon);
        
        // Load balance from Supabase and on-chain
        await loadBalance();
        
      } catch (err) {
        console.error('Wallet error:', err);
        const solEl = document.getElementById('solWalletAddress');
        const usdcEl = document.getElementById('usdcWalletAddress');
        const statusEl = document.getElementById('walletStatusBar');
        
        if (solEl) solEl.textContent = 'Error loading';
        if (usdcEl) usdcEl.textContent = 'Error loading';
        
        // Show user-friendly error message
        let errorMsg = 'Error loading wallet';
        let isConfigError = false;
        
        if (err.message) {
          // Check for specific error types
          if (err.message === 'SERVER_CONFIG_ERROR' || 
              err.message.includes('ENCRYPTION_KEY') || 
              err.message.includes('encryption_key_error') ||
              err.message.includes('ENCRYPTION_KEY must be exactly 64')) {
            errorMsg = 'Server configuration error. Please contact support.';
            isConfigError = true;
          } else if (err.message.includes('database_not_configured') || err.message.includes('Supabase not configured')) {
            errorMsg = 'Database not configured. Please contact support.';
            isConfigError = true;
          } else if (err.message.includes('missing_user_id') || err.message.includes('telegram_id is required')) {
            errorMsg = 'Unable to identify user. Please refresh the page.';
          } else if (err.message.includes('Failed to fetch') || err.message.includes('NetworkError')) {
            errorMsg = 'Network error. Please check your connection.';
          } else {
            // Show shortened error message
            const shortMsg = err.message.length > 60 ? err.message.substring(0, 60) + '...' : err.message;
            errorMsg = shortMsg;
          }
        }
        
        if (statusEl) {
          statusEl.textContent = errorMsg;
          if (isConfigError) {
            statusEl.style.background = 'var(--red)';
            statusEl.style.color = 'white';
          } else {
            statusEl.style.background = 'var(--accent)';
            statusEl.style.color = 'white';
          }
        }
        
        // Log full error for debugging
        console.error('Full wallet error:', err);
        console.error('Error stack:', err.stack);
      }
    }

    async function copyToClipboard(text) {
      try {
        await navigator.clipboard.writeText(text);
        hapticFeedback('light');
        return true;
      } catch (err) {
        console.error('Copy failed:', err);
        // Fallback for older browsers
        const textArea = document.createElement('textarea');
        textArea.value = text;
        textArea.style.position = 'fixed';
        textArea.style.opacity = '0';
        document.body.appendChild(textArea);
        textArea.select();
        document.execCommand('copy');
        document.body.removeChild(textArea);
        hapticFeedback('light');
        return true;
      }
    }

    function setupCopyButton(btnId, address) {
      const btn = document.getElementById(btnId);
      if (!btn || !address) return;
      
      btn.onclick = async () => {
        const success = await copyToClipboard(address);
        if (success) {
          btn.classList.add('copied');
          btn.innerHTML = `<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="20 6 9 17 4 12"></polyline></svg>`;
          
          setTimeout(() => {
            btn.classList.remove('copied');
            btn.innerHTML = `<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>`;
          }, 2000);
        }
      };
    }

    function setupClickableAddress(elementId, address) {
      const el = document.getElementById(elementId);
      if (!el || !address) return;
      
      el.onclick = async () => {
        const success = await copyToClipboard(address);
        if (success) {
          // Visual feedback
          const originalBg = el.style.background;
          el.style.background = 'var(--green-soft)';
          el.textContent = 'Copied!';
          
          setTimeout(() => {
            el.style.background = originalBg;
            el.textContent = address;
          }, 1500);
        }
      };
    }

    async function loadBalance() {
      if (!state.wallet) {
      document.getElementById('usdcBalance').textContent = '$0.00';
      document.getElementById('positionsValue').textContent = '$0.00';
      document.getElementById('totalBalance').textContent = '$0.00';
        return;
      }

      try {
        // Try to fetch balance from API
        const resp = await fetch(`/api/balances?telegram_id=${encodeURIComponent(state.telegramId)}`);
        if (resp.ok) {
          const data = await resp.json();
          if (data.success) {
            document.getElementById('usdcBalance').textContent = `$${data.usdc.toFixed(2)}`;
            document.getElementById('positionsValue').textContent = `$${data.positions.toFixed(2)}`;
            document.getElementById('totalBalance').textContent = `$${data.total.toFixed(2)}`;
            
            // Update wallet status if available
            if (data.walletStatus) {
              const statusEl = document.getElementById('walletStatusBar');
              if (statusEl) {
                if (data.walletStatus.exists) {
                  if (data.walletStatus.clobRegistered && data.walletStatus.usdcApproved) {
                    statusEl.textContent = '✓ Wallet ready for trading';
                  } else if (data.walletStatus.clobRegistered) {
                    statusEl.textContent = '⚠ CLOB registered - approve USDC to trade';
                  } else {
                    statusEl.textContent = '⚠ Register with CLOB to trade';
                  }
                } else {
                  statusEl.textContent = '✓ Wallets ready - fund to trade';
                }
              }
            }
            return;
          }
        }
      } catch (err) {
        console.log('[loadBalance] API not available, using defaults:', err.message);
      }

      // Fallback: show zero balances
      document.getElementById('usdcBalance').textContent = '$0.00';
      document.getElementById('positionsValue').textContent = '$0.00';
      document.getElementById('totalBalance').textContent = '$0.00';
    }

    // =====================
    // CATEGORIES
    // =====================
    async function fetchCategories() {
      try {
        const resp = await fetch('/api/categories');
        if (resp.ok) {
          const data = await resp.json();
          return data.categories || [];
        }
      } catch (err) {
        console.error('[fetchCategories] Error:', err);
      }
      return [];
    }

    function renderCategories(categories) {
      const container = document.getElementById('categoryScroll');
      if (!container) return;

      container.innerHTML = categories.map(cat => {
        const isActive = state.selectedCategory === cat.slug;
        return `
          <button class="category-chip ${isActive ? 'active' : ''}" 
                  data-kind="${cat.slug}" 
                  data-id="${cat.id}">
            ${cat.icon} ${cat.label}
          </button>
        `;
      }).join('');

      // Add click handlers
          container.querySelectorAll('.category-chip').forEach(chip => {
            chip.addEventListener('click', () => {
              hapticFeedback('light');
              const kind = chip.dataset.kind;
              state.selectedCategory = kind;
              
              // Update active state
              container.querySelectorAll('.category-chip').forEach(c => c.classList.remove('active'));
              chip.classList.add('active');
              
              // Scroll to active chip (center it if possible)
              chip.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'center' });
              
              // If sports is clicked, show subcategories instead of markets
              if (kind === 'sports') {
                showSportsSubcategories();
              } else {
                // Fetch markets for this category
                fetchMarkets(kind);
              }
            });
          });
    }

    async function showSportsSubcategories() {
      // Show Games and Props as top-level sports subcategories
      const list = document.getElementById('marketsList');
      list.innerHTML = `
        <div style="margin-bottom: 16px; font-size: 14px; color: var(--text-muted);">
          Select a category:
        </div>
        <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px;">
          <button class="category-chip" 
                  data-sport-type="games" 
                  style="width: 100%; justify-content: flex-start; padding: 12px 16px;">
            Games
          </button>
          <button class="category-chip" 
                  data-sport-type="props" 
                  style="width: 100%; justify-content: flex-start; padding: 12px 16px;">
            Props
          </button>
        </div>
      `;
      
      // Add click handlers for Games and Props
          list.querySelectorAll('.category-chip').forEach(btn => {
            btn.addEventListener('click', () => {
              hapticFeedback('light');
              const sportType = btn.dataset.sportType;
              state.selectedSportType = sportType;
              showSportsByType(sportType);
            });
          });
    }

    async function showSportsByType(type) {
      // type is either "games" or "props"
      try {
        const resp = await fetch('/api/sports-subcategories');
        if (resp.ok) {
          const data = await resp.json();
          const subcategories = data.subcategories || [];
          
          if (subcategories.length > 0) {
            // Render sports subcategories in the markets list area
            const list = document.getElementById('marketsList');
            list.innerHTML = `
              <div style="margin-bottom: 16px; font-size: 14px; color: var(--text-muted);">
                Select a sport:
              </div>
              <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px;">
                ${subcategories.map(sub => `
                  <button class="category-chip" 
                          data-sport="${sub.slug}" 
                          data-sport-type="${type}"
                          style="width: 100%; justify-content: flex-start; padding: 12px 16px;">
                    ${sub.label}
                  </button>
                `).join('')}
              </div>
            `;
            
            // Add click handlers for sports subcategories
            list.querySelectorAll('.category-chip').forEach(btn => {
              btn.addEventListener('click', () => {
                hapticFeedback('light');
                const sportSlug = btn.dataset.sport;
                const sportType = btn.dataset.sportType;
                state.selectedCategory = sportSlug;
                state.selectedSportType = sportType;
                // Fetch markets for this sport, passing sportType to filter games vs props
                fetchMarkets(sportSlug, sportType);
              });
            });
          } else {
            // Fallback: fetch sports markets directly
            fetchMarkets('sports');
          }
        } else {
          // Fallback: fetch sports markets directly
          fetchMarkets('sports');
        }
      } catch (err) {
        console.error('[showSportsByType] Error:', err);
        // Fallback: fetch sports markets directly
        fetchMarkets('sports');
      }
    }

    // =====================
    // MARKETS
    // =====================
    async function fetchMarkets(kind = 'trending', sportType = null) {
      const list = document.getElementById('marketsList');
      list.innerHTML = '<div class="loading">Loading markets...</div>';

      try {
        console.log('[fetchMarkets] Fetching:', kind, 'sportType:', sportType);
        // Reduce limit for faster loading - 1000 markets is plenty for initial display
        // Only show markets with volume - filter out zero-volume markets (use $0.01 minimum)
        let apiUrl = `/api/markets?kind=${kind}&limit=1000&minVolume=0.01`;
        if (sportType) {
          apiUrl += `&sportType=${sportType}`;
        }
        console.log('[fetchMarkets] URL:', apiUrl);
        
        const resp = await fetch(apiUrl);
        console.log('[fetchMarkets] Status:', resp.status, resp.statusText);
        
        if (!resp.ok) {
          const errorText = await resp.text();
          console.error('[fetchMarkets] Error response:', errorText);
          throw new Error(`HTTP ${resp.status}: ${errorText.substring(0, 100)}`);
        }
        
        const data = await resp.json();
        console.log('[fetchMarkets] Response data:', data);
        console.log('[fetchMarkets] Markets count:', data.markets?.length || 0);
        
        const markets = data.markets || [];
        
        if (markets.length > 0) {
          console.log('[fetchMarkets] First market:', markets[0]);
          state.markets = markets;
          renderMarkets(markets);
        } else {
          console.log('[fetchMarkets] No markets in response');
          list.innerHTML = `<div class="loading">No markets found. <br><small style="color:var(--text-muted)">API responded but returned 0 markets</small></div>`;
        }
      } catch (err) {
        console.error('[fetchMarkets] Error:', err);
        list.innerHTML = `
          <div class="loading" style="color:#ef4444;">
            Failed to load markets<br>
            <small style="color:var(--text-muted)">${err.message}</small>
          </div>
        `;
      }
    }

    function renderMarkets(markets) {
      const list = document.getElementById('marketsList');
      
      // Check if we should group by events (for NFL games)
      const shouldGroupByEvent = state.selectedCategory === 'nfl' && 
                                  markets.some(m => m.eventId && m.eventTitle);
      
      if (shouldGroupByEvent && markets.length > 0) {
        // Group markets by event
        const eventsMap = new Map();
        markets.forEach(m => {
          const eventId = m.eventId || 'ungrouped';
          const eventTitle = m.eventTitle || 'Other Markets';
          
          if (!eventsMap.has(eventId)) {
            eventsMap.set(eventId, {
              eventId: eventId,
              eventTitle: eventTitle,
              eventImage: m.eventImage || m.image,
              eventVolume: m.eventVolume || 0,
              eventStartDate: m.eventStartDate,
              markets: []
            });
          }
          eventsMap.get(eventId).markets.push(m);
        });
        
        // Sort events by volume (highest first) before rendering
        const sortedEvents = Array.from(eventsMap.values()).sort((a, b) => {
          const volA = a.eventVolume || a.markets.reduce((sum, m) => sum + (m.volume24hr || m.volume || 0), 0);
          const volB = b.eventVolume || b.markets.reduce((sum, m) => sum + (m.volume24hr || m.volume || 0), 0);
          return volB - volA;
        });
        
        // Render events with their markets
        list.innerHTML = sortedEvents.map(event => {
          const eventVol = event.eventVolume || 
                          event.markets.reduce((sum, m) => sum + (m.volume24hr || m.volume || 0), 0);
          const eventImg = event.eventImage || event.markets[0]?.image || '';
          const hasImage = eventImg && eventImg.trim() !== '';
          
          // Get week tag if available
          const weekTag = event.markets[0]?.eventTags?.find(t => 
            (typeof t === 'string' ? t : (t.slug || t.label || '')).toLowerCase().includes('week')
          );
          const weekLabel = weekTag ? (typeof weekTag === 'string' ? weekTag : (weekTag.label || weekTag.slug || '')) : '';
          
          // Find primary moneyline market (the main game outcome)
          const moneylineMarket = event.markets.find(m => {
            const q = (m.question || '').toLowerCase();
            return q.includes('moneyline') || q.includes('ml') || 
                   (q.includes(' vs ') && !q.includes('spread') && !q.includes('total') && !q.includes('o/u'));
          }) || event.markets[0];
          
          // Get primary prices for moneyline (first two outcomes)
          const primaryPrices = moneylineMarket?.outcomePrices || [];
          const primaryOutcomes = moneylineMarket?.outcomes || [];
          const price1 = primaryPrices[0] !== undefined ? (parseFloat(primaryPrices[0]) * 100).toFixed(0) + '¢' : '--';
          const price2 = primaryPrices[1] !== undefined ? (parseFloat(primaryPrices[1]) * 100).toFixed(0) + '¢' : '--';
          const outcome1 = primaryOutcomes[0] || 'Yes';
          const outcome2 = primaryOutcomes[1] || 'No';
          
          return `
            <div class="event-group collapsed" data-event-id="${event.eventId}">
              <div class="event-header collapsed" data-collapse-target="${event.eventId}">
                ${hasImage ? `<img class="event-image" src="${eventImg}" alt="" onerror="this.classList.add('hidden')" />` : ''}
                <div class="event-info">
                  <div class="event-title">
                    ${weekLabel ? `<span class="week-tag">${weekLabel}</span>` : ''}
                    <span class="event-title-text">${event.eventTitle}</span>
                  </div>
                  <div class="event-meta">
                    <span>Vol: ${formatVolume(eventVol)}</span>
                    <span>${event.markets.length} market${event.markets.length !== 1 ? 's' : ''}</span>
                  </div>
                </div>
                <div class="event-primary-prices">
                  ${primaryPrices.length >= 2 ? `
                    <button class="event-price-btn event-price-btn-1" 
                            data-market-id="${moneylineMarket?.id}" 
                            data-outcome-index="0">
                      ${outcome1} ${price1}
                    </button>
                    <button class="event-price-btn event-price-btn-2" 
                            data-market-id="${moneylineMarket?.id}" 
                            data-outcome-index="1">
                      ${outcome2} ${price2}
                    </button>
                  ` : ''}
                </div>
                <div class="event-collapse-icon">▼</div>
              </div>
              <div class="event-markets" data-event-markets="${event.eventId}">
                ${event.markets.map(m => {
                  const prices = m.outcomePrices || [];
                  const outcomes = m.outcomes || ["Yes", "No"];
                  const vol = m.volume24hr || m.volume || 0;
                  
                  return `
                    <div class="market-outcome-item" data-id="${m.id}">
                      <div class="outcome-label">${m.question}</div>
                      <div class="outcome-buttons">
                        ${outcomes.map((outcome, idx) => {
                          const price = prices[idx] !== undefined ? (parseFloat(prices[idx]) * 100).toFixed(0) + '¢' : '--';
                          const isYes = outcome.toLowerCase() === 'yes' || idx === 0;
                          return `
                            <div class="outcome-button-group">
                              <span class="outcome-price">${price}</span>
                              <button class="outcome-btn ${isYes ? 'outcome-yes' : 'outcome-no'}" 
                                      data-market-id="${m.id}" 
                                      data-outcome-index="${idx}">
                                ${outcome}
                              </button>
                            </div>
                          `;
                        }).join('')}
                      </div>
                    </div>
                  `;
                }).join('')}
              </div>
            </div>
          `;
        }).join('');
      } else {
        // Render as flat list (original behavior)
      list.innerHTML = markets.map(m => {
        const prices = m.outcomePrices || [];
          const outcomes = m.outcomes || ["Yes", "No"];
        const vol = m.volume24hr || m.volume || 0;
          const imgUrl = m.image || m.eventImage || m.icon || '';
          const hasImage = imgUrl && imgUrl.trim() !== '';
        
        return `
            <div class="market-card" data-id="${m.id}">
              <div class="market-card-header">
                ${hasImage ? `<img class="market-image" src="${imgUrl}" alt="" onerror="this.classList.add('hidden')" />` : ''}
                <div class="market-title">${m.question}</div>
              </div>
              <div class="market-outcomes">
                ${outcomes.map((outcome, idx) => {
                  const price = prices[idx] !== undefined ? (parseFloat(prices[idx]) * 100).toFixed(0) + '¢' : '--';
                  const isYes = outcome.toLowerCase() === 'yes' || idx === 0;
                  return `
                    <div class="outcome-button-group">
                      <span class="outcome-price">${price}</span>
                      <button class="outcome-btn ${isYes ? 'outcome-yes' : 'outcome-no'}" 
                              data-market-id="${m.id}" 
                              data-outcome-index="${idx}">
                        ${outcome}
                      </button>
            </div>
                  `;
                }).join('')}
              </div>
              <div class="market-card-footer">
                <span class="market-volume">${formatVolume(vol)} Vol.</span>
                <span class="market-icon">🎁</span>
            </div>
          </div>
        `;
      }).join('');
      }

      // Add click handlers for event price buttons
      list.querySelectorAll('.event-price-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.stopPropagation();
          hapticFeedback('light');
          const marketId = btn.dataset.marketId;
          const outcomeIndex = parseInt(btn.dataset.outcomeIndex, 10);
          const market = markets.find(m => String(m.id) === String(marketId));
          if (market) {
            openTradeModal(market, outcomeIndex);
          }
        });
      });
      
      // Add click handlers for event price buttons
      list.querySelectorAll('.event-price-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.stopPropagation();
          hapticFeedback('light');
          const marketId = btn.dataset.marketId;
          const outcomeIndex = parseInt(btn.dataset.outcomeIndex, 10);
          const market = markets.find(m => String(m.id) === String(marketId));
          if (market) {
            openTradeModal(market, outcomeIndex);
          }
        });
      });
      
      // Add click handlers for event header collapse/expand
      list.querySelectorAll('.event-header').forEach(header => {
        header.addEventListener('click', (e) => {
          // Don't collapse if clicking on interactive elements
          if (e.target.closest('.outcome-btn') || e.target.closest('.event-price-btn') || e.target.closest('button') || e.target.closest('a')) {
            return;
          }
          
          hapticFeedback('light');
          const eventId = header.dataset.collapseTarget;
          const eventGroup = header.closest('.event-group');
          
          if (eventGroup) {
            eventGroup.classList.toggle('collapsed');
            header.classList.toggle('collapsed');
          }
        });
      });
      
      // Prevent nested market clicks from collapsing
      list.querySelectorAll('.event-markets .market-outcome-item').forEach(item => {
        item.addEventListener('click', (e) => {
          e.stopPropagation();
        });
      });

      // Add click handlers for outcome buttons
      list.querySelectorAll('.outcome-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.stopPropagation();
          hapticFeedback('light');
          const marketId = btn.dataset.marketId;
          const outcomeIndex = parseInt(btn.dataset.outcomeIndex);
          const market = markets.find(m => String(m.id) === marketId || String(m.conditionId) === marketId);
          if (market) {
            state.selectedOutcomeIndex = outcomeIndex;
            openTradeModal(market);
          }
        });
      });

      // Add click handlers for market cards (fallback)
      list.querySelectorAll('.market-card, .market-item').forEach(item => {
        item.addEventListener('click', (e) => {
          if (!e.target.closest('.outcome-btn')) {
            hapticFeedback('light');
            const itemId = String(item.dataset.id);
            const market = markets.find(m => String(m.id) === itemId || String(m.conditionId) === itemId);
          if (market) openTradeModal(market);
          }
        });
      });
    }

    // =====================
    // TRADE MODAL
    // =====================
    function openTradeModal(market) {
      hapticFeedback('medium');
      state.selectedMarket = market;

      // Get all outcomes and prices
      const outcomes = market.outcomes || ["Yes", "No"];
      const prices = market.outcomePrices || [];
      
      // Set market image and question
      const marketImg = document.getElementById('tradeMarketImg');
      const imgUrl = market.image || market.icon || '';
      if (imgUrl) {
        marketImg.src = imgUrl;
        marketImg.style.display = 'block';
      } else {
        marketImg.style.display = 'none';
      }
      document.getElementById('tradeMarketQuestion').textContent = market.question;
      
      // Render all outcomes with percentages
      const outcomesContainer = document.getElementById('tradeOutcomes');
      outcomesContainer.innerHTML = outcomes.map((outcome, index) => {
        // Use 0.5 as fallback to match updateTradeSummary logic
        const price = prices[index] ? parseFloat(prices[index]) : 0.5;
        const percent = (price * 100).toFixed(0);
        const priceCents = (price * 100).toFixed(0);
        const isActive = index === 0; // Default to first outcome
        
        return `
          <div class="trade-outcome ${isActive ? 'active' : ''}" 
               data-outcome-index="${index}" 
               data-outcome="${outcome}">
            <div class="trade-outcome-left">
              <div class="trade-outcome-label">${outcome}</div>
              <div class="trade-outcome-percent">${percent}%</div>
            </div>
            <div class="trade-outcome-price">${priceCents}¢</div>
          </div>
        `;
      }).join('');
      
      // Set default selected outcome
      if (outcomes.length > 0) {
        state.tradeSide = outcomes[0];
        state.selectedOutcomeIndex = 0;
      }
      
      // Add click handlers for outcomes
      outcomesContainer.querySelectorAll('.trade-outcome').forEach(outcomeEl => {
        outcomeEl.addEventListener('click', () => {
          // Remove active from all
          outcomesContainer.querySelectorAll('.trade-outcome').forEach(o => o.classList.remove('active'));
          // Add active to clicked
          outcomeEl.classList.add('active');
          
          state.selectedOutcomeIndex = parseInt(outcomeEl.dataset.outcomeIndex);
          state.tradeSide = outcomeEl.dataset.outcome;
          
          updateTradeSummary();
        });
      });
      
      document.getElementById('tradeAmount').value = '';
      updateTradeSummary();
      
      document.getElementById('tradeModal').classList.add('visible');
    }

    function closeTradeModal() {
      hapticFeedback('light');
      document.getElementById('tradeModal').classList.remove('visible');
      state.selectedMarket = null;
    }

    function updateTradeSummary() {
      const amount = parseFloat(document.getElementById('tradeAmount').value) || 0;
      const prices = state.selectedMarket?.outcomePrices || [];
      const priceIdx = state.selectedOutcomeIndex !== undefined 
        ? state.selectedOutcomeIndex 
        : (state.tradeSide === 'yes' ? 0 : 1);
      const price = prices[priceIdx] ? parseFloat(prices[priceIdx]) : 0.5;
      const outcomeLabel = state.selectedMarket?.outcomes?.[priceIdx] || state.tradeSide || 'Yes';
      
      const shares = price > 0 ? (amount / price).toFixed(2) : 0;
      const potential = (shares * 1).toFixed(2);
      
      document.getElementById('tradeShares').textContent = shares;
      document.getElementById('tradeAvgPrice').textContent = `${(price * 100).toFixed(0)}¢`;
      document.getElementById('tradePotential').textContent = `$${potential}`;
      
      const btn = document.getElementById('tradeSubmit');
      if (state.wallet && amount > 0) {
        btn.disabled = false;
        btn.textContent = `Buy ${outcomeLabel} · $${amount.toFixed(2)}`;
      } else if (!state.wallet) {
        btn.disabled = true;
        btn.textContent = 'Create Wallet First';
      } else {
        btn.disabled = true;
        btn.textContent = 'Enter Amount';
      }
    }

    // =====================
    // FUNDING
    // =====================
    let currentFundingCurrency = 'usdc';

    function openFundModal(currency = 'usdc') {
      hapticFeedback('medium');
      currentFundingCurrency = currency;
      const modal = document.getElementById('fundModal');
      const title = document.getElementById('fundModalTitle');
      const subtitle = document.getElementById('fundModalSubtitle');
      const addressEl = document.getElementById('fundAddress');
      const networkEl = document.getElementById('fundNetwork');
      const minimumEl = document.getElementById('fundMinimum');
      const instructionsEl = document.getElementById('fundInstructions');

      // Update currency buttons
      document.querySelectorAll('.currency-btn').forEach(btn => {
        btn.classList.remove('active');
        if (btn.dataset.currency === currency) {
          btn.classList.add('active');
        }
      });

      if (!state.wallet) {
        alert('Please create a wallet first');
        return;
      }

      const walletAddress = currency === 'usdc' ? state.wallet.polygon : state.wallet.solana;
      addressEl.textContent = walletAddress;

      if (currency === 'usdc') {
        title.textContent = 'Fund USDC Wallet';
        subtitle.textContent = 'Send USDC to your Polygon wallet';
        networkEl.textContent = 'Polygon';
        minimumEl.textContent = '$10.00';
        instructionsEl.innerHTML = '<p>Send USDC (Polygon network) to the address above. Minimum deposit: $10. Make sure you\'re sending on the Polygon network, not Ethereum.</p>';
      } else {
        title.textContent = 'Fund SOL Wallet';
        subtitle.textContent = 'Send SOL to your Solana wallet';
        networkEl.textContent = 'Solana';
        minimumEl.textContent = '0.1 SOL';
        instructionsEl.innerHTML = '<p>Send SOL to the address above. Minimum deposit: 0.1 SOL. Make sure you\'re sending on the Solana network.</p>';
      }

      document.getElementById('fundAmount').value = '';
      modal.classList.add('visible');
    }

    function closeFundModal() {
      hapticFeedback('light');
      document.getElementById('fundModal').classList.remove('visible');
    }

    async function submitFunding() {
      const amount = parseFloat(document.getElementById('fundAmount').value);
      const currency = currentFundingCurrency;

      if (!amount || amount <= 0) {
        hapticFeedback('error');
        alert('Please enter a valid amount');
        return;
      }

      const minAmount = currency === 'usdc' ? 10 : 0.1;
      if (amount < minAmount) {
        hapticFeedback('error');
        alert(`Minimum deposit is ${currency === 'usdc' ? '$' : ''}${minAmount}${currency === 'sol' ? ' SOL' : ''}`);
        return;
      }

      const submitBtn = document.getElementById('fundSubmitBtn');
      const originalText = submitBtn.textContent;
      submitBtn.disabled = true;
      submitBtn.textContent = 'Processing...';
      hapticFeedback('medium');

      try {
        const walletAddress = currency === 'usdc' ? state.wallet.polygon : state.wallet.solana;

        const resp = await fetch('/api/fund', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            telegram_id: state.telegramId,
            currency: currency,
            amount: amount,
            payment_method: 'crypto',
            wallet_address: walletAddress
          })
        });

        const data = await resp.json();

        if (!resp.ok) {
          throw new Error(data.message || data.error || 'Funding failed');
        }

        if (data.success) {
          hapticFeedback('success');
          alert(`Funding instructions:\n\n${data.instructions}\n\nYour balance will update once the transaction is confirmed on-chain.`);
          closeFundModal();
          // Refresh balance after a delay
          setTimeout(() => loadBalance(), 2000);
        } else {
          throw new Error(data.message || 'Funding failed');
        }

      } catch (err) {
        console.error('[submitFunding] Error:', err);
        hapticFeedback('error');
        alert(`Funding failed: ${err.message}`);
      } finally {
        submitBtn.disabled = false;
        submitBtn.textContent = originalText;
      }
    }

    // =====================
    // POSITIONS & PAYOUTS
    // =====================
    async function loadPositions() {
      // In production, fetch from API
      // For now, show empty or mock positions
      const positionsCard = document.getElementById('positionsCard');
      const positionsList = document.getElementById('positionsList');

      try {
        // In production: const resp = await fetch(`/api/positions?telegram_id=${state.telegramId}`);
        // For now, show empty
        positionsList.innerHTML = '<div class="loading" style="padding: 10px;">No active positions</div>';
        positionsCard.style.display = 'none';
      } catch (err) {
        console.error('[loadPositions] Error:', err);
      }
    }

    async function loadPayouts() {
      try {
        const resp = await fetch(`/api/payout?telegram_id=${encodeURIComponent(state.telegramId)}`);
        if (resp.ok) {
          const data = await resp.json();
          if (data.success && data.pending_payouts && data.pending_payouts.length > 0) {
            // Show payout modal or notification
            openPayoutModal(data.pending_payouts);
          }
        }
      } catch (err) {
        console.error('[loadPayouts] Error:', err);
      }
    }

    function openPayoutModal(payouts) {
      const modal = document.getElementById('payoutModal');
      const list = document.getElementById('payoutList');

      if (!payouts || payouts.length === 0) {
        list.innerHTML = '<div class="loading" style="padding: 10px;">No pending payouts</div>';
        return;
      }

      list.innerHTML = payouts.map(payout => `
        <div class="payout-item">
          <div class="payout-header">
            <div>
              <div class="position-question">${payout.market_question || 'Winning Position'}</div>
              <div style="font-size: 11px; color: var(--text-muted); margin-top: 4px;">
                Position ID: ${payout.position_id}
              </div>
            </div>
            <div class="payout-amount">$${payout.amount.toFixed(2)}</div>
          </div>
          <button class="payout-btn" 
                  data-position-id="${payout.position_id}"
                  data-amount="${payout.amount}">
            Claim Payout
          </button>
        </div>
      `).join('');

      // Add click handlers
      list.querySelectorAll('.payout-btn').forEach(btn => {
        btn.addEventListener('click', async () => {
          await claimPayout(btn.dataset.positionId, parseFloat(btn.dataset.amount));
        });
      });

      modal.classList.add('visible');
    }

    function closePayoutModal() {
      hapticFeedback('light');
      document.getElementById('payoutModal').classList.remove('visible');
    }

    async function claimPayout(positionId, amount) {
      hapticFeedback('medium');

      try {
        const resp = await fetch('/api/payout', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            telegram_id: state.telegramId,
            position_id: positionId,
            amount: amount,
            wallet_address: state.wallet.polygon
          })
        });

        const data = await resp.json();

        if (!resp.ok) {
          throw new Error(data.message || data.error || 'Payout failed');
        }

        if (data.success) {
          hapticFeedback('success');
          alert(`Payout initiated!\n\nAmount: $${amount.toFixed(2)}\n\n${data.message || 'Funds will arrive in your wallet shortly.'}`);
          closePayoutModal();
          await loadBalance();
        } else {
          throw new Error(data.message || 'Payout failed');
        }

      } catch (err) {
        console.error('[claimPayout] Error:', err);
        hapticFeedback('error');
        alert(`Payout failed: ${err.message}`);
      }
    }

    // =====================
    // TRADE EXECUTION
    // =====================
    async function executeTrade() {
      if (!state.selectedMarket) {
        hapticFeedback('error');
        alert('No market selected');
        return;
      }

      if (!state.wallet) {
        hapticFeedback('error');
        alert('Please create a wallet first');
        return;
      }

      const amountInput = document.getElementById('tradeAmount');
      const amount = parseFloat(amountInput.value);
      
      if (!amount || amount <= 0) {
        hapticFeedback('error');
        alert('Please enter a valid amount');
        return;
      }

      const submitBtn = document.getElementById('tradeSubmit');
      const originalText = submitBtn.textContent;
      
      // Disable button and show loading
      submitBtn.disabled = true;
      submitBtn.textContent = 'Processing...';
      hapticFeedback('medium');

      try {
        const market = state.selectedMarket;
        const side = state.tradeSide;
        const outcomeIndex = state.selectedOutcomeIndex || 0;
        
        // Get market ID (could be id, conditionId, or condition_id)
        const marketId = market.id || market.conditionId || market.condition_id;
        
        if (!marketId) {
          throw new Error('Market ID not found');
        }

        console.log('[executeTrade] Executing trade:', {
          marketId,
          side,
          amount,
          outcomeIndex,
          wallet: state.wallet.polygon
        });

        // Call trade API
        const resp = await fetch('/api/trade', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            telegram_id: state.telegramId,
            market_id: marketId,
            condition_id: marketId,
            outcome_index: outcomeIndex,
            side: side,
            amount: amount,
            wallet_address: state.wallet.polygon
          })
        });

        const data = await resp.json();

        if (!resp.ok) {
          throw new Error(data.message || data.error || 'Trade failed');
        }

        if (data.success) {
          hapticFeedback('success');
          
          // Show success message
          const successMsg = `Trade executed!\n\n` +
            `Market: ${market.question.substring(0, 50)}...\n` +
            `Side: ${side.toUpperCase()}\n` +
            `Amount: $${amount.toFixed(2)}\n` +
            `Shares: ${data.shares.toFixed(2)}\n` +
            `Trade ID: ${data.trade_id}`;
          
          alert(successMsg);
          
          // Close modal
          closeTradeModal();
          
          // Reload balance
          await loadBalance();
          
          // Optionally refresh markets to show updated prices
          // fetchMarkets(state.selectedCategory, state.selectedSportType);
        } else {
          throw new Error(data.message || 'Trade failed');
        }

      } catch (err) {
        console.error('[executeTrade] Error:', err);
        hapticFeedback('error');
        alert(`Trade failed: ${err.message}`);
      } finally {
        // Re-enable button
        submitBtn.disabled = false;
        submitBtn.textContent = originalText;
      }
    }

    // =====================
    // INIT
    // =====================
    function initModeChips() {
      // Legacy support for old mode-chips if they exist
      document.querySelectorAll('.mode-chip[data-kind]').forEach(chip => {
        chip.addEventListener('click', () => {
          document.querySelectorAll('.mode-chip').forEach(c => c.classList.remove('active'));
          chip.classList.add('active');
          fetchMarkets(chip.dataset.kind);
        });
      });
    }

    async function initCategories() {
      const categories = await fetchCategories();
      if (categories.length > 0) {
        renderCategories(categories);
        // Set default to first category (usually "trending")
        if (!state.selectedCategory && categories.length > 0) {
          state.selectedCategory = categories[0].slug;
          fetchMarkets(categories[0].slug);
        }
      } else {
        // Fallback to default categories if API fails
        const fallbackCategories = [
          { slug: 'trending', label: 'Trending', icon: '' },
          { slug: 'volume', label: 'Volume', icon: '' },
          { slug: 'new', label: 'New', icon: '' },
          { slug: 'sports', label: 'Sports', icon: '' },
        ];
        renderCategories(fallbackCategories);
        state.selectedCategory = 'trending';
        fetchMarkets('trending');
      }
    }

    function initTradeModal() {
      // Close on backdrop click
      document.getElementById('tradeModal').addEventListener('click', (e) => {
        if (e.target.id === 'tradeModal') closeTradeModal();
      });

      // Amount input
      document.getElementById('tradeAmount').addEventListener('input', updateTradeSummary);

      // Submit
      document.getElementById('tradeSubmit').addEventListener('click', async () => {
        await executeTrade();
      });
    }

    function initFundModal() {
      // Close on backdrop click
      document.getElementById('fundModal').addEventListener('click', (e) => {
        if (e.target.id === 'fundModal') closeFundModal();
      });

      // Close button
      document.getElementById('closeFundModal')?.addEventListener('click', () => {
        closeFundModal();
      });

      // Currency selector
      document.querySelectorAll('.currency-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          const currency = btn.dataset.currency;
          document.querySelectorAll('.currency-btn').forEach(b => b.classList.remove('active'));
          btn.classList.add('active');
          openFundModal(currency);
        });
      });

      // Copy fund address button
      document.getElementById('copyFundAddressBtn')?.addEventListener('click', async () => {
        const addressEl = document.getElementById('fundAddress');
        if (addressEl && addressEl.textContent) {
          await copyToClipboard(addressEl.textContent);
          const btn = document.getElementById('copyFundAddressBtn');
          btn.classList.add('copied');
          setTimeout(() => btn.classList.remove('copied'), 2000);
        }
      });

      // Submit button
      document.getElementById('fundSubmitBtn')?.addEventListener('click', async () => {
        await submitFunding();
      });

      // Payout modal close
      document.getElementById('closePayoutModal')?.addEventListener('click', () => {
        closePayoutModal();
      });

      // Payout modal backdrop
      document.getElementById('payoutModal')?.addEventListener('click', (e) => {
        if (e.target.id === 'payoutModal') closePayoutModal();
      });
    }

    async function bootstrapApp() {
      console.log('Bootstrapping app...');
      initTelegram();
      initModeChips();
      initTradeModal();
      initFundModal();
      await initCategories();


      await loadWallet();
      // Markets will be fetched by initCategories()
      console.log('Bootstrap complete');
    }

    // =====================
    // START
    // =====================
    document.addEventListener('DOMContentLoaded', () => {
      initOnboarding();
      showSplash();

      setTimeout(() => {
        hideSplash();
        if (checkAccess()) {
          showMainApp();
        } else {
          showOnboarding();
        }
      }, 1500);
    });
  </script>
</body>
</html>
