<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Polygram · Trade Predictions</title>
  <script src="https://telegram.org/js/telegram-web-app.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/5.7.2/ethers.umd.min.js"></script>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800;900&family=Montserrat:wght@400;500;600;700;800&display=swap" rel="stylesheet">
  <style>
    @font-face {
      font-family: 'Benzin';
      src: url('https://fonts.cdnfonts.com/s/29189/Benzin-ExtraBold.woff') format('woff');
      font-weight: 800;
      font-style: normal;
    }
    
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    :root {
      --bg: #FFFFFF;
      --card: #f8f9fa;
      --text: #1a1a1a;
      --text-muted: #6b7280;
      --accent: #000000;
      --accent-light: #4B4B4B;
      --accent-pink: #4B4B4B;
      --green: #000000;
      --green-soft: #1a1a1a;
      --red: #d97777;
      --border: #e5e7eb;
      --bg-secondary: #f3f4f6;
      --card-hover: #e5e7eb;
      --radius: 24px;
      --radius-sm: 16px;
      --shadow: none;
    }

    body {
      font-family: 'Inter', 'Montserrat', -apple-system, BlinkMacSystemFont, sans-serif;
      background: var(--bg);
      color: var(--text);
      min-height: 100vh;
      overflow-x: hidden;
      -webkit-font-smoothing: antialiased;
    }

    /* Splash Screen */
    .splash-screen {
      position: fixed;
      inset: 0;
      background: linear-gradient(135deg, #fff5f0 0%, #fef3f2 25%, #f5f0ff 50%, #f0f4ff 75%, #ffffff 100%);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 9999;
      transition: opacity 0.4s ease;
    }
    .splash-screen.hidden { opacity: 0; pointer-events: none; }
    
    .splash-logo {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 32px;
    }
    .splash-logo-icon {
      font-size: 32px;
    }
    .splash-logo-text {
      font-family: 'Inter', 'Montserrat', sans-serif;
      font-size: 42px;
      font-weight: 900;
      color: #000000;
      letter-spacing: -0.03em;
    }
    
    .splash-spinner {
      width: 32px;
      height: 32px;
      border: 3px solid rgba(0, 0, 0, 0.1);
      border-top-color: #000000;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    @keyframes spin { to { transform: rotate(360deg); } }

    /* Onboarding Screen */
    .onboarding-screen {
      position: fixed;
      inset: 0;
      background: var(--bg);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 9998;
      padding: 20px;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s ease;
    }
    .onboarding-screen.visible { opacity: 1; pointer-events: auto; }
    
    .onboarding-card {
      background: var(--card);
      border-radius: var(--radius);
      padding: 32px;
      max-width: 360px;
      width: 100%;
      text-align: center;
    }
    .onboarding-logo {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
      margin-bottom: 20px;
    }
    .onboarding-logo-icon {
      font-size: 24px;
    }
    .onboarding-logo-text {
      font-family: 'Montserrat', sans-serif;
      font-size: 28px;
      font-weight: 800;
      color: var(--text);
    }
    .onboarding-title {
      font-size: 20px;
      font-weight: 700;
      margin-bottom: 8px;
      color: var(--text);
    }
    .onboarding-subtitle {
      font-size: 14px;
      color: var(--text-muted);
      margin-bottom: 24px;
      line-height: 1.5;
    }
    
    .feature-list {
      text-align: left;
      margin-bottom: 24px;
    }
    .feature-item {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 12px;
      background: var(--bg);
      border-radius: var(--radius-sm);
      margin-bottom: 10px;
    }
    .feature-icon {
      width: 36px;
      height: 36px;
      border-radius: 10px;
      background: var(--accent);
      color: white;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
      flex-shrink: 0;
    }
    .feature-text {
      font-size: 13px;
      color: var(--text);
      line-height: 1.4;
    }
    
    .passkey-input {
      width: 100%;
      padding: 14px;
      font-size: 15px;
      font-family: inherit;
      border: 2px solid var(--border);
      border-radius: var(--radius-sm);
      background: var(--bg);
      text-align: center;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      margin-bottom: 12px;
      transition: border-color 0.2s;
    }
    .passkey-input:focus {
      outline: none;
      border-color: var(--accent);
    }
    .passkey-input.error {
      border-color: var(--red);
      animation: shake 0.4s ease;
    }
    @keyframes shake {
      0%, 100% { transform: translateX(0); }
      25% { transform: translateX(-8px); }
      75% { transform: translateX(8px); }
    }
    
    .passkey-error {
      color: var(--red);
      font-size: 12px;
      margin-bottom: 12px;
      display: none;
    }
    .passkey-error.visible { display: block; }
    
    .passkey-btn {
      width: 100%;
      padding: 14px;
      font-size: 15px;
      font-weight: 600;
      font-family: inherit;
      background: #000000;
      color: white;
      border: none;
      border-radius: var(--radius-sm);
      cursor: pointer;
      transition: transform 0.2s, opacity 0.2s;
    }
    .passkey-btn:active { transform: scale(0.98); }
    .passkey-btn:disabled { opacity: 0.6; cursor: not-allowed; }
    
    .passkey-hint {
      margin-top: 16px;
      font-size: 12px;
      color: var(--text-muted);
    }
    .passkey-hint a {
      color: var(--accent);
      text-decoration: none;
    }

    /* Main App */
    .app-shell {
      padding: 20px 16px 100px;
      max-width: 480px;
      margin: 0 auto;
      opacity: 0;
      transition: opacity 0.3s ease;
    }
    .app-shell.visible { opacity: 1; }

    /* Header */
    .header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      margin-bottom: 20px;
      padding: 8px 0;
    }
    .header-left {
      display: flex;
      align-items: center;
      gap: 10px;
      flex: 1;
    }
    .header-logo {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .header-logo-icon {
      font-size: 20px;
    }
    .header-logo-text {
      font-family: 'Montserrat', sans-serif;
      font-size: 26px;
      font-weight: 800;
      color: var(--text);
      letter-spacing: -0.02em;
    }
    .platform-selector {
      display: flex;
      gap: 4px;
      background: var(--bg);
      border-radius: 20px;
      padding: 4px;
      border: 1px solid var(--border);
    }
    .platform-btn {
      padding: 6px 12px;
      border-radius: 16px;
      font-size: 12px;
      font-weight: 600;
      font-family: inherit;
      background: transparent;
      border: none;
      color: var(--text-muted);
      cursor: pointer;
      transition: all 0.2s;
      white-space: nowrap;
    }
    .platform-btn:hover {
      color: var(--text);
    }
    .platform-btn.active {
      background: var(--accent);
      color: white;
    }

    /* Cards */
    .card {
      background: var(--card);
      border-radius: var(--radius);
      padding: 20px;
      margin-bottom: 16px;
    }
    .card-label {
      font-size: 11px;
      font-weight: 600;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.1em;
      margin-bottom: 6px;
    }

    /* Balance Card */
    .balance-card {
      position: relative;
    }
    .balance-top-bar {
      background: var(--green);
      height: 48px;
      border-radius: 30px;
      margin-bottom: 16px;
    }
    .balance-amount {
      font-size: 36px;
      font-weight: 700;
      margin-bottom: 8px;
      color: var(--text);
    }
    .balance-breakdown {
      background: var(--bg);
      padding: 14px 18px;
      border-radius: 30px;
      font-size: 13px;
      color: var(--text-muted);
      margin-bottom: 12px;
    }
    .balance-dot {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      background: var(--accent);
    }

    /* Wallet Card */
    .wallet-title {
      font-size: 16px;
      font-weight: 600;
      margin-bottom: 12px;
      color: var(--text);
    }
    .wallet-section {
      display: flex;
      flex-direction: column;
      gap: 12px;
      margin-bottom: 12px;
    }
    .wallet-row {
      background: var(--bg);
      border-radius: 16px;
      padding: 12px 16px;
    }
    .wallet-label {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 12px;
      font-weight: 600;
      color: var(--text-muted);
      margin-bottom: 6px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    .wallet-icon {
      font-size: 14px;
      font-weight: 700;
    }
    .wallet-address-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
    }
    .wallet-address {
      font-size: 13px;
      font-family: 'SF Mono', Monaco, monospace;
      color: var(--text);
      flex: 1;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      cursor: pointer;
      padding: 4px 8px;
      border-radius: 6px;
      transition: all 0.2s;
      user-select: all;
    }
    .wallet-address:hover {
      background: var(--bg);
    }
    .wallet-address:active {
      background: var(--card);
    }
    .copy-btn {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 6px 8px;
      cursor: pointer;
      color: var(--text-muted);
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s;
      flex-shrink: 0;
    }
    .copy-btn:hover {
      background: var(--green);
      color: var(--text);
      border-color: var(--green);
    }
    .copy-btn:active {
      transform: scale(0.95);
    }
    .copy-btn.copied {
      background: var(--green);
      color: var(--text);
      border-color: var(--green);
    }
    .wallet-status {
      background: var(--accent);
      color: white;
      height: 40px;
      border-radius: 30px;
      padding: 0 18px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 13px;
      margin-bottom: 12px;
    }
    .wallet-actions {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
      margin-top: 8px;
    }
    .wallet-action-btn {
      padding: 10px 16px;
      border-radius: var(--radius-sm);
      font-size: 13px;
      font-weight: 600;
      border: 1px solid var(--border);
      background: var(--bg);
      color: var(--text);
      cursor: pointer;
      transition: all 0.2s;
    }
    .wallet-action-btn:hover {
      background: var(--card);
    }
    .wallet-action-btn:active {
      transform: scale(0.98);
    }

    /* Fund Modal */
    .fund-info {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }
    .fund-currency-selector {
      display: flex;
      gap: 8px;
    }
    .currency-btn {
      flex: 1;
      padding: 10px;
      border-radius: var(--radius-sm);
      font-size: 14px;
      font-weight: 600;
      border: 1px solid var(--border);
      background: var(--bg);
      color: var(--text);
      cursor: pointer;
      transition: all 0.2s;
    }
    .currency-btn.active {
      background: var(--accent);
      color: white;
      border-color: var(--accent);
    }
    .fund-amount input {
      width: 100%;
      padding: 12px;
      border-radius: var(--radius-sm);
      border: 1px solid var(--border);
      background: var(--bg);
      font-size: 16px;
      font-weight: 600;
    }
    .fund-address-section {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .fund-address-section label {
      font-size: 12px;
      color: var(--text-muted);
      font-weight: 500;
    }
    .fund-address-display {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 12px;
      background: var(--bg);
      border-radius: var(--radius-sm);
      border: 1px solid var(--border);
    }
    .fund-address-display code {
      flex: 1;
      font-size: 12px;
      font-family: 'Courier New', monospace;
      word-break: break-all;
      color: var(--text);
    }
    .fund-instructions {
      padding: 12px;
      background: var(--bg);
      border-radius: var(--radius-sm);
      font-size: 13px;
      color: var(--text-muted);
      line-height: 1.5;
    }
    .fund-summary {
      display: flex;
      flex-direction: column;
      gap: 8px;
      padding: 12px;
      background: var(--bg);
      border-radius: var(--radius-sm);
    }
    .fund-summary-row {
      display: flex;
      justify-content: space-between;
      font-size: 13px;
    }
    .fund-summary-row span:first-child {
      color: var(--text-muted);
    }
    .fund-summary-row span:last-child {
      font-weight: 600;
      color: var(--text);
    }
    .modal-close-btn {
      width: 100%;
      padding: 12px;
      margin-top: 8px;
      border-radius: var(--radius-sm);
      border: 1px solid var(--border);
      background: var(--bg);
      color: var(--text);
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s;
    }
    .modal-close-btn:hover {
      background: var(--card);
    }

    /* Positions */
    .position-item {
      padding: 12px;
      background: var(--bg);
      border-radius: var(--radius-sm);
      margin-bottom: 8px;
      border: 1px solid var(--border);
    }
    .position-header {
      display: flex;
      justify-content: space-between;
      align-items: start;
      margin-bottom: 8px;
    }
    .position-question {
      font-size: 13px;
      font-weight: 500;
      color: var(--text);
      flex: 1;
    }
    .position-side {
      padding: 4px 8px;
      border-radius: 12px;
      font-size: 11px;
      font-weight: 600;
      text-transform: uppercase;
    }
    .position-side.yes {
      background: var(--green-soft);
      color: var(--text);
    }
    .position-side.no {
      background: var(--bg);
      color: var(--text-muted);
    }
    .position-details {
      display: flex;
      justify-content: space-between;
      font-size: 12px;
      color: var(--text-muted);
    }
    .position-value {
      font-weight: 600;
      color: var(--text);
    }
    .position-value.winning {
      color: var(--green);
    }
    .payout-item {
      padding: 12px;
      background: var(--bg);
      border-radius: var(--radius-sm);
      margin-bottom: 8px;
      border: 1px solid var(--border);
    }
    .payout-header {
      display: flex;
      justify-content: space-between;
      align-items: start;
      margin-bottom: 8px;
    }
    .payout-amount {
      font-size: 18px;
      font-weight: 700;
      color: var(--green);
    }
    .payout-btn {
      width: 100%;
      padding: 10px;
      margin-top: 8px;
      border-radius: var(--radius-sm);
      background: var(--green);
      color: white;
      font-size: 13px;
      font-weight: 600;
      border: none;
      cursor: pointer;
      transition: all 0.2s;
    }
    .payout-btn:hover {
      opacity: 0.9;
    }
    .payout-btn:active {
      transform: scale(0.98);
    }
    .payout-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    /* Legacy wallet actions (kept for compatibility) */
    .wallet-actions {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      margin-bottom: 10px;
    }
    .wallet-actions-bottom {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }
    .wallet-btn {
      padding: 16px;
      border-radius: 30px;
      font-size: 14px;
      font-weight: 600;
      font-family: inherit;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      transition: transform 0.2s;
      border: none;
    }
    .wallet-btn:active { transform: scale(0.98); }
    .wallet-btn.green {
      background: var(--green);
      color: var(--text);
    }
    .wallet-btn.dark {
      background: var(--accent);
      color: white;
    }

    /* Markets Card */
    .markets-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 16px;
    }
    .markets-title {
      font-size: 16px;
      font-weight: 600;
      color: var(--text);
    }
    
    /* Category Scroll Container */
    .category-scroll-container {
      position: relative;
      margin-bottom: 16px;
      overflow: hidden;
    }
    .category-scroll {
      display: flex;
      gap: 10px;
      overflow-x: auto;
      overflow-y: hidden;
      scroll-behavior: smooth;
      -webkit-overflow-scrolling: touch;
      padding: 4px 0;
      scrollbar-width: none; /* Firefox */
      -ms-overflow-style: none; /* IE/Edge */
    }
    .category-scroll::-webkit-scrollbar {
      display: none; /* Chrome/Safari */
    }
    .category-chip {
      padding: 10px 18px;
      border-radius: 30px;
      font-size: 13px;
      font-weight: 600;
      font-family: inherit;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      background: var(--accent);
      border: none;
      color: white;
      transition: all 0.2s;
      white-space: nowrap;
      flex-shrink: 0;
      min-height: 40px;
    }
    .category-chip:hover {
      opacity: 0.9;
    }
    .category-chip:active {
      transform: scale(0.95);
    }
    .category-chip.active {
      background: #000000;
      color: white;
    }
    
    /* Legacy mode-chips (keeping for backward compatibility) */
    .mode-chips {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      margin-bottom: 16px;
    }
    .mode-chip {
      padding: 14px 16px;
      border-radius: 30px;
      font-size: 13px;
      font-weight: 600;
      font-family: inherit;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      background: var(--accent);
      border: none;
      color: white;
      transition: all 0.2s;
    }
    .mode-chip.active {
      background: var(--green);
      color: var(--text);
    }
    
    .markets-list {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    /* Market Item */
    .market-item {
      display: flex;
      gap: 12px;
      padding: 14px;
      background: var(--bg);
      border-radius: var(--radius-sm);
      cursor: pointer;
      transition: transform 0.2s;
    }
    .market-item:active { transform: scale(0.99); }
    .market-image {
      width: 40px;
      height: 40px;
      border-radius: 8px;
      object-fit: cover;
      flex-shrink: 0;
      background: var(--bg-secondary);
    }
    .market-image.hidden {
      display: none;
    }
    .market-info {
      flex: 1;
      min-width: 0;
    }
    .market-question {
      font-size: 14px;
      font-weight: 500;
      line-height: 1.4;
      margin-bottom: 6px;
      color: var(--text);
      display: -webkit-box;
      -webkit-line-clamp: 2;
      line-clamp: 2;
      -webkit-box-orient: vertical;
      overflow: hidden;
    }
    .market-meta {
      display: flex;
      align-items: center;
      gap: 12px;
      font-size: 12px;
      color: var(--text-muted);
    }
    .market-odds {
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      gap: 4px;
    }
    .odds-yes {
      background: var(--green);
      color: var(--text);
      padding: 6px 12px;
      border-radius: 20px;
      font-size: 13px;
      font-weight: 600;
    }
    .odds-vol {
      font-size: 11px;
      color: var(--text-muted);
    }

    /* Event Grouping (for NFL games) */
    .event-group {
      background: var(--bg);
      border-radius: var(--radius-sm);
      margin-bottom: 12px;
      overflow: hidden;
    }
    .event-header {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 14px;
      border-bottom: 1px solid var(--border);
      cursor: pointer;
      user-select: none;
      transition: background 0.2s;
      flex-wrap: nowrap;
      overflow: hidden;
    }
    .event-header:hover {
      background: var(--card);
    }
    .event-header.collapsed {
      border-bottom: none;
    }
    .event-info {
      flex: 1;
      min-width: 0;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    .event-title {
      font-size: 15px;
      font-weight: 600;
      line-height: 1.4;
      color: var(--text);
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: nowrap;
      word-break: keep-all;
      overflow-wrap: normal;
      white-space: nowrap;
      overflow: hidden;
      min-width: 0;
    }
    .event-title-text {
      display: inline-block;
      word-break: keep-all;
      overflow-wrap: normal;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      flex: 1;
      min-width: 0;
    }
    .event-meta {
      display: flex;
      align-items: center;
      gap: 12px;
      font-size: 12px;
      color: var(--text-muted);
    }
    .event-primary-prices {
      display: flex;
      gap: 6px;
      flex-shrink: 0;
      margin-left: auto;
      margin-right: 8px;
    }
    .event-price-btn {
      padding: 6px 12px;
      border-radius: 8px;
      border: none;
      font-weight: 600;
      font-size: 12px;
      cursor: pointer;
      white-space: nowrap;
      transition: opacity 0.2s;
      flex-shrink: 0;
    }
    @media (max-width: 480px) {
      .event-primary-prices {
        flex-direction: column;
        gap: 4px;
      }
      .event-price-btn {
        padding: 4px 8px;
        font-size: 11px;
      }
      .event-title {
        font-size: 14px;
      }
      .event-header {
        padding: 12px;
        gap: 8px;
      }
      .event-image {
        width: 40px;
        height: 40px;
      }
    }
    .event-collapse-icon {
      font-size: 18px;
      color: var(--text-muted);
      transition: transform 0.2s;
      flex-shrink: 0;
      width: 24px;
      height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .event-header.collapsed .event-collapse-icon {
      transform: rotate(-90deg);
    }
    .event-price-btn:hover {
      opacity: 0.8;
    }
    .event-price-btn-1 {
      background: var(--market-color, #003366);
      color: white;
    }
    .event-price-btn-2 {
      background: var(--market-color, #003366);
      color: white;
    }
    .event-markets {
      padding: 0;
      max-height: 2000px;
      overflow: hidden;
      transition: max-height 0.3s ease, padding 0.3s ease;
    }
    .event-group.collapsed .event-markets {
      max-height: 0;
      padding: 0;
    }
    .event-image {
      width: 48px;
      height: 48px;
      border-radius: 8px;
      object-fit: cover;
      flex-shrink: 0;
      background: var(--bg-secondary);
    }
    .event-image.hidden {
      display: none;
    }
    .week-tag {
      background: var(--bg-secondary);
      color: var(--text-muted);
      padding: 2px 8px;
      border-radius: 12px;
      font-size: 11px;
      font-weight: 500;
      text-transform: uppercase;
      flex-shrink: 0;
    }
    .event-markets {
      padding: 0;
    }
    .market-item.nested {
      border-radius: 0;
      border-bottom: 1px solid var(--border);
      margin: 0;
    }
    .market-item.nested:last-child {
      border-bottom: none;
    }
    .market-item.nested .market-question {
      font-size: 13px;
    }

    /* Market Card (New Design) */
    .market-card {
      background: var(--card);
      border-radius: var(--radius-sm);
      padding: 16px;
      margin-bottom: 12px;
      transition: all 0.2s ease;
      cursor: pointer;
    }
    .market-card:active {
      transform: scale(0.99);
    }
    .market-card-header {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 16px;
    }
    .market-card-header .market-image {
      width: 48px;
      height: 48px;
      border-radius: 8px;
      object-fit: cover;
      flex-shrink: 0;
      background: var(--bg);
    }
    .market-title {
      flex: 1;
      font-size: 16px;
      font-weight: 600;
      color: var(--text);
      line-height: 1.4;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      word-break: keep-all;
    }
    .market-outcomes {
      display: flex;
      flex-direction: column;
      gap: 10px;
      margin-bottom: 12px;
    }
    .market-outcome-item {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .outcome-label {
      font-size: 14px;
      color: var(--text-muted);
      margin-bottom: 4px;
    }
    .outcome-buttons {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }
    .outcome-button-group {
      display: flex;
      align-items: center;
      gap: 8px;
      flex: 1;
      min-width: 120px;
    }
    .outcome-price {
      font-size: 14px;
      font-weight: 600;
      color: var(--text);
      min-width: 45px;
    }
    .outcome-btn {
      flex: 1;
      padding: 10px 16px;
      border-radius: var(--radius-sm);
      font-size: 14px;
      font-weight: 500;
      border: 1px solid var(--border);
      background: var(--bg);
      color: var(--text);
      cursor: pointer;
      transition: all 0.2s ease;
      min-width: 60px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      word-break: keep-all;
    }
    .outcome-btn:active {
      transform: scale(0.95);
    }
    .outcome-yes {
      background: var(--market-color, #003366);
      color: white;
      border-color: var(--market-color, #003366);
    }
    .outcome-yes:active {
      opacity: 0.9;
    }
    .outcome-no {
      background: var(--market-color, #003366);
      color: white;
      border-color: var(--market-color, #003366);
    }
    .outcome-no:active {
      opacity: 0.9;
    }
    .market-card-footer {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding-top: 12px;
      border-top: 1px solid var(--border);
    }
    .market-volume {
      font-size: 12px;
      color: var(--text-muted);
      font-weight: 500;
    }
    .market-icon {
      font-size: 16px;
      opacity: 0.6;
    }

    /* Modal */
    .modal-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.4);
      display: flex;
      align-items: flex-end;
      justify-content: center;
      z-index: 1000;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s;
    }
    .modal-overlay.visible {
      opacity: 1;
      pointer-events: auto;
    }
    .modal {
      background: var(--card);
      border-radius: var(--radius) var(--radius) 0 0;
      padding: 24px;
      width: 100%;
      max-width: 480px;
      max-height: 85vh;
      overflow-y: auto;
      transform: translateY(100%);
      transition: transform 0.3s ease;
    }
    .modal-overlay.visible .modal {
      transform: translateY(0);
    }
    .modal-handle {
      width: 40px;
      height: 4px;
      background: var(--border);
      border-radius: 2px;
      margin: 0 auto 20px;
    }
    .modal-title {
      font-size: 20px;
      font-weight: 700;
      margin-bottom: 8px;
      color: var(--text);
    }
    .modal-subtitle {
      font-size: 14px;
      color: var(--text-muted);
      margin-bottom: 20px;
    }
    .modal-close {
      position: absolute;
      top: 20px;
      right: 20px;
      width: 32px;
      height: 32px;
      border-radius: 50%;
      background: var(--bg);
      border: none;
      font-size: 18px;
      cursor: pointer;
    }

    /* Trade Modal */
    .trade-market-info {
      display: flex;
      gap: 12px;
      padding: 16px;
      background: var(--bg);
      border-radius: var(--radius-sm);
      margin-bottom: 20px;
    }
    .trade-market-img {
      width: 64px;
      height: 64px;
      border-radius: 12px;
      object-fit: cover;
      flex-shrink: 0;
    }
    .trade-market-question {
      font-size: 14px;
      font-weight: 500;
      line-height: 1.4;
      color: var(--text);
    }
    
    .trade-outcomes {
      display: flex;
      flex-direction: column;
      gap: 12px;
      margin-bottom: 20px;
    }
    .trade-outcome {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 14px 16px;
      border-radius: var(--radius-sm);
      cursor: pointer;
      border: none;
      transition: all 0.2s;
      background: var(--market-color, #003366);
      color: white;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
    }
    .trade-outcome.active { 
      background: #000000;
      color: white;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
    }
    .trade-outcome .trade-outcome-label,
    .trade-outcome .trade-outcome-percent,
    .trade-outcome .trade-outcome-price {
      color: white;
    }
    .trade-outcome.active .trade-outcome-label,
    .trade-outcome.active .trade-outcome-percent {
      color: white;
    }
    .trade-outcome-left {
      display: flex;
      align-items: center;
      gap: 12px;
      flex: 1;
    }
    .trade-outcome-label {
      font-size: 15px;
      font-weight: 600;
      color: var(--text);
      flex: 1;
    }
    .trade-outcome-percent {
      font-size: 16px;
      font-weight: 700;
      color: var(--text);
      min-width: 50px;
      text-align: right;
    }
    .trade-outcome-price {
      font-size: 18px;
      font-weight: 700;
      color: white;
      min-width: 60px;
      text-align: right;
    }
    
    .trade-amount {
      margin-bottom: 20px;
    }
    .trade-amount label {
      display: block;
      font-size: 12px;
      font-weight: 600;
      color: var(--text-muted);
      text-transform: uppercase;
      margin-bottom: 8px;
    }
    .trade-amount input {
      width: 100%;
      padding: 16px;
      font-size: 18px;
      font-family: inherit;
      border: 2px solid var(--border);
      border-radius: var(--radius-sm);
      text-align: center;
      background: var(--bg);
    }
    .trade-amount input:focus {
      outline: none;
      border-color: var(--accent);
    }
    
    .trade-summary {
      padding: 16px;
      background: var(--bg);
      border-radius: var(--radius-sm);
      margin-bottom: 20px;
    }
    .trade-summary-row {
      display: flex;
      justify-content: space-between;
      margin-bottom: 8px;
      font-size: 14px;
    }
    .trade-summary-row:last-child { margin-bottom: 0; }
    .trade-summary-row span:first-child { color: var(--text-muted); }
    .trade-summary-row span:last-child { font-weight: 600; color: var(--text); }
    
    .trade-submit {
      width: 100%;
      padding: 16px;
      font-size: 16px;
      font-weight: 600;
      font-family: inherit;
      background: #000000;
      color: white;
      border: none;
      border-radius: 30px;
      cursor: pointer;
    }
    .trade-submit:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    /* Loading State */
    .loading {
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 40px;
      color: var(--text-muted);
      font-size: 14px;
    }

    /* Market Detail View */
    .market-detail-view {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: var(--bg);
      z-index: 1000;
      overflow-y: auto;
      padding-bottom: 80px;
    }
    .market-detail-header {
      display: flex;
      align-items: center;
      padding: 16px;
      border-bottom: 1px solid var(--border);
      position: sticky;
      top: 0;
      background: var(--bg);
      z-index: 10;
    }
    .back-btn {
      background: none;
      border: none;
      color: var(--text);
      cursor: pointer;
      padding: 8px;
      margin-right: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .market-detail-title {
      flex: 1;
      font-size: 18px;
      font-weight: 600;
      color: var(--text);
    }
    .market-detail-actions {
      display: flex;
      gap: 8px;
    }
    .icon-btn {
      background: none;
      border: none;
      color: var(--text);
      cursor: pointer;
      padding: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .icon-btn:hover {
      opacity: 0.7;
    }
    .market-detail-content {
      padding: 16px;
    }
    .market-detail-volume {
      font-size: 14px;
      color: var(--text-muted);
      margin-bottom: 8px;
    }
    .market-detail-event {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 20px;
    }
    .market-detail-event img {
      width: 24px;
      height: 24px;
      border-radius: 4px;
    }
    .market-detail-outcomes-list {
      margin-bottom: 24px;
    }
    .outcome-item {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 12px;
      margin-bottom: 8px;
      background: var(--bg);
      border-radius: var(--radius-sm);
      border: 1px solid var(--border);
      cursor: pointer;
      transition: all 0.2s;
    }
    .outcome-item:hover {
      border-color: var(--accent);
    }
    .outcome-item.selected {
      border-color: var(--accent);
      background: var(--accent-soft);
    }
    .outcome-dot {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      flex-shrink: 0;
    }
    .outcome-dot.blue { background: #687E90; }
    .outcome-dot.green { background: #4B4B4B; }
    .outcome-dot.orange { background: #5b5b5b; }
    .outcome-dot.red { background: #6b6b6b; }
    .outcome-dot.purple { background: #7b7b7b; }
    .outcome-dot.pink { background: #8b8b8b; }
    .outcome-label {
      flex: 1;
      font-size: 14px;
      color: var(--text);
    }
    .outcome-percent {
      font-size: 14px;
      font-weight: 600;
      color: var(--text);
      min-width: 50px;
      text-align: right;
    }
    .market-detail-graph-container {
      background: var(--bg);
      border-radius: var(--radius-sm);
      padding: 16px;
      margin-bottom: 24px;
      border: 1px solid var(--border);
    }
    #marketDetailGraph {
      width: 100%;
      height: 200px;
      margin-bottom: 12px;
      max-width: 100%;
    }
    @media (max-width: 480px) {
      #marketDetailGraph {
        height: 150px;
      }
    }
    .graph-time-selectors {
      display: flex;
      gap: 8px;
      justify-content: center;
    }
    .time-selector {
      padding: 6px 12px;
      background: var(--bg);
      border: 1px solid var(--border);
      border-radius: var(--radius-sm);
      color: var(--text);
      font-size: 12px;
      cursor: pointer;
      transition: all 0.2s;
    }
    .time-selector:hover {
      border-color: var(--accent);
    }
    .time-selector.active {
      background: #000000;
      color: white;
      border-color: #000000;
    }
    .market-detail-selected-outcome {
      display: flex;
      justify-content: space-between;
      padding: 16px;
      background: var(--bg);
      border-radius: var(--radius-sm);
      border: 1px solid var(--border);
      margin-bottom: 16px;
    }
    .selected-outcome-label {
      font-size: 11px;
      text-transform: uppercase;
      color: var(--text-muted);
      margin-bottom: 4px;
    }
    .selected-outcome-name {
      font-size: 16px;
      font-weight: 600;
      color: var(--text);
      margin-bottom: 4px;
    }
    .selected-outcome-volume {
      font-size: 12px;
      color: var(--text-muted);
    }
    .selected-outcome-percent {
      font-size: 24px;
      font-weight: 700;
      color: var(--accent);
    }
    .market-detail-buy-buttons {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
    }
    .buy-btn {
      padding: 16px;
      border-radius: var(--radius-sm);
      border: none;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 4px;
      transition: all 0.2s;
    }
    .buy-btn:active {
      transform: scale(0.98);
    }
    .buy-btn-yes {
      background: var(--market-color, #003366);
      color: white;
    }
    .buy-btn-no {
      background: var(--market-color, #003366);
      color: white;
    }
    .buy-btn-label {
      font-size: 11px;
      text-transform: uppercase;
      opacity: 0.8;
    }
    .buy-btn-outcome {
      font-size: 16px;
      font-weight: 700;
    }
    .buy-btn-price {
      font-size: 18px;
      font-weight: 700;
    }

    /* Sub-filters */
    .sub-filters {
      display: flex;
      gap: 8px;
      padding: 12px 16px;
      overflow-x: auto;
      border-bottom: 1px solid var(--border);
      background: var(--bg);
    }
    .sub-filter-btn {
      padding: 6px 16px;
      background: var(--bg);
      border: 1px solid var(--border);
      border-radius: 20px;
      color: var(--text);
      font-size: 13px;
      white-space: nowrap;
      cursor: pointer;
      transition: all 0.2s;
    }
    .sub-filter-btn:hover {
      border-color: var(--accent);
    }
    .sub-filter-btn.active {
      background: var(--accent);
      color: white;
      border-color: var(--accent);
    }
  </style>
</head>
<body>
  <!-- Splash Screen -->
  <div class="splash-screen" id="splashScreen">
    <div class="splash-logo">
      <span class="splash-logo-icon">✦</span>
      <span class="splash-logo-text">Polygram</span>
    </div>
    <div class="splash-spinner"></div>
  </div>

  <!-- Onboarding Screen -->
  <div class="onboarding-screen" id="onboardingScreen">
    <div class="onboarding-card">
      <div class="onboarding-logo">
        <span class="onboarding-logo-icon">✦</span>
        <span class="onboarding-logo-text">Polygram</span>
      </div>
      <h2 class="onboarding-title">Welcome to Polygram</h2>
      <p class="onboarding-subtitle">Trade prediction markets directly from Telegram. Fast, simple, powerful.</p>
      
      <div class="feature-list">
        <div class="feature-item">
          <div class="feature-icon"></div>
          <div class="feature-text">Instant trades on Polymarket via custodial wallet</div>
        </div>
        <div class="feature-item">
          <div class="feature-icon"></div>
          <div class="feature-text">Real-time markets, trending events, live odds</div>
        </div>
        <div class="feature-item">
          <div class="feature-icon"></div>
          <div class="feature-text">Secure wallet with USDC on Polygon network</div>
        </div>
      </div>
      
      <input type="text" class="passkey-input" id="passkeyInput" placeholder="Enter passkey" maxlength="20" />
      <div class="passkey-error" id="passkeyError">Invalid passkey. Please try again.</div>
      <button class="passkey-btn" id="passkeyBtn">Continue</button>
      
      <p class="passkey-hint">Don't have a passkey? <a href="https://t.me/publiclabs" target="_blank">Join our Telegram</a></p>
    </div>
  </div>

  <!-- Main App -->
  <div class="app-shell" id="appShell">
    <!-- Header -->
    <header class="header">
      <div class="header-left">
        <div class="header-logo">
          <span class="header-logo-icon">✦</span>
          <span class="header-logo-text">Polygram</span>
        </div>
      </div>
      <div class="platform-selector">
        <button class="platform-btn active" data-platform="polymarket" id="platformPolymarket">Polymarket</button>
        <button class="platform-btn" data-platform="kalshi" id="platformKalshi">Kalshi</button>
      </div>
    </header>

    <!-- Balance Card -->
    <div class="card balance-card">
      <div class="balance-top-bar"></div>
      <div class="balance-amount" id="totalBalance">$0.00</div>
      <div class="balance-breakdown" id="balanceBreakdown">
        USDC: <span id="usdcBalance">$0.00</span> | Positions: <span id="positionsValue">$0.00</span>
      </div>
      <div class="balance-dot"></div>
    </div>

    <!-- Wallet Card -->
    <div class="card">
      <div class="wallet-section">
        <div class="wallet-row">
          <div class="wallet-label">
            <span class="wallet-icon">◎</span>
            <span>SOL Wallet</span>
          </div>
          <div class="wallet-address-row">
            <span class="wallet-address" id="solWalletAddress" title="Click to copy">Loading...</span>
            <button class="copy-btn" id="copySolBtn" title="Copy SOL address">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
              </svg>
            </button>
          </div>
        </div>
        <div class="wallet-row">
          <div class="wallet-label">
            <span class="wallet-icon">$</span>
            <span>USDC Wallet</span>
          </div>
          <div class="wallet-address-row">
            <span class="wallet-address" id="usdcWalletAddress" title="Click to copy">Loading...</span>
            <button class="copy-btn" id="copyUsdcBtn" title="Copy USDC address">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
              </svg>
            </button>
          </div>
        </div>
      </div>
      <div class="wallet-status" id="walletStatusBar">Checking status...</div>
      </div>

    <!-- Positions Card -->
    <div class="card" id="positionsCard" style="display: none;">
      <h3 style="margin-bottom: 12px; font-size: 16px; font-weight: 600;">Active Positions</h3>
      <div id="positionsList">
        <div class="loading" style="padding: 10px;">No active positions</div>
      </div>
    </div>

    <!-- Markets Card -->
    <div class="card">
      <div class="category-scroll-container">
        <div class="category-scroll" id="categoryScroll">
          <div class="loading" style="padding: 10px;">Loading categories...</div>
        </div>
      </div>
      
      <div class="sub-filters" id="subFilters" style="display: none;">
        <!-- Sub-filters will be dynamically generated -->
      </div>
      
      <div class="markets-list" id="marketsList">
        <div class="loading">Loading markets...</div>
      </div>
    </div>
  </div>

  <!-- Market Detail View -->
  <div class="market-detail-view" id="marketDetailView" style="display: none;">
    <div class="market-detail-header">
      <button class="back-btn" id="marketDetailBack">
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M19 12H5M12 19l-7-7 7-7"/>
        </svg>
      </button>
      <div class="market-detail-title" id="marketDetailTitle"></div>
      <div class="market-detail-actions">
        <button class="icon-btn" id="marketDetailShare" title="Share">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <circle cx="18" cy="5" r="3"></circle>
            <circle cx="6" cy="12" r="3"></circle>
            <circle cx="18" cy="19" r="3"></circle>
            <line x1="8.59" y1="13.51" x2="15.42" y2="17.49"></line>
            <line x1="15.41" y1="6.51" x2="8.59" y2="10.49"></line>
          </svg>
        </button>
        <button class="icon-btn" id="marketDetailBookmark" title="Bookmark">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M19 21l-7-5-7 5V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2z"></path>
          </svg>
        </button>
      </div>
    </div>
    
    <div class="market-detail-content">
      <div class="market-detail-volume" id="marketDetailVolume"></div>
      <div class="market-detail-event" id="marketDetailEvent"></div>
      
      <div class="market-detail-outcomes-list" id="marketDetailOutcomesList"></div>
      
      <div class="market-detail-graph-container">
        <canvas id="marketDetailGraph" width="400" height="200"></canvas>
        <div class="graph-time-selectors">
          <button class="time-selector active" data-range="1H">1H</button>
          <button class="time-selector" data-range="6H">6H</button>
          <button class="time-selector" data-range="1D">1D</button>
          <button class="time-selector" data-range="1W">1W</button>
          <button class="time-selector" data-range="1M">1M</button>
          <button class="time-selector" data-range="ALL">ALL</button>
        </div>
      </div>
      
      <div class="market-detail-selected-outcome" id="marketDetailSelectedOutcome">
        <div class="selected-outcome-left">
          <div class="selected-outcome-label">OUTCOME</div>
          <div class="selected-outcome-name" id="selectedOutcomeName">--</div>
          <div class="selected-outcome-volume" id="selectedOutcomeVolume">$0 Vol.</div>
        </div>
        <div class="selected-outcome-right">
          <div class="selected-outcome-label">% CHANCE</div>
          <div class="selected-outcome-percent" id="selectedOutcomePercent">--</div>
        </div>
      </div>
      
      <div class="market-detail-buy-buttons">
        <button class="buy-btn buy-btn-yes" id="marketDetailBuyYes">
          <span class="buy-btn-label">Buy</span>
          <span class="buy-btn-outcome" id="buyYesOutcome">Yes</span>
          <span class="buy-btn-price" id="buyYesPrice">--¢</span>
        </button>
        <button class="buy-btn buy-btn-no" id="marketDetailBuyNo">
          <span class="buy-btn-label">Buy</span>
          <span class="buy-btn-outcome" id="buyNoOutcome">No</span>
          <span class="buy-btn-price" id="buyNoPrice">--¢</span>
        </button>
      </div>
    </div>
  </div>

  <!-- Trade Modal -->
  <div class="modal-overlay" id="tradeModal">
    <div class="modal">
      <div class="modal-handle"></div>
      <h3 class="modal-title">Place Trade</h3>
      <p class="modal-subtitle">Select your position and amount</p>
      
      <div class="trade-market-info" id="tradeMarketInfo">
        <img class="trade-market-img" id="tradeMarketImg" src="" alt="" onerror="this.style.display='none'" />
        <div class="trade-market-question" id="tradeMarketQuestion"></div>
      </div>
      
      <div class="trade-outcomes" id="tradeOutcomes">
        <!-- Outcomes will be dynamically generated -->
      </div>
      
      <div class="trade-amount">
        <label>Amount (USDC)</label>
        <input type="number" id="tradeAmount" placeholder="10.00" min="1" step="1" />
      </div>
      
      <div class="trade-summary">
        <div class="trade-summary-row">
          <span>Shares</span>
          <span id="tradeShares">0</span>
        </div>
        <div class="trade-summary-row">
          <span>Avg Price</span>
          <span id="tradeAvgPrice">--¢</span>
        </div>
        <div class="trade-summary-row">
          <span>Potential Return</span>
          <span id="tradePotential">$0.00</span>
        </div>
      </div>
      
      <button class="trade-submit" id="tradeSubmit" disabled>Connect Wallet First</button>
    </div>
  </div>

  <!-- Fund Modal -->
  <div class="modal-overlay" id="fundModal">
    <div class="modal">
      <div class="modal-handle"></div>
      <h3 class="modal-title" id="fundModalTitle">Fund Wallet</h3>
      <p class="modal-subtitle" id="fundModalSubtitle">Send funds to your wallet address</p>
      
      <div class="fund-info" id="fundInfo">
        <div class="fund-currency-selector">
          <button class="currency-btn active" data-currency="usdc">USDC</button>
          <button class="currency-btn" data-currency="sol">SOL</button>
        </div>
        
        <div class="fund-amount">
          <label>Amount</label>
          <input type="number" id="fundAmount" placeholder="10.00" min="1" step="0.01" />
        </div>
        
        <div class="fund-address-section">
          <label>Send to this address:</label>
          <div class="fund-address-display">
            <code id="fundAddress">Loading...</code>
            <button class="copy-btn" id="copyFundAddressBtn">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
              </svg>
            </button>
          </div>
        </div>
        
        <div class="fund-instructions" id="fundInstructions">
          <p>Send USDC (Polygon network) to the address above. Minimum deposit: $10</p>
        </div>
        
        <div class="fund-summary">
          <div class="fund-summary-row">
            <span>Network</span>
            <span id="fundNetwork">Polygon</span>
          </div>
          <div class="fund-summary-row">
            <span>Minimum</span>
            <span id="fundMinimum">$10.00</span>
          </div>
        </div>
      </div>
      
      <button class="trade-submit" id="fundSubmitBtn">I've Sent the Funds</button>
      <button class="modal-close-btn" id="closeFundModal">Cancel</button>
    </div>
  </div>

  <!-- Payout Modal -->
  <div class="modal-overlay" id="payoutModal">
    <div class="modal">
      <div class="modal-handle"></div>
      <h3 class="modal-title">Claim Payout</h3>
      <p class="modal-subtitle">Withdraw winnings from your winning positions</p>
      
      <div class="payout-list" id="payoutList">
        <!-- Payout items will be dynamically generated -->
      </div>
      
      <button class="modal-close-btn" id="closePayoutModal">Close</button>
    </div>
  </div>

  <script>
    // =====================
    // STATE
    // =====================
    const state = {
      telegramId: null,
      wallet: null,
      markets: [],
      selectedMarket: null,
      selectedCategory: null,
      selectedSportType: null, // 'games' or 'props'
      selectedPlatform: 'polymarket', // 'polymarket' or 'kalshi'
      tradeSide: 'yes',
      selectedOutcomeIndex: 0,
      selectedSubFilter: 'all',
    };

    // =====================
    // HAPTIC FEEDBACK
    // =====================
    function hapticFeedback(type = 'light') {
      if (window.Telegram?.WebApp?.HapticFeedback) {
        const haptic = window.Telegram.WebApp.HapticFeedback;
        switch(type) {
          case 'light':
            haptic.impactOccurred('light');
            break;
          case 'medium':
            haptic.impactOccurred('medium');
            break;
          case 'heavy':
            haptic.impactOccurred('heavy');
            break;
          case 'success':
            haptic.notificationOccurred('success');
            break;
          case 'error':
            haptic.notificationOccurred('error');
            break;
          case 'warning':
            haptic.notificationOccurred('warning');
            break;
        }
      } else if (navigator.vibrate) {
        // Fallback for non-Telegram environments
        const patterns = {
          light: 10,
          medium: 20,
          heavy: 30,
          success: [10, 50, 10],
          error: [20, 50, 20, 50, 20],
          warning: [10, 50, 20]
        };
        navigator.vibrate(patterns[type] || 10);
      }
    }

    // =====================
    // TELEGRAM INIT
    // =====================
    function initTelegram() {
      if (window.Telegram?.WebApp) {
        const tg = window.Telegram.WebApp;
        tg.ready();
        tg.expand();
        
        // Get Telegram user ID - try multiple methods
        const userId = tg.initDataUnsafe?.user?.id || 
                      tg.initData?.user?.id ||
                      tg.initDataUnsafe?.user_id ||
                      null;
        
        if (userId) {
          // Ensure it's a string and valid
          state.telegramId = String(userId);
          console.log('Telegram user ID:', state.telegramId);
          console.log('Telegram user data:', tg.initDataUnsafe?.user);
      } else {
          // Fallback for testing/development
          const demoId = localStorage.getItem('demo_telegram_id') || `demo_${Date.now()}`;
          localStorage.setItem('demo_telegram_id', demoId);
          state.telegramId = demoId;
          console.warn('No Telegram user ID found, using demo ID:', state.telegramId);
        }
      } else {
        // Fallback for non-Telegram environments
        const demoId = localStorage.getItem('demo_telegram_id') || `demo_${Date.now()}`;
        localStorage.setItem('demo_telegram_id', demoId);
        state.telegramId = demoId;
        console.warn('Not running in Telegram, using demo ID:', state.telegramId);
      }
      
      console.log('Final Telegram ID:', state.telegramId);
    }

    // =====================
    // UTILS
    // =====================
    function shortAddr(addr) {
      if (!addr) return '...';
      return `${addr.slice(0, 6)}...${addr.slice(-4)}`;
    }

    function formatUSD(num) {
      return `$${Number(num || 0).toFixed(2)}`;
    }

    function formatVolume(num) {
      if (!num) return '$0';
      if (num >= 1000000) return `$${(num / 1000000).toFixed(1)}M`;
      if (num >= 1000) return `$${(num / 1000).toFixed(1)}K`;
      return `$${num.toFixed(0)}`;
    }

    /**
     * NFL Team Colors Mapping
     * Primary colors for each NFL team
     */
    const NFL_TEAM_COLORS = {
      // NFC
      'rams': '#003594', // Rams Blue
      'los angeles rams': '#003594',
      'lar': '#003594',
      'la': '#003594',
      '49ers': '#AA0000', // 49ers Red
      'san francisco 49ers': '#AA0000',
      'sf': '#AA0000',
      'cowboys': '#003594', // Cowboys Blue
      'dallas cowboys': '#003594',
      'dal': '#003594',
      'packers': '#203731', // Packers Green
      'green bay packers': '#203731',
      'gb': '#203731',
      'bears': '#0B162A', // Bears Navy
      'chicago bears': '#0B162A',
      'chi': '#0B162A',
      'vikings': '#4F2683', // Vikings Purple
      'minnesota vikings': '#4F2683',
      'min': '#4F2683',
      'lions': '#0076B6', // Lions Blue
      'detroit lions': '#0076B6',
      'det': '#0076B6',
      'saints': '#D3BC8D', // Saints Gold
      'new orleans saints': '#D3BC8D',
      'no': '#D3BC8D',
      'falcons': '#A71930', // Falcons Red
      'atlanta falcons': '#A71930',
      'atl': '#A71930',
      'panthers': '#0085CA', // Panthers Blue
      'carolina panthers': '#0085CA',
      'car': '#0085CA',
      'buccaneers': '#D50A0A', // Bucs Red
      'tampa bay buccaneers': '#D50A0A',
      'tb': '#D50A0A',
      'cardinals': '#97233F', // Cardinals Red
      'arizona cardinals': '#97233F',
      'ari': '#97233F',
      'seahawks': '#002244', // Seahawks Blue
      'seattle seahawks': '#002244',
      'sea': '#002244',
      'commanders': '#5A1414', // Commanders Burgundy
      'washington commanders': '#5A1414',
      'was': '#5A1414',
      'wsh': '#5A1414',
      'giants': '#0B2265', // Giants Blue
      'new york giants': '#0B2265',
      'nyg': '#0B2265',
      'eagles': '#004C54', // Eagles Green
      'philadelphia eagles': '#004C54',
      'phi': '#004C54',
      
      // AFC
      'broncos': '#FB4F14', // Broncos Orange
      'denver broncos': '#FB4F14',
      'den': '#FB4F14',
      'chiefs': '#E31837', // Chiefs Red
      'kansas city chiefs': '#E31837',
      'kc': '#E31837',
      'raiders': '#000000', // Raiders Black
      'las vegas raiders': '#000000',
      'lv': '#000000',
      'chargers': '#0080C6', // Chargers Blue
      'los angeles chargers': '#0080C6',
      'lac': '#0080C6',
      'patriots': '#002244', // Patriots Blue
      'new england patriots': '#002244',
      'ne': '#002244',
      'jets': '#125740', // Jets Green
      'new york jets': '#125740',
      'nyj': '#125740',
      'bills': '#00338D', // Bills Blue
      'buffalo bills': '#00338D',
      'buf': '#00338D',
      'dolphins': '#008E97', // Dolphins Teal
      'miami dolphins': '#008E97',
      'mia': '#008E97',
      'ravens': '#241773', // Ravens Purple
      'baltimore ravens': '#241773',
      'bal': '#241773',
      'bengals': '#FB4F14', // Bengals Orange
      'cincinnati bengals': '#FB4F14',
      'cin': '#FB4F14',
      'browns': '#311D00', // Browns Brown
      'cleveland browns': '#311D00',
      'cle': '#311D00',
      'steelers': '#FFB612', // Steelers Gold
      'pittsburgh steelers': '#FFB612',
      'pit': '#FFB612',
      'texans': '#03202F', // Texans Navy
      'houston texans': '#03202F',
      'hou': '#03202F',
      'colts': '#002C5F', // Colts Blue
      'indianapolis colts': '#002C5F',
      'ind': '#002C5F',
      'jaguars': '#006778', // Jaguars Teal
      'jacksonville jaguars': '#006778',
      'jax': '#006778',
      'titans': '#0C2340', // Titans Navy
      'tennessee titans': '#0C2340',
      'ten': '#0C2340',
    };

    /**
     * Extract team name from text (case-insensitive)
     * Checks for team names/abbreviations using word boundaries to avoid partial matches
     */
    function extractTeamName(text) {
      if (!text) return null;
      const lowerText = text.toLowerCase().trim();
      
      // Sort team names by length (longest first) to match full names before abbreviations
      const teamEntries = Object.entries(NFL_TEAM_COLORS).sort((a, b) => b[0].length - a[0].length);
      
      // Check for exact team name matches (with word boundaries for abbreviations)
      for (const [teamName, color] of teamEntries) {
        // For short abbreviations (2-3 chars), use word boundary matching
        if (teamName.length <= 3) {
          const regex = new RegExp(`\\b${teamName}\\b`, 'i');
          if (regex.test(lowerText)) {
            return teamName;
          }
        } else {
          // For longer names, use substring matching
          if (lowerText.includes(teamName)) {
            return teamName;
          }
        }
      }
      
      return null;
    }

    /**
     * Get team color for an outcome
     * Returns the team color if the outcome represents a team
     * For non-team markets with Yes/No outcomes, uses Polymarket pattern (green for Yes, red for No)
     * Otherwise generates a color based on market
     */
    function getOutcomeColor(market, outcome, outcomeIndex) {
      if (!market || !outcome) return '#003366'; // Default blue
      
      const outcomeLower = outcome.toLowerCase().trim();
      const questionLower = (market.question || '').toLowerCase();
      
      // First, try to extract team name directly from the outcome text
      let teamName = extractTeamName(outcomeLower);
      if (teamName && NFL_TEAM_COLORS[teamName]) {
        return NFL_TEAM_COLORS[teamName];
      }
      
      // If not found in outcome, try the full market question + outcome context
      const marketText = `${questionLower} ${outcomeLower}`;
      teamName = extractTeamName(marketText);
      if (teamName && NFL_TEAM_COLORS[teamName]) {
        return NFL_TEAM_COLORS[teamName];
      }
      
      // For markets with "vs" or team names in question, try to match outcome position
      // If question has teams and outcomes are positional (first/second outcome = first/second team)
      if (questionLower.includes(' vs ') || questionLower.includes(' vs. ')) {
        const teamsInQuestion = [];
        for (const [teamNameKey, color] of Object.entries(NFL_TEAM_COLORS)) {
          if (questionLower.includes(teamNameKey)) {
            teamsInQuestion.push({ name: teamNameKey, color });
          }
        }
        // If we found teams and outcomes match positionally
        if (teamsInQuestion.length >= 2 && outcomeIndex < teamsInQuestion.length) {
          return teamsInQuestion[outcomeIndex].color;
        } else if (teamsInQuestion.length === 1 && outcomeIndex === 0) {
          // First outcome uses first team's color
          return teamsInQuestion[0].color;
        }
      }
      
      // For non-team markets: use Polymarket pattern - green for Yes, red for No
      // Check for Yes/No BEFORE checking teams to avoid conflicts (but only if not a team matchup)
      const isTeamMatchup = questionLower.includes(' vs ') || questionLower.includes(' vs. ') ||
                            extractTeamName(questionLower) !== null;
      
      if (!isTeamMatchup) {
        if (outcomeLower === 'yes' || outcomeLower === 'y') {
          return '#10B981'; // Green (similar to Polymarket's Yes button color)
        }
        if (outcomeLower === 'no' || outcomeLower === 'n') {
          return '#EF4444'; // Red (similar to Polymarket's No button color)
        }
      }
      
      // Fallback: generate color based on market for consistency
      const seed = `${market.id || market.conditionId || market.question || 'default'}_${outcomeIndex}`;
      let hash = 0;
      for (let i = 0; i < seed.length; i++) {
        hash = seed.charCodeAt(i) + ((hash << 5) - hash);
      }
      
      const hue = 200 + (Math.abs(hash) % 40);
      const saturation = 60 + (Math.abs(hash) % 25);
      const lightness = 35 + (Math.abs(hash) % 15);
      
      return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
    }

    /**
     * Generate a deterministic color for a market based on market data
     * Returns a blue-ish color (matching Polymarket's pattern)
     * Uses market ID or question to ensure consistent colors
     */
    function getMarketColor(market) {
      if (!market) return '#003366'; // Default blue
      
      // Use market ID or question to generate consistent color
      const seed = market.id || market.conditionId || market.question || 'default';
      
      // Simple hash function to convert seed to number
      let hash = 0;
      for (let i = 0; i < seed.length; i++) {
        hash = seed.charCodeAt(i) + ((hash << 5) - hash);
      }
      
      // Generate blue color palette (similar to Polymarket's blue theme)
      // Use different shades of blue based on hash
      const hue = 200 + (hash % 40); // Blue range: 200-240
      const saturation = 60 + (hash % 25); // 60-85%
      const lightness = 35 + (hash % 15); // 35-50% (darker blues)
      
      return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
    }

    // =====================
    // ONBOARDING FLOW
    // =====================
    const STORAGE_KEY = 'polygram_access';
    const VALID_PASSKEYS = ['EARLYBIRD', 'POLYGRAM2024', 'TRADEPRO', 'BETAACCESS', 'PUBLICLABS'];

    function checkAccess() {
      const urlParams = new URLSearchParams(window.location.search);
      if (urlParams.get('bypass') === 'true') return true;
      
      const stored = localStorage.getItem(STORAGE_KEY);
      if (stored) {
        try {
          const data = JSON.parse(stored);
          if (data.validated) return true;
        } catch (e) {}
      }
      return false;
    }

    function grantAccess(passkey) {
      localStorage.setItem(STORAGE_KEY, JSON.stringify({
        validated: true,
        passkey: passkey,
        timestamp: Date.now()
      }));
    }

    function showSplash() {
      document.getElementById('splashScreen').classList.remove('hidden');
    }

    function hideSplash() {
      document.getElementById('splashScreen').classList.add('hidden');
    }

    function showOnboarding() {
      document.getElementById('onboardingScreen').classList.add('visible');
    }

    function hideOnboarding() {
      document.getElementById('onboardingScreen').classList.remove('visible');
    }

    function showMainApp() {
      document.getElementById('appShell').classList.add('visible');
      bootstrapApp();
    }

    function initOnboarding() {
      const input = document.getElementById('passkeyInput');
      const btn = document.getElementById('passkeyBtn');
      const error = document.getElementById('passkeyError');

      btn.addEventListener('click', () => {
        const passkey = input.value.trim().toUpperCase();
        
        if (VALID_PASSKEYS.includes(passkey)) {
          btn.textContent = '✓';
          grantAccess(passkey);
          setTimeout(() => {
            hideOnboarding();
            showMainApp();
          }, 500);
        } else {
          input.classList.add('error');
          error.classList.add('visible');
          setTimeout(() => {
            input.classList.remove('error');
          }, 400);
        }
      });

      input.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') btn.click();
      });

      input.addEventListener('input', () => {
        error.classList.remove('visible');
      });
    }

    // =====================
    // WALLET MANAGEMENT
    // =====================
    // =====================
    // WALLET - CLIENT SIDE
    // =====================
    const WALLET_STORAGE_KEY = 'polygram_wallet';

    function generateSolanaAddress() {
      const chars = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
      let result = '';
      for (let i = 0; i < 44; i++) {
        result += chars.charAt(Math.floor(Math.random() * chars.length));
      }
      return result;
    }

    function getOrCreateWallet() {
      // Check localStorage first
      const stored = localStorage.getItem(WALLET_STORAGE_KEY);
      if (stored) {
        try {
          const wallet = JSON.parse(stored);
          if (wallet.polygon && wallet.solana) {
            console.log('Loaded existing wallet from localStorage');
            return wallet;
          }
        } catch (e) {
          console.error('Failed to parse stored wallet:', e);
        }
      }

      // Generate new wallets
      console.log('Generating new wallets...');
      
      // Generate Polygon wallet using ethers.js
      const polygonWallet = ethers.Wallet.createRandom();
      
      // Generate Solana-style address
      const solanaAddress = generateSolanaAddress();

      const wallet = {
        polygon: polygonWallet.address,
        polygonPrivateKey: polygonWallet.privateKey, // Store encrypted in production!
        solana: solanaAddress,
        solanaPrivateKey: 'sol_' + solanaAddress.substring(0, 32), // Placeholder
        userId: state.telegramId,
        createdAt: new Date().toISOString(),
      };

      // Save to localStorage
      localStorage.setItem(WALLET_STORAGE_KEY, JSON.stringify(wallet));
      console.log('New wallet created and saved');
      
      return wallet;
    }

    async function loadWallet() {
      try {
        console.log('Loading/creating wallet for:', state.telegramId);
        
        // Call API to get or create wallet
        const resp = await fetch(`/api/wallet?telegram_id=${encodeURIComponent(state.telegramId)}`);
        
        if (!resp.ok) {
          let errorData;
          try {
            errorData = await resp.json();
          } catch (e) {
            errorData = { message: `HTTP ${resp.status}: ${resp.statusText}` };
          }
          
          // Check for specific error types
          if (errorData.error === 'encryption_key_error' || errorData.code === 'ENCRYPTION_KEY_MISSING' || errorData.code === 'ENCRYPTION_KEY_INVALID_LENGTH') {
            throw new Error('SERVER_CONFIG_ERROR');
          }
          
          throw new Error(errorData.message || `HTTP ${resp.status}: Failed to load wallet`);
        }
        
        const data = await resp.json();
        
        if (!data.success || !data.wallet) {
          // Check if there's a warning (like missing Supabase)
          if (data.warning) {
            console.warn('Wallet warning:', data.warning);
          }
          throw new Error('Invalid wallet response from server');
        }
        
        const wallet = {
          solana: data.wallet.solana,
          polygon: data.wallet.polygon,
          userId: data.wallet.userId,
          createdAt: data.wallet.createdAt
        };
        
        state.wallet = wallet;
        
        console.log('Wallet loaded:', wallet.polygon, wallet.solana, data.isNew ? '(new)' : '(existing)');
        
        // Display SOL wallet
        const solEl = document.getElementById('solWalletAddress');
        if (solEl) solEl.textContent = wallet.solana;
        
        // Display USDC wallet (Polygon)
        const usdcEl = document.getElementById('usdcWalletAddress');
        if (usdcEl) usdcEl.textContent = wallet.polygon;
        
        // Update status
        const statusEl = document.getElementById('walletStatusBar');
        if (statusEl) {
          // Check for warnings (like encryption key missing)
          if (data.warning || data.error === 'encryption_key_missing') {
            statusEl.textContent = '⚠ Wallets created (not saved - config issue)';
            statusEl.style.background = 'var(--yellow)';
            statusEl.style.color = 'var(--text)';
            console.warn('Wallet warning:', data.warning || data.help);
          } else {
            if (data.isNew) {
              statusEl.textContent = '✓ Wallets created - fund to trade';
            } else {
              statusEl.textContent = '✓ Wallets loaded - fund to trade';
            }
            statusEl.style.background = 'var(--accent)';
            statusEl.style.color = 'white';
          }
        }
        
        // Setup copy buttons and make addresses clickable
        setupCopyButton('copySolBtn', wallet.solana);
        setupCopyButton('copyUsdcBtn', wallet.polygon);
        setupClickableAddress('solWalletAddress', wallet.solana);
        setupClickableAddress('usdcWalletAddress', wallet.polygon);
        
        // Load balance from Supabase and on-chain
        await loadBalance();
        
      } catch (err) {
        console.error('Wallet error:', err);
        const solEl = document.getElementById('solWalletAddress');
        const usdcEl = document.getElementById('usdcWalletAddress');
        const statusEl = document.getElementById('walletStatusBar');
        
        if (solEl) solEl.textContent = 'Error loading';
        if (usdcEl) usdcEl.textContent = 'Error loading';
        
        // Show user-friendly error message
        let errorMsg = 'Error loading wallet';
        let isConfigError = false;
        
        if (err.message) {
          // Check for specific error types
          if (err.message === 'SERVER_CONFIG_ERROR' || 
              err.message.includes('ENCRYPTION_KEY') || 
              err.message.includes('encryption_key_error') ||
              err.message.includes('ENCRYPTION_KEY must be exactly 64')) {
            errorMsg = 'Server configuration error. Please contact support.';
            isConfigError = true;
          } else if (err.message.includes('database_not_configured') || err.message.includes('Supabase not configured')) {
            errorMsg = 'Database not configured. Please contact support.';
            isConfigError = true;
          } else if (err.message.includes('missing_user_id') || err.message.includes('telegram_id is required')) {
            errorMsg = 'Unable to identify user. Please refresh the page.';
          } else if (err.message.includes('Failed to fetch') || err.message.includes('NetworkError')) {
            errorMsg = 'Network error. Please check your connection.';
          } else {
            // Show shortened error message
            const shortMsg = err.message.length > 60 ? err.message.substring(0, 60) + '...' : err.message;
            errorMsg = shortMsg;
          }
        }
        
        if (statusEl) {
          statusEl.textContent = errorMsg;
          if (isConfigError) {
            statusEl.style.background = 'var(--red)';
            statusEl.style.color = 'white';
          } else {
            statusEl.style.background = 'var(--accent)';
            statusEl.style.color = 'white';
          }
        }
        
        // Log full error for debugging
        console.error('Full wallet error:', err);
        console.error('Error stack:', err.stack);
      }
    }

    async function copyToClipboard(text) {
      try {
        await navigator.clipboard.writeText(text);
        hapticFeedback('light');
        return true;
      } catch (err) {
        console.error('Copy failed:', err);
        // Fallback for older browsers
        const textArea = document.createElement('textarea');
        textArea.value = text;
        textArea.style.position = 'fixed';
        textArea.style.opacity = '0';
        document.body.appendChild(textArea);
        textArea.select();
        document.execCommand('copy');
        document.body.removeChild(textArea);
        hapticFeedback('light');
        return true;
      }
    }

    function setupCopyButton(btnId, address) {
      const btn = document.getElementById(btnId);
      if (!btn || !address) return;
      
      btn.onclick = async () => {
        const success = await copyToClipboard(address);
        if (success) {
          btn.classList.add('copied');
          btn.innerHTML = `<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="20 6 9 17 4 12"></polyline></svg>`;
          
          setTimeout(() => {
            btn.classList.remove('copied');
            btn.innerHTML = `<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>`;
          }, 2000);
        }
      };
    }

    function setupClickableAddress(elementId, address) {
      const el = document.getElementById(elementId);
      if (!el || !address) return;
      
      el.onclick = async () => {
        const success = await copyToClipboard(address);
        if (success) {
          // Visual feedback
          const originalBg = el.style.background;
          el.style.background = 'var(--green-soft)';
          el.textContent = 'Copied!';
          
          setTimeout(() => {
            el.style.background = originalBg;
            el.textContent = address;
          }, 1500);
        }
      };
    }

    async function loadBalance() {
      if (!state.wallet) {
      document.getElementById('usdcBalance').textContent = '$0.00';
      document.getElementById('positionsValue').textContent = '$0.00';
      document.getElementById('totalBalance').textContent = '$0.00';
        return;
      }

      try {
        // Try to fetch balance from API
        const resp = await fetch(`/api/balances?telegram_id=${encodeURIComponent(state.telegramId)}`);
        if (resp.ok) {
          const data = await resp.json();
          if (data.success) {
            document.getElementById('usdcBalance').textContent = `$${data.usdc.toFixed(2)}`;
            document.getElementById('positionsValue').textContent = `$${data.positions.toFixed(2)}`;
            document.getElementById('totalBalance').textContent = `$${data.total.toFixed(2)}`;
            
            // Update wallet status if available
            if (data.walletStatus) {
              const statusEl = document.getElementById('walletStatusBar');
              if (statusEl) {
                if (data.walletStatus.exists) {
                  if (data.walletStatus.clobRegistered && data.walletStatus.usdcApproved) {
                    statusEl.textContent = '✓ Wallet ready for trading';
                  } else if (data.walletStatus.clobRegistered) {
                    statusEl.textContent = '⚠ CLOB registered - approve USDC to trade';
                  } else {
                    statusEl.textContent = '⚠ Register with CLOB to trade';
                  }
                } else {
                  statusEl.textContent = '✓ Wallets ready - fund to trade';
                }
              }
            }
            return;
          }
        }
      } catch (err) {
        console.log('[loadBalance] API not available, using defaults:', err.message);
      }

      // Fallback: show zero balances
      document.getElementById('usdcBalance').textContent = '$0.00';
      document.getElementById('positionsValue').textContent = '$0.00';
      document.getElementById('totalBalance').textContent = '$0.00';
    }

    // =====================
    // CATEGORIES
    // =====================
    function showSubFilters(category) {
      const subFiltersContainer = document.getElementById('subFilters');
      
      // Define sub-filters for each category (based on popular tags)
      const subFiltersMap = {
        'politics': ['All', 'Trump', 'Biden', 'Election', 'Breaking News'],
        'sports': ['All', 'NFL', 'NBA', 'MLB', 'NHL'],
        'crypto': ['All', 'Bitcoin', 'Ethereum', 'Solana', 'DeFi'],
        'finance': ['All', 'Fed', 'Stocks', 'Economy', 'Earnings'],
        'tech': ['All', 'AI', 'Apple', 'Google', 'Meta'],
        'geopolitics': ['All', 'Ukraine', 'Middle East', 'China', 'Russia'],
      };
      
      const filters = subFiltersMap[category.toLowerCase()];
      if (filters && filters.length > 0) {
        subFiltersContainer.innerHTML = filters.map((filter, index) => `
          <button class="sub-filter-btn ${index === 0 ? 'active' : ''}" 
                  data-filter="${filter.toLowerCase()}">
            ${filter}
          </button>
        `).join('');
        
        subFiltersContainer.style.display = 'flex';
        
        // Add click handlers
        subFiltersContainer.querySelectorAll('.sub-filter-btn').forEach(btn => {
          btn.addEventListener('click', () => {
            hapticFeedback('light');
            subFiltersContainer.querySelectorAll('.sub-filter-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            state.selectedSubFilter = btn.dataset.filter;
            // Re-fetch markets with sub-filter
            fetchMarkets(category);
          });
        });
      } else {
        subFiltersContainer.style.display = 'none';
      }
    }

    async function fetchCategories() {
      try {
        const resp = await fetch('/api/categories');
        if (resp.ok) {
          const data = await resp.json();
          return data.categories || [];
        }
      } catch (err) {
        console.error('[fetchCategories] Error:', err);
      }
      return [];
    }

    function renderCategories(categories) {
      const container = document.getElementById('categoryScroll');
      if (!container) return;

      container.innerHTML = categories.map(cat => {
        const isActive = state.selectedCategory === cat.slug;
        return `
          <button class="category-chip ${isActive ? 'active' : ''}" 
                  data-kind="${cat.slug}" 
                  data-id="${cat.id}">
            ${cat.icon} ${cat.label}
          </button>
        `;
      }).join('');

      // Add click handlers
          container.querySelectorAll('.category-chip').forEach(chip => {
            chip.addEventListener('click', () => {
              hapticFeedback('light');
              const kind = chip.dataset.kind;
              state.selectedCategory = kind;
              
              // Update active state
              container.querySelectorAll('.category-chip').forEach(c => c.classList.remove('active'));
              chip.classList.add('active');
              
              // Scroll to active chip (center it if possible)
              chip.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'center' });
              
              // If sports is clicked, go directly to NFL games
              if (kind === 'sports') {
                state.selectedCategory = 'nfl';
                state.selectedSportType = 'games';
                // Hide sub-filters since we're going directly to NFL games
                const subFiltersContainer = document.getElementById('subFiltersContainer');
                if (subFiltersContainer) {
                  subFiltersContainer.style.display = 'none';
                }
                fetchMarkets('nfl', 'games');
              } else {
                // Fetch markets for this category
                fetchMarkets(kind);
                // Show sub-filters if available for this category
                showSubFilters(kind);
              }
            });
          });
    }

    async function showSportsSubcategories() {
      // Show Games and Props as top-level sports subcategories
      const list = document.getElementById('marketsList');
      list.innerHTML = `
        <div style="margin-bottom: 16px; font-size: 14px; color: var(--text-muted);">
          Select a category:
        </div>
        <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px;">
          <button class="category-chip" 
                  data-sport-type="games" 
                  style="width: 100%; justify-content: flex-start; padding: 12px 16px;">
            Games
          </button>
          <button class="category-chip" 
                  data-sport-type="props" 
                  style="width: 100%; justify-content: flex-start; padding: 12px 16px;">
            Props
          </button>
        </div>
      `;
      
      // Add click handlers for Games and Props
          list.querySelectorAll('.category-chip').forEach(btn => {
            btn.addEventListener('click', () => {
              hapticFeedback('light');
              const sportType = btn.dataset.sportType;
              state.selectedSportType = sportType;
              showSportsByType(sportType);
            });
          });
    }

    async function showSportsByType(type) {
      // type is either "games" or "props"
      try {
        const resp = await fetch('/api/sports-subcategories');
        if (resp.ok) {
          const data = await resp.json();
          const subcategories = data.subcategories || [];
          
          if (subcategories.length > 0) {
            // Render sports subcategories in the markets list area
            const list = document.getElementById('marketsList');
            list.innerHTML = `
              <div style="margin-bottom: 16px; font-size: 14px; color: var(--text-muted);">
                Select a sport:
              </div>
              <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px;">
                ${subcategories.map(sub => `
                  <button class="category-chip" 
                          data-sport="${sub.slug}" 
                          data-sport-type="${type}"
                          style="width: 100%; justify-content: flex-start; padding: 12px 16px;">
                    ${sub.label}
                  </button>
                `).join('')}
              </div>
            `;
            
            // Add click handlers for sports subcategories
            list.querySelectorAll('.category-chip').forEach(btn => {
              btn.addEventListener('click', () => {
                hapticFeedback('light');
                const sportSlug = btn.dataset.sport;
                const sportType = btn.dataset.sportType;
                state.selectedCategory = sportSlug;
                state.selectedSportType = sportType;
                // Fetch markets for this sport, passing sportType to filter games vs props
                fetchMarkets(sportSlug, sportType);
              });
            });
          } else {
            // Fallback: fetch sports markets directly
            fetchMarkets('sports');
          }
        } else {
          // Fallback: fetch sports markets directly
          fetchMarkets('sports');
        }
      } catch (err) {
        console.error('[showSportsByType] Error:', err);
        // Fallback: fetch sports markets directly
        fetchMarkets('sports');
      }
    }

    // =====================
    // MARKETS
    // =====================
    // Get current NFL week (NFL season typically starts in early September)
    function getCurrentNFLWeek() {
      const now = new Date();
      const currentYear = now.getFullYear();
      
      // NFL season typically starts around September 5-10 (Week 1)
      // Calculate approximate start date (first Thursday of September)
      let seasonStart = new Date(currentYear, 8, 1); // September 1st
      // Find first Thursday in September
      while (seasonStart.getDay() !== 4) { // 4 = Thursday
        seasonStart.setDate(seasonStart.getDate() + 1);
      }
      // Adjust to September 5-10 range (typical NFL season start)
      if (seasonStart.getDate() < 5) {
        seasonStart.setDate(5);
      } else if (seasonStart.getDate() > 10) {
        seasonStart.setDate(5);
      }
      
      // If we're before the season start, check previous year
      if (now < seasonStart) {
        seasonStart = new Date(currentYear - 1, 8, 1);
        while (seasonStart.getDay() !== 4) {
          seasonStart.setDate(seasonStart.getDate() + 1);
        }
        if (seasonStart.getDate() < 5) {
          seasonStart.setDate(5);
        } else if (seasonStart.getDate() > 10) {
          seasonStart.setDate(5);
        }
      }
      
      // Calculate weeks since season start (each week is 7 days)
      const daysDiff = Math.floor((now - seasonStart) / (1000 * 60 * 60 * 24));
      const weekNum = Math.floor(daysDiff / 7) + 1;
      
      // Clamp to valid NFL weeks (1-18 for regular season, 19-22 for playoffs)
      if (weekNum < 1) return 1;
      if (weekNum > 22) return null; // Season ended
      
      return weekNum;
    }

    async function fetchMarkets(kind = 'trending', sportType = null) {
      const list = document.getElementById('marketsList');
      list.innerHTML = '<div class="loading">Loading markets...</div>';

      try {
        console.log('[fetchMarkets] Fetching:', kind, 'sportType:', sportType, 'platform:', state.selectedPlatform);
        // Reduce limit for faster loading - 1000 markets is plenty for initial display
        // Only show markets with volume - filter out zero-volume markets (use $0.01 minimum)
        // Don't filter by volume by default - show all active markets to match Polymarket
        let apiUrl = `/api/markets?kind=${kind}&limit=1000&platform=${state.selectedPlatform || 'polymarket'}`;
        if (sportType) {
          apiUrl += `&sportType=${sportType}`;
        }
        // For NFL games, add current week parameter
        if (kind.toLowerCase() === 'nfl' && sportType === 'games') {
          const currentWeek = getCurrentNFLWeek();
          if (currentWeek) {
            apiUrl += `&week=${currentWeek}`;
            console.log('[fetchMarkets] Filtering NFL games by week:', currentWeek);
          }
        }
        console.log('[fetchMarkets] URL:', apiUrl);
        
        const resp = await fetch(apiUrl);
        console.log('[fetchMarkets] Status:', resp.status, resp.statusText);
        
        if (!resp.ok) {
          let errorData;
          try {
            errorData = await resp.json();
          } catch (e) {
            const errorText = await resp.text();
            throw new Error(`HTTP ${resp.status}: ${errorText.substring(0, 100)}`);
          }
          
          // Handle Kalshi authentication/configuration errors
          if (resp.status === 503 && errorData.requiresAuth && state.selectedPlatform === 'kalshi') {
            throw new Error('Kalshi API requires authentication. Please configure KALSHI_ACCESS_KEY and KALSHI_PRIVATE_KEY environment variables.');
          }
          
          throw new Error(errorData.message || errorData.error || `HTTP ${resp.status}`);
        }
        
        const data = await resp.json();
        // #region agent log
        fetch('http://127.0.0.1:7243/ingest/cf0ac01b-cbf1-4c16-aaa3-32490620eb9e',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'index.html:2611',message:'API response received',data:{marketCount: data.markets?.length || 0, meta: data.meta, firstMarketQuestion: data.markets?.[0]?.question, firstMarketCategory: data.markets?.[0]?.eventTitle},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'C'})}).catch(()=>{});
        // #endregion
        console.log('[fetchMarkets] Response data:', data);
        console.log('[fetchMarkets] Markets count:', data.markets?.length || 0);
        
        const markets = data.markets || [];
        
        if (markets.length > 0) {
          console.log('[fetchMarkets] First market:', markets[0]);
          console.log('[fetchMarkets] Sample market structure:', {
            hasEventId: !!markets[0]?.eventId,
            hasEventTitle: !!markets[0]?.eventTitle,
            question: markets[0]?.question,
            eventTitle: markets[0]?.eventTitle,
            outcomes: markets[0]?.outcomes,
            outcomePrices: markets[0]?.outcomePrices
          });
          state.markets = markets;
          renderMarkets(markets);
        } else {
          console.log('[fetchMarkets] No markets in response');
          list.innerHTML = `<div class="loading">No markets found. <br><small style="color:var(--text-muted)">API responded but returned 0 markets</small></div>`;
        }
      } catch (err) {
        console.error('[fetchMarkets] Error:', err);
        list.innerHTML = `
          <div class="loading" style="color:#d97777;">
            Failed to load markets<br>
            <small style="color:var(--text-muted)">${err.message}</small>
          </div>
        `;
      }
    }

    // Format volume for display (e.g., 416000 -> "$416k")
    function formatVolume(volume) {
      const vol = parseFloat(volume) || 0;
      if (vol >= 1000000) {
        return '$' + (vol / 1000000).toFixed(vol >= 10000000 ? 0 : 1) + 'm';
      } else if (vol >= 1000) {
        return '$' + (vol / 1000).toFixed(vol >= 10000 ? 0 : 1) + 'k';
      } else {
        return '$' + vol.toFixed(0);
      }
    }

    function renderMarkets(markets) {
      const list = document.getElementById('marketsList');
      
      console.log('[renderMarkets] Rendering', markets.length, 'markets');
      console.log('[renderMarkets] selectedCategory:', state.selectedCategory);
      console.log('[renderMarkets] Markets with event data:', markets.filter(m => m.eventId && m.eventTitle).length);
      
      // Check if we should group by events (for NFL games)
      const shouldGroupByEvent = state.selectedCategory === 'nfl' && 
                                  markets.some(m => m.eventId && m.eventTitle);
      
      console.log('[renderMarkets] shouldGroupByEvent:', shouldGroupByEvent);
      
      if (shouldGroupByEvent && markets.length > 0) {
        // Group markets by event
        const eventsMap = new Map();
        markets.forEach(m => {
          const eventId = m.eventId || 'ungrouped';
          const eventTitle = m.eventTitle || 'Other Markets';
          
          if (!eventsMap.has(eventId)) {
            eventsMap.set(eventId, {
              eventId: eventId,
              eventTitle: eventTitle,
              eventImage: m.eventImage || m.image,
              eventVolume: m.eventVolume || 0,
              eventStartDate: m.eventStartDate,
              markets: []
            });
          }
          eventsMap.get(eventId).markets.push(m);
        });
        
        // Calculate total volume for each event (use event volume if available, otherwise sum all market volumes)
        let sortedEvents = Array.from(eventsMap.values()).map(event => {
          // Use eventVolume if available (this is the total volume from Polymarket API)
          // Otherwise, sum all market volumes (use volume, not volume24hr, for total event volume)
          let totalVol = 0;
          if (event.eventVolume && parseFloat(event.eventVolume) > 0) {
            totalVol = parseFloat(event.eventVolume);
          } else {
            // Sum all market volumes (use total volume, not 24hr volume, for aggregate)
            totalVol = event.markets.reduce((sum, m) => {
              const vol = parseFloat(m.volume) || parseFloat(m.volume24hr) || 0;
              return sum + vol;
            }, 0);
          }
          return { ...event, totalVolume: totalVol };
        });
        
        // Sort events by total volume (highest first)
        sortedEvents.sort((a, b) => b.totalVolume - a.totalVolume);
        
        // Render events with their markets
        list.innerHTML = sortedEvents.map(event => {
          const eventVol = event.totalVolume;
          const eventImg = event.eventImage || event.markets[0]?.image || '';
          const hasImage = eventImg && eventImg.trim() !== '';
          
          // Get week tag if available
          const weekTag = event.markets[0]?.eventTags?.find(t => 
            (typeof t === 'string' ? t : (t.slug || t.label || '')).toLowerCase().includes('week')
          );
          const weekLabel = weekTag ? (typeof weekTag === 'string' ? weekTag : (weekTag.label || weekTag.slug || '')) : '';
          
          // Find primary moneyline market (the main game outcome)
          const moneylineMarket = event.markets.find(m => {
            const q = (m.question || '').toLowerCase();
            return q.includes('moneyline') || q.includes('ml') || 
                   (q.includes(' vs ') && !q.includes('spread') && !q.includes('total') && !q.includes('o/u'));
          }) || event.markets[0];
          
          // Get primary prices for moneyline (first two outcomes)
          const primaryPrices = moneylineMarket?.outcomePrices || [];
          const primaryOutcomes = moneylineMarket?.outcomes || [];
          const price1 = primaryPrices[0] !== undefined ? (parseFloat(primaryPrices[0]) * 100).toFixed(0) + '¢' : '--';
          const price2 = primaryPrices[1] !== undefined ? (parseFloat(primaryPrices[1]) * 100).toFixed(0) + '¢' : '--';
          const outcome1 = primaryOutcomes[0] || 'Yes';
          const outcome2 = primaryOutcomes[1] || 'No';
          
          return `
            <div class="event-group" data-event-id="${event.eventId}">
              <div class="event-header" style="padding: 16px; border-bottom: 1px solid var(--border);">
                ${hasImage ? `<img class="event-image" src="${eventImg}" alt="" onerror="this.classList.add('hidden')" style="width: 40px; height: 40px; border-radius: 8px; margin-right: 12px; object-fit: cover;" />` : ''}
                <div class="event-info" style="flex: 1;">
                  <div class="event-title" style="font-size: 16px; font-weight: 600; margin-bottom: 4px; color: var(--text);">
                    ${event.eventTitle}
                  </div>
                  <div class="event-meta" style="font-size: 14px; color: var(--text-muted);">
                    ${formatVolume(eventVol)} Vol.
                  </div>
                </div>
              </div>
              <div class="event-markets" data-event-markets="${event.eventId}">
                ${event.markets.map(m => {
                  const prices = m.outcomePrices || [];
                  const outcomes = m.outcomes || ["Yes", "No"];
                  const vol = m.volume24hr || m.volume || 0;
                  
                  // Get market color for this market
                  const marketColor = getMarketColor(m);
                  
                  return `
                    <div class="market-outcome-item" data-id="${m.id}" data-market-id="${m.id}" style="cursor: pointer; --market-color: ${marketColor};">
                      <div class="outcome-label">${m.question}</div>
                      <div class="outcome-buttons">
                        ${outcomes.map((outcome, idx) => {
                          const price = prices[idx] !== undefined ? (parseFloat(prices[idx]) * 100).toFixed(0) + '¢' : '--';
                          const isYes = outcome.toLowerCase() === 'yes' || idx === 0;
                          // Get team-specific color for this outcome
                          const outcomeColor = getOutcomeColor(m, outcome, idx);
                          return `
                            <div class="outcome-button-group">
                              <span class="outcome-price">${price}</span>
                              <button class="outcome-btn ${isYes ? 'outcome-yes' : 'outcome-no'}" 
                                      data-market-id="${m.id}" 
                                      data-outcome-index="${idx}"
                                      style="background: ${outcomeColor}; color: white; border-color: ${outcomeColor};">
                                ${outcome}
                              </button>
                            </div>
                          `;
                        }).join('')}
                      </div>
                    </div>
                  `;
                }).join('')}
              </div>
            </div>
          `;
        }).join('');
      } else {
        // Render as flat list (original behavior)
      list.innerHTML = markets.map(m => {
        const prices = m.outcomePrices || [];
          const outcomes = m.outcomes || ["Yes", "No"];
        const vol = m.volume24hr || m.volume || 0;
          const imgUrl = m.image || m.eventImage || m.icon || '';
          const hasImage = imgUrl && imgUrl.trim() !== '';
        
        // Get market color for this market
        const marketColor = getMarketColor(m);
        
        return `
            <div class="market-card" data-id="${m.id}" style="--market-color: ${marketColor};">
              <div class="market-card-header">
                ${hasImage ? `<img class="market-image" src="${imgUrl}" alt="" onerror="this.classList.add('hidden')" />` : ''}
                <div class="market-title">${m.question}</div>
              </div>
              <div class="market-outcomes">
                ${outcomes.map((outcome, idx) => {
                  const price = prices[idx] !== undefined ? (parseFloat(prices[idx]) * 100).toFixed(0) + '¢' : '--';
                  const isYes = outcome.toLowerCase() === 'yes' || idx === 0;
                  return `
                    <div class="outcome-button-group">
                      <span class="outcome-price">${price}</span>
                      <button class="outcome-btn ${isYes ? 'outcome-yes' : 'outcome-no'}" 
                              data-market-id="${m.id}" 
                              data-outcome-index="${idx}">
                        ${outcome}
                      </button>
            </div>
                  `;
                }).join('')}
              </div>
              <div class="market-card-footer">
                <span class="market-volume">${formatVolume(vol)} Vol.</span>
                <span class="market-icon">🎁</span>
            </div>
          </div>
        `;
      }).join('');
      }

      // Add click handlers for event price buttons
      list.querySelectorAll('.event-price-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.stopPropagation();
          hapticFeedback('light');
          const marketId = btn.dataset.marketId;
          const outcomeIndex = parseInt(btn.dataset.outcomeIndex, 10);
          const market = markets.find(m => String(m.id) === String(marketId));
          if (market) {
            openTradeModal(market, outcomeIndex);
          }
        });
      });
      
      // Add click handlers for event price buttons - open detail view
      list.querySelectorAll('.event-price-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.stopPropagation();
          hapticFeedback('light');
          const marketId = btn.dataset.marketId;
          const market = markets.find(m => String(m.id) === String(marketId));
          if (market) {
            openMarketDetail(market);
          }
        });
      });
      
      // Add click handlers for market cards - open detail view
      list.querySelectorAll('.market-card, .market-outcome-item').forEach(item => {
        item.addEventListener('click', (e) => {
          // Don't open detail if clicking on outcome buttons
          if (e.target.closest('.outcome-btn')) {
            return;
          }
          hapticFeedback('light');
          const marketId = item.dataset.id || item.dataset.marketId;
          const market = markets.find(m => String(m.id) === String(marketId));
          if (market) {
            openMarketDetail(market);
          }
        });
      });
      
      // Add click handlers for event header collapse/expand
      list.querySelectorAll('.event-header').forEach(header => {
        header.addEventListener('click', (e) => {
          // Don't collapse if clicking on interactive elements
          if (e.target.closest('.outcome-btn') || e.target.closest('.event-price-btn') || e.target.closest('button') || e.target.closest('a')) {
            return;
          }
          
          hapticFeedback('light');
          const eventId = header.dataset.collapseTarget;
          const eventGroup = header.closest('.event-group');
          
          if (eventGroup) {
            eventGroup.classList.toggle('collapsed');
            header.classList.toggle('collapsed');
          }
        });
      });
      
      // Prevent nested market clicks from collapsing
      list.querySelectorAll('.event-markets .market-outcome-item').forEach(item => {
        item.addEventListener('click', (e) => {
          e.stopPropagation();
        });
      });

      // Add click handlers for outcome buttons
      list.querySelectorAll('.outcome-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.stopPropagation();
          hapticFeedback('light');
          const marketId = btn.dataset.marketId;
          const outcomeIndex = parseInt(btn.dataset.outcomeIndex);
          const market = markets.find(m => String(m.id) === marketId || String(m.conditionId) === marketId);
          if (market) {
            state.selectedOutcomeIndex = outcomeIndex;
            openTradeModal(market);
          }
        });
      });

      // Add click handlers for market cards (fallback)
      list.querySelectorAll('.market-card, .market-item').forEach(item => {
        item.addEventListener('click', (e) => {
          if (!e.target.closest('.outcome-btn')) {
            hapticFeedback('light');
            const itemId = String(item.dataset.id);
            const market = markets.find(m => String(m.id) === itemId || String(m.conditionId) === itemId);
          if (market) openTradeModal(market);
          }
        });
      });
    }

    // =====================
    // TRADE MODAL
    // =====================
    function openMarketDetail(market) {
      hapticFeedback('medium');
      state.selectedMarket = market;
      
      // Hide main app, show detail view
      document.getElementById('appShell').style.display = 'none';
      document.getElementById('marketDetailView').style.display = 'block';
      
      // Populate detail view
      const title = document.getElementById('marketDetailTitle');
      title.textContent = market.question || market.eventTitle || 'Market Details';
      
      const volume = document.getElementById('marketDetailVolume');
      const vol = market.volume24hr || market.volume || 0;
      volume.textContent = `$${formatVolume(vol)} Vol.`;
      
      const event = document.getElementById('marketDetailEvent');
      if (market.eventTitle) {
        event.innerHTML = `
          ${market.eventImage ? `<img src="${market.eventImage}" alt="" />` : ''}
          <span>${market.eventTitle}</span>
        `;
      } else {
        event.innerHTML = '';
      }
      
      // Render outcomes list
      const outcomesList = document.getElementById('marketDetailOutcomesList');
      const outcomes = market.outcomes || ["Yes", "No"];
      const prices = market.outcomePrices || [];
      
      // Get market color for dynamic theming
      const marketColor = getMarketColor(market);
      const marketDetailView = document.getElementById('marketDetailView');
      if (marketDetailView) {
        marketDetailView.style.setProperty('--market-color', marketColor);
      }
      
      // Use market color with variations for different outcomes
      const baseColor = marketColor;
      // Convert HSL to RGB for manipulation (simplified - using the market color directly)
      const colors = [baseColor, baseColor]; // Use same color for now, can add variations later
      
      outcomesList.innerHTML = outcomes.map((outcome, index) => {
        const price = prices[index] !== undefined ? parseFloat(prices[index]) : 0.5;
        const percent = (price * 100).toFixed(1);
        const color = colors[index % colors.length];
        const isSelected = index === 0;
        
        return `
          <div class="outcome-item ${isSelected ? 'selected' : ''}" 
               data-outcome-index="${index}"
               data-outcome="${outcome}">
            <div class="outcome-dot ${color}"></div>
            <div class="outcome-label">${outcome}</div>
            <div class="outcome-percent">${percent}%</div>
          </div>
        `;
      }).join('');
      
      // Add click handlers for outcomes
      outcomesList.querySelectorAll('.outcome-item').forEach(item => {
        item.addEventListener('click', () => {
          outcomesList.querySelectorAll('.outcome-item').forEach(i => i.classList.remove('selected'));
          item.classList.add('selected');
          updateMarketDetailSelectedOutcome(market, parseInt(item.dataset.outcomeIndex));
        });
      });
      
      // Set default selected outcome
      if (outcomes.length > 0) {
        updateMarketDetailSelectedOutcome(market, 0);
      }
      
      // Initialize graph
      initializeMarketGraph(market);
      
      // Setup buy buttons
      setupMarketDetailBuyButtons(market);
    }
    
    function updateMarketDetailSelectedOutcome(market, outcomeIndex) {
      const outcomes = market.outcomes || ["Yes", "No"];
      const prices = market.outcomePrices || [];
      const outcome = outcomes[outcomeIndex] || 'Yes';
      const price = prices[outcomeIndex] !== undefined ? parseFloat(prices[outcomeIndex]) : 0.5;
      const percent = (price * 100).toFixed(1);
      
      document.getElementById('selectedOutcomeName').textContent = outcome;
      document.getElementById('selectedOutcomePercent').textContent = `${percent}%`;
      document.getElementById('selectedOutcomeVolume').textContent = '$0 Vol.'; // TODO: Get actual volume for this outcome
    }
    
    function initializeMarketGraph(market) {
      const canvas = document.getElementById('marketDetailGraph');
      if (!canvas) return;
      
      const ctx = canvas.getContext('2d');
      const outcomes = market.outcomes || ["Yes", "No"];
      const prices = market.outcomePrices || [];
      
      // Set canvas size based on container
      const container = canvas.parentElement;
      canvas.width = container.clientWidth - 32; // Account for padding
      canvas.height = 200;
      
      let currentRange = 'ALL';
      let historicalData = null;
      
      // Fetch historical data from API
      async function fetchHistoricalData(range = 'ALL') {
        try {
          const marketId = market.id || market.conditionId;
          if (!marketId) {
            console.log("[market-detail] No market ID, using mock data");
            return null;
          }
          
          const resp = await fetch(`/api/market-history?marketId=${marketId}&range=${range}`);
          if (resp.ok) {
            const data = await resp.json();
            // Store current prices from API response for graph
            if (data.currentPrices && Array.isArray(data.currentPrices)) {
              // Update prices array to match API response
              data.currentPrices.forEach((price, idx) => {
                if (prices[idx] !== undefined) {
                  prices[idx] = price;
                }
              });
            }
            return data.history || null;
          } else {
            console.log("[market-detail] Historical data API failed, using mock data");
            return null;
          }
        } catch (err) {
          console.log("[market-detail] Error fetching historical data:", err);
          return null;
        }
      }
      
      function drawGraph(range = 'ALL', historyData = null) {
        const width = canvas.width;
        const height = canvas.height;
        
        // Resize canvas if needed
        if (canvas.width !== container.clientWidth - 32) {
          canvas.width = container.clientWidth - 32;
        }
        
        ctx.clearRect(0, 0, width, height);
        
        // Get current market prices (these are the "now" values)
        const currentPrices = prices.map(p => parseFloat(p) || 0);
        
        // Draw grid
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
        ctx.lineWidth = 1;
        for (let i = 0; i <= 10; i++) {
          const y = (height / 10) * i;
          ctx.beginPath();
          ctx.moveTo(0, y);
          ctx.lineTo(width, y);
          ctx.stroke();
        }
        
        // Draw Y-axis labels (percentages)
        ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
        ctx.font = '10px sans-serif';
        for (let i = 0; i <= 10; i++) {
          const percent = 100 - (i * 10);
          const y = (height / 10) * i;
          ctx.fillText(`${percent}%`, 4, y + 4);
        }
        
        // Draw lines for each outcome (using new color scheme)
        const colors = ['#687E90', '#4B4B4B', '#5b5b5b', '#6b6b6b', '#7b7b7b', '#8b8b8b'];
        
        if (historyData && historyData.length > 0) {
          // Use real historical data from API
          historyData.forEach((outcomeHistory, index) => {
            const color = colors[index % colors.length];
            const dataPoints = outcomeHistory.data || [];
            const currentPrice = currentPrices[index] || 0;
            
            if (dataPoints.length === 0) {
              // No history, draw flat line at current price
              const y = height - (currentPrice * height);
              ctx.strokeStyle = color;
              ctx.lineWidth = 2;
              ctx.beginPath();
              ctx.moveTo(0, y);
              ctx.lineTo(width, y);
              ctx.stroke();
              return;
            }
            
            // Find min/max timestamps for scaling
            const timestamps = dataPoints.map(p => p.timestamp);
            const minTime = Math.min(...timestamps);
            const maxTime = Math.max(...timestamps);
            const timeRange = maxTime - minTime || 1; // Avoid division by zero
            
            // Ensure the graph ends at current price (rightmost point)
            const now = Date.now();
            const historicalPoints = [...dataPoints];
            
            // Add current price as the final point (rightmost)
            historicalPoints.push({
              timestamp: now,
              price: currentPrice,
              volume: 0,
              liquidity: 0
            });
            
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            historicalPoints.forEach((point, i) => {
              // Scale X: 0 to width, with current time at the right edge
              const x = timeRange > 0 
                ? ((point.timestamp - minTime) / (now - minTime)) * width
                : width; // If no time range, put at end
              
              // Scale Y: price (0-1) to canvas height (0 at top, 100% at bottom)
              const y = height - (point.price * height);
              
              // Clamp to canvas bounds
              const clampedX = Math.max(0, Math.min(width, x));
              const clampedY = Math.max(0, Math.min(height, y));
              
              if (i === 0) {
                ctx.moveTo(clampedX, clampedY);
              } else {
                ctx.lineTo(clampedX, clampedY);
              }
            });
            
            ctx.stroke();
            
            // Draw current price indicator (rightmost point)
            const currentY = height - (currentPrice * height);
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(width, currentY, 4, 0, Math.PI * 2);
            ctx.fill();
          });
        } else {
          // Fallback: Draw lines that end at current market prices
          outcomes.forEach((outcome, index) => {
            const color = colors[index % colors.length];
            const currentPrice = currentPrices[index] || 0.5;
            
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            const points = 100;
            for (let i = 0; i < points; i++) {
              const x = (width / points) * i;
              // Simulate price movement that trends toward current price
              const progress = i / points;
              // Start from a reasonable baseline (around 0.5 or opposite of current)
              const startPrice = index === 0 ? 0.5 : (1 - currentPrice);
              // Interpolate from start to current price
              const price = startPrice + (currentPrice - startPrice) * progress;
              // Add some realistic variation
              const variation = (Math.sin(i / 10) * 0.05) * (1 - progress); // Less variation near end
              const finalPrice = Math.max(0.01, Math.min(0.99, price + variation));
              const y = height - (finalPrice * height);
              
              if (i === 0) {
                ctx.moveTo(x, y);
              } else {
                ctx.lineTo(x, y);
              }
            }
            
            ctx.stroke();
            
            // Draw current price indicator (rightmost point)
            const currentY = height - (currentPrice * height);
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(width, currentY, 4, 0, Math.PI * 2);
            ctx.fill();
          });
        }
        
        // Draw current price labels on right side
        ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
        ctx.font = '11px sans-serif';
        ctx.textAlign = 'right';
        outcomes.forEach((outcome, index) => {
          const currentPrice = currentPrices[index] || 0;
          const percent = (currentPrice * 100).toFixed(0);
          const y = height - (currentPrice * height);
          // Offset label slightly above/below the point
          const labelY = index % 2 === 0 ? y - 8 : y + 16;
          ctx.fillText(`${percent}%`, width - 4, labelY);
        });
        ctx.textAlign = 'left'; // Reset alignment
      }
      
      // Time range selector handlers
      document.querySelectorAll('.time-selector').forEach(btn => {
        btn.addEventListener('click', async () => {
          document.querySelectorAll('.time-selector').forEach(b => b.classList.remove('active'));
          btn.classList.add('active');
          currentRange = btn.dataset.range;
          
          // Fetch new historical data for selected range
          historicalData = await fetchHistoricalData(currentRange);
          drawGraph(currentRange, historicalData);
        });
      });
      
      // Initial load
      (async () => {
        historicalData = await fetchHistoricalData(currentRange);
        drawGraph(currentRange, historicalData);
      })();
    }
    
    function setupMarketDetailBuyButtons(market) {
      const outcomes = market.outcomes || ["Yes", "No"];
      const prices = market.outcomePrices || [];
      
      // Setup Yes button (first outcome)
      const buyYesBtn = document.getElementById('marketDetailBuyYes');
      const yesIndex = 0;
      const yesPrice = prices[yesIndex] !== undefined ? (parseFloat(prices[yesIndex]) * 100).toFixed(0) : '50';
      const yesOutcome = outcomes[yesIndex] || 'Yes';
      document.getElementById('buyYesOutcome').textContent = yesOutcome;
      document.getElementById('buyYesPrice').textContent = `${yesPrice}¢`;
      
      // Apply team-specific color to Yes button
      const yesColor = getOutcomeColor(market, yesOutcome, yesIndex);
      buyYesBtn.style.background = yesColor;
      buyYesBtn.style.borderColor = yesColor;
      
      buyYesBtn.addEventListener('click', () => {
        hapticFeedback('medium');
        state.selectedOutcomeIndex = yesIndex;
        state.tradeSide = yesOutcome;
        closeMarketDetail();
        openTradeModal(market);
      });
      
      // Setup No button (second outcome if exists, otherwise opposite)
      const buyNoBtn = document.getElementById('marketDetailBuyNo');
      const noIndex = outcomes.length > 1 ? 1 : 0;
      const noPrice = prices[noIndex] !== undefined ? (parseFloat(prices[noIndex]) * 100).toFixed(0) : '50';
      const noOutcome = outcomes[noIndex] || 'No';
      document.getElementById('buyNoOutcome').textContent = noOutcome;
      document.getElementById('buyNoPrice').textContent = `${noPrice}¢`;
      
      // Apply team-specific color to No button
      const noColor = getOutcomeColor(market, noOutcome, noIndex);
      buyNoBtn.style.background = noColor;
      buyNoBtn.style.borderColor = noColor;
      
      buyNoBtn.addEventListener('click', () => {
        hapticFeedback('medium');
        state.selectedOutcomeIndex = noIndex;
        state.tradeSide = noOutcome;
        closeMarketDetail();
        openTradeModal(market);
      });
    }
    
    function closeMarketDetail() {
      document.getElementById('marketDetailView').style.display = 'none';
      document.getElementById('appShell').style.display = 'block';
    }
    
    // Back button handler
    document.getElementById('marketDetailBack')?.addEventListener('click', () => {
      hapticFeedback('light');
      closeMarketDetail();
    });
    
    // Share button handler
    document.getElementById('marketDetailShare')?.addEventListener('click', () => {
      hapticFeedback('light');
      if (navigator.share && state.selectedMarket) {
        navigator.share({
          title: state.selectedMarket.question,
          text: `Check out this market on Polygram`,
          url: window.location.href
        }).catch(() => {
          // Fallback: copy to clipboard
          navigator.clipboard.writeText(window.location.href);
        });
      } else {
        navigator.clipboard.writeText(window.location.href);
      }
    });
    
    // Bookmark button handler
    document.getElementById('marketDetailBookmark')?.addEventListener('click', () => {
      hapticFeedback('light');
      // TODO: Implement bookmark functionality
      const btn = document.getElementById('marketDetailBookmark');
      btn.classList.toggle('bookmarked');
    });

    function openTradeModal(market, outcomeIndex) {
      hapticFeedback('medium');
      state.selectedMarket = market;
      
      // Use provided outcomeIndex or default
      if (outcomeIndex !== undefined) {
        state.selectedOutcomeIndex = outcomeIndex;
      }

      // Get market color (dynamic based on market data)
      const marketColor = getMarketColor(market);
      
      // Apply market color to modal via CSS custom property
      const tradeModal = document.getElementById('tradeModal');
      if (tradeModal) {
        tradeModal.style.setProperty('--market-color', marketColor);
      }

      // Get all outcomes and prices
      const outcomes = market.outcomes || ["Yes", "No"];
      const prices = market.outcomePrices || [];
      
      // Set market image and question
      const marketImg = document.getElementById('tradeMarketImg');
      const imgUrl = market.image || market.icon || '';
      if (imgUrl) {
        marketImg.src = imgUrl;
        marketImg.style.display = 'block';
      } else {
        marketImg.style.display = 'none';
      }
      document.getElementById('tradeMarketQuestion').textContent = market.question;
      
      // Render all outcomes with percentages
      const outcomesContainer = document.getElementById('tradeOutcomes');
      const defaultIndex = outcomeIndex !== undefined ? outcomeIndex : 0;
      outcomesContainer.innerHTML = outcomes.map((outcome, index) => {
        // Use 0.5 as fallback to match updateTradeSummary logic
        const price = prices[index] ? parseFloat(prices[index]) : 0.5;
        const percent = (price * 100).toFixed(0);
        const priceCents = (price * 100).toFixed(0);
        const isActive = index === defaultIndex;
        
        // Get team-specific color for this outcome
        const outcomeColor = getOutcomeColor(market, outcome, index);
        const buttonStyle = !isActive ? `style="background: ${outcomeColor}; color: white;"` : '';
        
        return `
          <div class="trade-outcome ${isActive ? 'active' : ''}" 
               data-outcome-index="${index}" 
               data-outcome="${outcome}"
               data-outcome-color="${outcomeColor}"
               ${buttonStyle}>
            <div class="trade-outcome-left">
              <div class="trade-outcome-label">${outcome}</div>
              <div class="trade-outcome-percent">${percent}%</div>
            </div>
            <div class="trade-outcome-price">${priceCents}¢</div>
          </div>
        `;
      }).join('');
      
      // Set default selected outcome
      if (outcomes.length > 0) {
        state.tradeSide = outcomes[0];
        state.selectedOutcomeIndex = 0;
      }
      
      // Add click handlers for outcomes
      outcomesContainer.querySelectorAll('.trade-outcome').forEach(outcomeEl => {
        outcomeEl.addEventListener('click', () => {
          // Remove active from all and restore team colors
          outcomesContainer.querySelectorAll('.trade-outcome').forEach(o => {
            o.classList.remove('active');
            // Restore team-specific color from data attribute
            const outcomeColor = o.dataset.outcomeColor || 'var(--market-color, #003366)';
            o.style.background = outcomeColor;
          });
          // Add active to clicked (black background)
          outcomeEl.classList.add('active');
          outcomeEl.style.background = '#000000';
          
          state.selectedOutcomeIndex = parseInt(outcomeEl.dataset.outcomeIndex);
          state.tradeSide = outcomeEl.dataset.outcome;
          
          updateTradeSummary();
        });
      });
      
      document.getElementById('tradeAmount').value = '';
      updateTradeSummary();
      
      document.getElementById('tradeModal').classList.add('visible');
    }

    function closeTradeModal() {
      hapticFeedback('light');
      document.getElementById('tradeModal').classList.remove('visible');
      state.selectedMarket = null;
    }

    function updateTradeSummary() {
      const amount = parseFloat(document.getElementById('tradeAmount').value) || 0;
      const prices = state.selectedMarket?.outcomePrices || [];
      const priceIdx = state.selectedOutcomeIndex !== undefined 
        ? state.selectedOutcomeIndex 
        : (state.tradeSide === 'yes' ? 0 : 1);
      const price = prices[priceIdx] ? parseFloat(prices[priceIdx]) : 0.5;
      const outcomeLabel = state.selectedMarket?.outcomes?.[priceIdx] || state.tradeSide || 'Yes';
      
      const shares = price > 0 ? (amount / price).toFixed(2) : 0;
      const potential = (shares * 1).toFixed(2);
      
      document.getElementById('tradeShares').textContent = shares;
      document.getElementById('tradeAvgPrice').textContent = `${(price * 100).toFixed(0)}¢`;
      document.getElementById('tradePotential').textContent = `$${potential}`;
      
      const btn = document.getElementById('tradeSubmit');
      if (state.wallet && amount > 0) {
        btn.disabled = false;
        btn.textContent = `Buy ${outcomeLabel} · $${amount.toFixed(2)}`;
      } else if (!state.wallet) {
        btn.disabled = true;
        btn.textContent = 'Create Wallet First';
      } else {
        btn.disabled = true;
        btn.textContent = 'Enter Amount';
      }
    }

    // =====================
    // FUNDING
    // =====================
    let currentFundingCurrency = 'usdc';

    function openFundModal(currency = 'usdc') {
      hapticFeedback('medium');
      currentFundingCurrency = currency;
      const modal = document.getElementById('fundModal');
      const title = document.getElementById('fundModalTitle');
      const subtitle = document.getElementById('fundModalSubtitle');
      const addressEl = document.getElementById('fundAddress');
      const networkEl = document.getElementById('fundNetwork');
      const minimumEl = document.getElementById('fundMinimum');
      const instructionsEl = document.getElementById('fundInstructions');

      // Update currency buttons
      document.querySelectorAll('.currency-btn').forEach(btn => {
        btn.classList.remove('active');
        if (btn.dataset.currency === currency) {
          btn.classList.add('active');
        }
      });

      if (!state.wallet) {
        alert('Please create a wallet first');
        return;
      }

      const walletAddress = currency === 'usdc' ? state.wallet.polygon : state.wallet.solana;
      addressEl.textContent = walletAddress;

      if (currency === 'usdc') {
        title.textContent = 'Fund USDC Wallet';
        subtitle.textContent = 'Send USDC to your Polygon wallet';
        networkEl.textContent = 'Polygon';
        minimumEl.textContent = '$10.00';
        instructionsEl.innerHTML = '<p>Send USDC (Polygon network) to the address above. Minimum deposit: $10. Make sure you\'re sending on the Polygon network, not Ethereum.</p>';
      } else {
        title.textContent = 'Fund SOL Wallet';
        subtitle.textContent = 'Send SOL to your Solana wallet';
        networkEl.textContent = 'Solana';
        minimumEl.textContent = '0.1 SOL';
        instructionsEl.innerHTML = '<p>Send SOL to the address above. Minimum deposit: 0.1 SOL. Make sure you\'re sending on the Solana network.</p>';
      }

      document.getElementById('fundAmount').value = '';
      modal.classList.add('visible');
    }

    function closeFundModal() {
      hapticFeedback('light');
      document.getElementById('fundModal').classList.remove('visible');
    }

    async function submitFunding() {
      const amount = parseFloat(document.getElementById('fundAmount').value);
      const currency = currentFundingCurrency;

      if (!amount || amount <= 0) {
        hapticFeedback('error');
        alert('Please enter a valid amount');
        return;
      }

      const minAmount = currency === 'usdc' ? 10 : 0.1;
      if (amount < minAmount) {
        hapticFeedback('error');
        alert(`Minimum deposit is ${currency === 'usdc' ? '$' : ''}${minAmount}${currency === 'sol' ? ' SOL' : ''}`);
        return;
      }

      const submitBtn = document.getElementById('fundSubmitBtn');
      const originalText = submitBtn.textContent;
      submitBtn.disabled = true;
      submitBtn.textContent = 'Processing...';
      hapticFeedback('medium');

      try {
        const walletAddress = currency === 'usdc' ? state.wallet.polygon : state.wallet.solana;

        const resp = await fetch('/api/fund', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            telegram_id: state.telegramId,
            currency: currency,
            amount: amount,
            payment_method: 'crypto',
            wallet_address: walletAddress
          })
        });

        const data = await resp.json();

        if (!resp.ok) {
          throw new Error(data.message || data.error || 'Funding failed');
        }

        if (data.success) {
          hapticFeedback('success');
          alert(`Funding instructions:\n\n${data.instructions}\n\nYour balance will update once the transaction is confirmed on-chain.`);
          closeFundModal();
          // Refresh balance after a delay
          setTimeout(() => loadBalance(), 2000);
        } else {
          throw new Error(data.message || 'Funding failed');
        }

      } catch (err) {
        console.error('[submitFunding] Error:', err);
        hapticFeedback('error');
        alert(`Funding failed: ${err.message}`);
      } finally {
        submitBtn.disabled = false;
        submitBtn.textContent = originalText;
      }
    }

    // =====================
    // POSITIONS & PAYOUTS
    // =====================
    async function loadPositions() {
      // In production, fetch from API
      // For now, show empty or mock positions
      const positionsCard = document.getElementById('positionsCard');
      const positionsList = document.getElementById('positionsList');

      try {
        // In production: const resp = await fetch(`/api/positions?telegram_id=${state.telegramId}`);
        // For now, show empty
        positionsList.innerHTML = '<div class="loading" style="padding: 10px;">No active positions</div>';
        positionsCard.style.display = 'none';
      } catch (err) {
        console.error('[loadPositions] Error:', err);
      }
    }

    async function loadPayouts() {
      try {
        const resp = await fetch(`/api/payout?telegram_id=${encodeURIComponent(state.telegramId)}`);
        if (resp.ok) {
          const data = await resp.json();
          if (data.success && data.pending_payouts && data.pending_payouts.length > 0) {
            // Show payout modal or notification
            openPayoutModal(data.pending_payouts);
          }
        }
      } catch (err) {
        console.error('[loadPayouts] Error:', err);
      }
    }

    function openPayoutModal(payouts) {
      const modal = document.getElementById('payoutModal');
      const list = document.getElementById('payoutList');

      if (!payouts || payouts.length === 0) {
        list.innerHTML = '<div class="loading" style="padding: 10px;">No pending payouts</div>';
        return;
      }

      list.innerHTML = payouts.map(payout => `
        <div class="payout-item">
          <div class="payout-header">
            <div>
              <div class="position-question">${payout.market_question || 'Winning Position'}</div>
              <div style="font-size: 11px; color: var(--text-muted); margin-top: 4px;">
                Position ID: ${payout.position_id}
              </div>
            </div>
            <div class="payout-amount">$${payout.amount.toFixed(2)}</div>
          </div>
          <button class="payout-btn" 
                  data-position-id="${payout.position_id}"
                  data-amount="${payout.amount}">
            Claim Payout
          </button>
        </div>
      `).join('');

      // Add click handlers
      list.querySelectorAll('.payout-btn').forEach(btn => {
        btn.addEventListener('click', async () => {
          await claimPayout(btn.dataset.positionId, parseFloat(btn.dataset.amount));
        });
      });

      modal.classList.add('visible');
    }

    function closePayoutModal() {
      hapticFeedback('light');
      document.getElementById('payoutModal').classList.remove('visible');
    }

    async function claimPayout(positionId, amount) {
      hapticFeedback('medium');

      try {
        const resp = await fetch('/api/payout', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            telegram_id: state.telegramId,
            position_id: positionId,
            amount: amount,
            wallet_address: state.wallet.polygon
          })
        });

        const data = await resp.json();

        if (!resp.ok) {
          throw new Error(data.message || data.error || 'Payout failed');
        }

        if (data.success) {
          hapticFeedback('success');
          alert(`Payout initiated!\n\nAmount: $${amount.toFixed(2)}\n\n${data.message || 'Funds will arrive in your wallet shortly.'}`);
          closePayoutModal();
          await loadBalance();
        } else {
          throw new Error(data.message || 'Payout failed');
        }

      } catch (err) {
        console.error('[claimPayout] Error:', err);
        hapticFeedback('error');
        alert(`Payout failed: ${err.message}`);
      }
    }

    // =====================
    // TRADE EXECUTION
    // =====================
    async function executeTrade() {
      if (!state.selectedMarket) {
        hapticFeedback('error');
        alert('No market selected');
        return;
      }

      if (!state.wallet) {
        hapticFeedback('error');
        alert('Please create a wallet first');
        return;
      }

      const amountInput = document.getElementById('tradeAmount');
      const amount = parseFloat(amountInput.value);
      
      if (!amount || amount <= 0) {
        hapticFeedback('error');
        alert('Please enter a valid amount');
        return;
      }

      const submitBtn = document.getElementById('tradeSubmit');
      const originalText = submitBtn.textContent;
      
      // Disable button and show loading
      submitBtn.disabled = true;
      submitBtn.textContent = 'Processing...';
      hapticFeedback('medium');

      try {
        const market = state.selectedMarket;
        const side = state.tradeSide;
        const outcomeIndex = state.selectedOutcomeIndex || 0;
        
        // Get market ID (could be id, conditionId, or condition_id)
        const marketId = market.id || market.conditionId || market.condition_id;
        
        if (!marketId) {
          throw new Error('Market ID not found');
        }

        console.log('[executeTrade] Executing trade:', {
          marketId,
          side,
          amount,
          outcomeIndex,
          wallet: state.wallet.polygon
        });

        // Call trade API
        const resp = await fetch('/api/trade', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            telegram_id: state.telegramId,
            market_id: marketId,
            condition_id: marketId,
            outcome_index: outcomeIndex,
            side: side,
            amount: amount,
            wallet_address: state.wallet.polygon
          })
        });

        const data = await resp.json();

        if (!resp.ok) {
          throw new Error(data.message || data.error || 'Trade failed');
        }

        if (data.success) {
          hapticFeedback('success');
          
          // Show success message
          const successMsg = `Trade executed!\n\n` +
            `Market: ${market.question.substring(0, 50)}...\n` +
            `Side: ${side.toUpperCase()}\n` +
            `Amount: $${amount.toFixed(2)}\n` +
            `Shares: ${data.shares.toFixed(2)}\n` +
            `Trade ID: ${data.trade_id}`;
          
          alert(successMsg);
          
          // Close modal
          closeTradeModal();
          
          // Reload balance
          await loadBalance();
          
          // Optionally refresh markets to show updated prices
          // fetchMarkets(state.selectedCategory, state.selectedSportType);
        } else {
          throw new Error(data.message || 'Trade failed');
        }

      } catch (err) {
        console.error('[executeTrade] Error:', err);
        hapticFeedback('error');
        alert(`Trade failed: ${err.message}`);
      } finally {
        // Re-enable button
        submitBtn.disabled = false;
        submitBtn.textContent = originalText;
      }
    }

    // =====================
    // INIT
    // =====================
    function initModeChips() {
      // Legacy support for old mode-chips if they exist
      document.querySelectorAll('.mode-chip[data-kind]').forEach(chip => {
        chip.addEventListener('click', () => {
          document.querySelectorAll('.mode-chip').forEach(c => c.classList.remove('active'));
          chip.classList.add('active');
          fetchMarkets(chip.dataset.kind);
        });
      });
    }

    async function initCategories() {
      const categories = await fetchCategories();
      if (categories.length > 0) {
        renderCategories(categories);
        // Set default to first category (usually "trending")
        if (!state.selectedCategory && categories.length > 0) {
          state.selectedCategory = categories[0].slug;
          fetchMarkets(categories[0].slug);
        }
      } else {
        // Fallback to default categories if API fails
        const fallbackCategories = [
          { slug: 'trending', label: 'Trending', icon: '' },
          { slug: 'volume', label: 'Volume', icon: '' },
          { slug: 'new', label: 'New', icon: '' },
          { slug: 'sports', label: 'Sports', icon: '' },
        ];
        renderCategories(fallbackCategories);
        state.selectedCategory = 'trending';
        fetchMarkets('trending');
      }
    }

    function initTradeModal() {
      // Close on backdrop click
      document.getElementById('tradeModal').addEventListener('click', (e) => {
        if (e.target.id === 'tradeModal') closeTradeModal();
      });

      // Amount input
      document.getElementById('tradeAmount').addEventListener('input', updateTradeSummary);

      // Submit
      document.getElementById('tradeSubmit').addEventListener('click', async () => {
        await executeTrade();
      });
    }

    function initPlatformSelector() {
      // Handle platform selector clicks
      document.querySelectorAll('.platform-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          const platform = btn.dataset.platform;
          if (platform === state.selectedPlatform) return; // Already selected
          
          hapticFeedback('light');
          
          // Update active state
          document.querySelectorAll('.platform-btn').forEach(b => b.classList.remove('active'));
          btn.classList.add('active');
          
          // Update state
          state.selectedPlatform = platform;
          
          console.log('[platform] Switched to:', platform);
          
          // Reload markets with new platform
          // Keep current category/sportType selection
          fetchMarkets(state.selectedCategory || 'trending', state.selectedSportType);
        });
      });
    }

    function initFundModal() {
      // Close on backdrop click
      document.getElementById('fundModal').addEventListener('click', (e) => {
        if (e.target.id === 'fundModal') closeFundModal();
      });

      // Close button
      document.getElementById('closeFundModal')?.addEventListener('click', () => {
        closeFundModal();
      });

      // Currency selector
      document.querySelectorAll('.currency-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          const currency = btn.dataset.currency;
          document.querySelectorAll('.currency-btn').forEach(b => b.classList.remove('active'));
          btn.classList.add('active');
          openFundModal(currency);
        });
      });

      // Copy fund address button
      document.getElementById('copyFundAddressBtn')?.addEventListener('click', async () => {
        const addressEl = document.getElementById('fundAddress');
        if (addressEl && addressEl.textContent) {
          await copyToClipboard(addressEl.textContent);
          const btn = document.getElementById('copyFundAddressBtn');
          btn.classList.add('copied');
          setTimeout(() => btn.classList.remove('copied'), 2000);
        }
      });

      // Submit button
      document.getElementById('fundSubmitBtn')?.addEventListener('click', async () => {
        await submitFunding();
      });

      // Payout modal close
      document.getElementById('closePayoutModal')?.addEventListener('click', () => {
        closePayoutModal();
      });

      // Payout modal backdrop
      document.getElementById('payoutModal')?.addEventListener('click', (e) => {
        if (e.target.id === 'payoutModal') closePayoutModal();
      });
    }

    async function bootstrapApp() {
      console.log('Bootstrapping app...');
      initTelegram();
      initPlatformSelector();
      initModeChips();
      initTradeModal();
      initFundModal();
      await initCategories();


      await loadWallet();
      // Markets will be fetched by initCategories()
      console.log('Bootstrap complete');
    }

    // =====================
    // START
    // =====================
    document.addEventListener('DOMContentLoaded', () => {
      initOnboarding();
      showSplash();

      setTimeout(() => {
        hideSplash();
        if (checkAccess()) {
          showMainApp();
        } else {
          showOnboarding();
        }
      }, 1500);
    });
  </script>
</body>
</html>

