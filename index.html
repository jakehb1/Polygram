<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Polygram Â· Trade Predictions</title>
  <script src="https://telegram.org/js/telegram-web-app.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/5.7.2/ethers.umd.min.js"></script>
  <!-- Load TON Connect UI with fallback CDN -->
  <script>
    (function() {
      function loadTONConnect() {
        return new Promise((resolve, reject) => {
          // Try unpkg first
          const script1 = document.createElement('script');
          script1.src = 'https://unpkg.com/@tonconnect/ui@2.3.1/dist/tonconnect-ui.min.js';
          script1.onload = () => {
            console.log('[TON Connect] Loaded from unpkg');
            resolve();
          };
          script1.onerror = () => {
            console.warn('[TON Connect] unpkg failed, trying jsdelivr...');
            // Try jsdelivr as fallback
            const script2 = document.createElement('script');
            script2.src = 'https://cdn.jsdelivr.net/npm/@tonconnect/ui@2.3.1/dist/tonconnect-ui.min.js';
            script2.onload = () => {
              console.log('[TON Connect] Loaded from jsdelivr');
              resolve();
            };
            script2.onerror = () => {
              console.error('[TON Connect] Failed to load from both CDNs');
              // Don't reject - allow app to continue without TON Connect
              resolve();
            };
            document.head.appendChild(script2);
          };
          document.head.appendChild(script1);
        });
      }
      
      // Load TON Connect UI
      loadTONConnect().then(() => {
        console.log('[TON Connect] Library loading complete');
      });
    })();
  </script>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;500;600;700;800&display=swap" rel="stylesheet">
  <style>
    @font-face {
      font-family: 'Benzin';
      src: url('https://fonts.cdnfonts.com/s/29189/Benzin-ExtraBold.woff') format('woff');
      font-weight: 800;
      font-style: normal;
    }
    
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    :root {
      --bg: #EAF5FB;
      --card: #d8edf8;
      --text: #687E90;
      --text-muted: #8a9ba8;
      --accent: #687E90;
      --accent-light: #4B4B4B;
      --accent-pink: #4B4B4B;
      --green: #4B4B4B;
      --green-soft: #6b6b6b;
      --red: #d97777;
      --border: #c5d9e8;
      --bg-secondary: #e0f0f8;
      --card-hover: #c8e0f0;
      --radius: 24px;
      --radius-sm: 16px;
      --shadow: none;
    }

    body {
      font-family: 'Montserrat', -apple-system, BlinkMacSystemFont, sans-serif;
      background: var(--bg);
      color: var(--text);
      min-height: 100vh;
      overflow-x: hidden;
      -webkit-font-smoothing: antialiased;
    }

    /* Splash Screen */
    .splash-screen {
      position: fixed;
      inset: 0;
      background: var(--bg);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 9999;
      transition: opacity 0.4s ease;
    }
    .splash-screen.hidden { opacity: 0; pointer-events: none; }
    
    .splash-logo {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 32px;
    }
    .splash-logo-icon {
      font-size: 32px;
    }
    .splash-logo-text {
      font-family: 'Montserrat', sans-serif;
      font-size: 42px;
      font-weight: 800;
      color: var(--text);
      letter-spacing: -0.02em;
    }
    
    .splash-spinner {
      width: 32px;
      height: 32px;
      border: 3px solid var(--border);
      border-top-color: var(--accent);
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    @keyframes spin { to { transform: rotate(360deg); } }

    /* Onboarding Screen */
    .onboarding-screen {
      position: fixed;
      inset: 0;
      background: var(--bg);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 9998;
      padding: 20px;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s ease;
    }
    .onboarding-screen.visible { opacity: 1; pointer-events: auto; }
    
    .onboarding-card {
      background: var(--card);
      border-radius: var(--radius);
      padding: 32px;
      max-width: 360px;
      width: 100%;
      text-align: center;
    }
    .onboarding-logo {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
      margin-bottom: 20px;
    }
    .onboarding-logo-icon {
      font-size: 24px;
    }
    .onboarding-logo-text {
      font-family: 'Montserrat', sans-serif;
      font-size: 28px;
      font-weight: 800;
      color: var(--text);
    }
    .onboarding-title {
      font-size: 20px;
      font-weight: 700;
      margin-bottom: 8px;
      color: var(--text);
    }
    .onboarding-subtitle {
      font-size: 14px;
      color: var(--text-muted);
      margin-bottom: 24px;
      line-height: 1.5;
    }
    
    .feature-list {
      text-align: left;
      margin-bottom: 24px;
    }
    .feature-item {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 12px;
      background: var(--bg);
      border-radius: var(--radius-sm);
      margin-bottom: 10px;
    }
    .feature-icon {
      width: 36px;
      height: 36px;
      border-radius: 10px;
      background: var(--accent);
      color: white;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
      flex-shrink: 0;
    }
    .feature-text {
      font-size: 13px;
      color: var(--text);
      line-height: 1.4;
    }
    
    .passkey-input {
      width: 100%;
      padding: 14px;
      font-size: 15px;
      font-family: inherit;
      border: 2px solid var(--border);
      border-radius: var(--radius-sm);
      background: var(--bg);
      text-align: center;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      margin-bottom: 12px;
      transition: border-color 0.2s;
    }
    .passkey-input:focus {
      outline: none;
      border-color: var(--accent);
    }
    .passkey-input.error {
      border-color: var(--red);
      animation: shake 0.4s ease;
    }
    @keyframes shake {
      0%, 100% { transform: translateX(0); }
      25% { transform: translateX(-8px); }
      75% { transform: translateX(8px); }
    }
    
    .passkey-error {
      color: var(--red);
      font-size: 12px;
      margin-bottom: 12px;
      display: none;
    }
    .passkey-error.visible { display: block; }
    
    .passkey-btn {
      width: 100%;
      padding: 14px;
      font-size: 15px;
      font-weight: 600;
      font-family: inherit;
      background: var(--accent);
      color: white;
      border: none;
      border-radius: var(--radius-sm);
      cursor: pointer;
      transition: transform 0.2s, opacity 0.2s;
    }
    .passkey-btn:active { transform: scale(0.98); }
    .passkey-btn:disabled { opacity: 0.6; cursor: not-allowed; }
    
    .passkey-hint {
      margin-top: 16px;
      font-size: 12px;
      color: var(--text-muted);
    }
    .passkey-hint a {
      color: var(--accent);
      text-decoration: none;
    }

    /* Main App */
    .app-shell {
      padding: 20px 16px 100px;
      max-width: 480px;
      margin: 0 auto;
      opacity: 0;
      transition: opacity 0.3s ease;
    }
    .app-shell.visible { opacity: 1; }

    /* Header */
    .header {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 20px;
      padding: 8px 0;
    }
    .header-logo {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .header-logo-icon {
      font-size: 20px;
    }
    .header-logo-text {
      font-family: 'Montserrat', sans-serif;
      font-size: 26px;
      font-weight: 800;
      color: var(--text);
      letter-spacing: -0.02em;
    }

    /* Cards */
    .card {
      background: var(--card);
      border-radius: var(--radius);
      padding: 20px;
      margin-bottom: 16px;
    }
    .card-label {
      font-size: 11px;
      font-weight: 600;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.1em;
      margin-bottom: 6px;
    }

    /* Balance Card */
    .balance-card {
      position: relative;
    }
    .balance-top-bar {
      background: var(--green);
      height: 48px;
      border-radius: 30px;
      margin-bottom: 16px;
    }
    .balance-amount {
      font-size: 36px;
      font-weight: 700;
      margin-bottom: 8px;
      color: var(--text);
    }
    .balance-breakdown {
      background: var(--bg);
      padding: 14px 18px;
      border-radius: 30px;
      font-size: 13px;
      color: var(--text-muted);
      margin-bottom: 12px;
    }
    .balance-dot {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      background: var(--accent);
    }

    /* Wallet Card */
    .wallet-title {
      font-size: 16px;
      font-weight: 600;
      margin-bottom: 12px;
      color: var(--text);
    }
    .wallet-section {
      display: flex;
      flex-direction: column;
      gap: 12px;
      margin-bottom: 12px;
    }
    .wallet-row {
      background: var(--bg);
      border-radius: 16px;
      padding: 12px 16px;
    }
    .wallet-label {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 12px;
      font-weight: 600;
      color: var(--text-muted);
      margin-bottom: 6px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    .wallet-icon {
      font-size: 14px;
      font-weight: 700;
    }
    .wallet-address-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
    }
    .wallet-address {
      font-size: 13px;
      font-family: 'SF Mono', Monaco, monospace;
      color: var(--text);
      flex: 1;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      cursor: pointer;
      padding: 4px 8px;
      border-radius: 6px;
      transition: all 0.2s;
      user-select: all;
    }
    .wallet-address:hover {
      background: var(--bg);
    }
    .wallet-address:active {
      background: var(--card);
    }
    .copy-btn {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 6px 8px;
      cursor: pointer;
      color: var(--text-muted);
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s;
      flex-shrink: 0;
    }
    .copy-btn:hover {
      background: var(--green);
      color: var(--text);
      border-color: var(--green);
    }
    .copy-btn:active {
      transform: scale(0.95);
    }
    .copy-btn.copied {
      background: var(--green);
      color: var(--text);
      border-color: var(--green);
    }
    .wallet-status {
      background: var(--accent);
      color: white;
      height: 40px;
      border-radius: 30px;
      padding: 0 18px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 13px;
      margin-bottom: 12px;
    }
    .wallet-actions {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
      margin-top: 8px;
    }
    .wallet-action-btn {
      padding: 10px 16px;
      border-radius: var(--radius-sm);
      font-size: 13px;
      font-weight: 600;
      border: 1px solid var(--border);
      background: var(--bg);
      color: var(--text);
      cursor: pointer;
      transition: all 0.2s;
    }
    .wallet-action-btn:hover {
      background: var(--card);
    }
    .wallet-action-btn:active {
      transform: scale(0.98);
    }

    /* Fund Modal */
    .fund-info {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }
    .fund-currency-selector {
      display: flex;
      gap: 8px;
    }
    .currency-btn {
      flex: 1;
      padding: 10px;
      border-radius: var(--radius-sm);
      font-size: 14px;
      font-weight: 600;
      border: 1px solid var(--border);
      background: var(--bg);
      color: var(--text);
      cursor: pointer;
      transition: all 0.2s;
    }
    .currency-btn.active {
      background: var(--accent);
      color: white;
      border-color: var(--accent);
    }
    .fund-amount input {
      width: 100%;
      padding: 12px;
      border-radius: var(--radius-sm);
      border: 1px solid var(--border);
      background: var(--bg);
      font-size: 16px;
      font-weight: 600;
    }
    .fund-address-section {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .fund-address-section label {
      font-size: 12px;
      color: var(--text-muted);
      font-weight: 500;
    }
    .fund-address-display {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 12px;
      background: var(--bg);
      border-radius: var(--radius-sm);
      border: 1px solid var(--border);
    }
    .fund-address-display code {
      flex: 1;
      font-size: 12px;
      font-family: 'Courier New', monospace;
      word-break: break-all;
      color: var(--text);
    }
    .fund-instructions {
      padding: 12px;
      background: var(--bg);
      border-radius: var(--radius-sm);
      font-size: 13px;
      color: var(--text-muted);
      line-height: 1.5;
    }
    .fund-summary {
      display: flex;
      flex-direction: column;
      gap: 8px;
      padding: 12px;
      background: var(--bg);
      border-radius: var(--radius-sm);
    }
    .fund-summary-row {
      display: flex;
      justify-content: space-between;
      font-size: 13px;
    }
    .fund-summary-row span:first-child {
      color: var(--text-muted);
    }
    .fund-summary-row span:last-child {
      font-weight: 600;
      color: var(--text);
    }
    .modal-close-btn {
      width: 100%;
      padding: 12px;
      margin-top: 8px;
      border-radius: var(--radius-sm);
      border: 1px solid var(--border);
      background: var(--bg);
      color: var(--text);
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s;
    }
    .modal-close-btn:hover {
      background: var(--card);
    }

    /* Positions */
    .position-item {
      padding: 12px;
      background: var(--bg);
      border-radius: var(--radius-sm);
      margin-bottom: 8px;
      border: 1px solid var(--border);
    }
    .position-header {
      display: flex;
      justify-content: space-between;
      align-items: start;
      margin-bottom: 8px;
    }
    .position-question {
      font-size: 13px;
      font-weight: 500;
      color: var(--text);
      flex: 1;
    }
    .position-side {
      padding: 4px 8px;
      border-radius: 12px;
      font-size: 11px;
      font-weight: 600;
      text-transform: uppercase;
    }
    .position-side.yes {
      background: var(--green-soft);
      color: var(--text);
    }
    .position-side.no {
      background: var(--bg);
      color: var(--text-muted);
    }
    .position-details {
      display: flex;
      justify-content: space-between;
      font-size: 12px;
      color: var(--text-muted);
    }
    .position-value {
      font-weight: 600;
      color: var(--text);
    }
    .position-value.winning {
      color: var(--green);
    }
    .payout-item {
      padding: 12px;
      background: var(--bg);
      border-radius: var(--radius-sm);
      margin-bottom: 8px;
      border: 1px solid var(--border);
    }
    .payout-header {
      display: flex;
      justify-content: space-between;
      align-items: start;
      margin-bottom: 8px;
    }
    .payout-amount {
      font-size: 18px;
      font-weight: 700;
      color: var(--green);
    }
    .payout-btn {
      width: 100%;
      padding: 10px;
      margin-top: 8px;
      border-radius: var(--radius-sm);
      background: var(--green);
      color: white;
      font-size: 13px;
      font-weight: 600;
      border: none;
      cursor: pointer;
      transition: all 0.2s;
    }
    .payout-btn:hover {
      opacity: 0.9;
    }
    .payout-btn:active {
      transform: scale(0.98);
    }
    .payout-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    /* Legacy wallet actions (kept for compatibility) */
    .wallet-actions {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      margin-bottom: 10px;
    }
    .wallet-actions-bottom {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }
    .wallet-btn {
      padding: 16px;
      border-radius: 30px;
      font-size: 14px;
      font-weight: 600;
      font-family: inherit;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      transition: transform 0.2s;
      border: none;
    }
    .wallet-btn:active { transform: scale(0.98); }
    .wallet-btn.green {
      background: var(--green);
      color: var(--text);
    }
    .wallet-btn.dark {
      background: var(--accent);
      color: white;
    }

    /* Markets Card */
    .markets-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 16px;
    }
    .markets-title {
      font-size: 16px;
      font-weight: 600;
      color: var(--text);
    }
    
    /* Category Scroll Container */
    .category-scroll-container {
      position: relative;
      margin-bottom: 16px;
      overflow: hidden;
    }
    .category-scroll {
      display: flex;
      gap: 10px;
      overflow-x: auto;
      overflow-y: hidden;
      scroll-behavior: smooth;
      -webkit-overflow-scrolling: touch;
      padding: 4px 0;
      scrollbar-width: none; /* Firefox */
      -ms-overflow-style: none; /* IE/Edge */
    }
    .category-scroll::-webkit-scrollbar {
      display: none; /* Chrome/Safari */
    }
    .category-chip {
      padding: 10px 18px;
      border-radius: 30px;
      font-size: 13px;
      font-weight: 600;
      font-family: inherit;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      background: var(--accent);
      border: none;
      color: white;
      transition: all 0.2s;
      white-space: nowrap;
      flex-shrink: 0;
      min-height: 40px;
    }
    .category-chip:hover {
      opacity: 0.9;
    }
    .category-chip:active {
      transform: scale(0.95);
    }
    .category-chip.active {
      background: var(--green);
      color: var(--text);
    }
    
    /* Legacy mode-chips (keeping for backward compatibility) */
    .mode-chips {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      margin-bottom: 16px;
    }
    .mode-chip {
      padding: 14px 16px;
      border-radius: 30px;
      font-size: 13px;
      font-weight: 600;
      font-family: inherit;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      background: var(--accent);
      border: none;
      color: white;
      transition: all 0.2s;
    }
    .mode-chip.active {
      background: var(--green);
      color: var(--text);
    }
    
    .markets-list {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    /* Market Item */
    .market-item {
      display: flex;
      gap: 12px;
      padding: 14px;
      background: var(--bg);
      border-radius: var(--radius-sm);
      cursor: pointer;
      transition: transform 0.2s;
    }
    .market-item:active { transform: scale(0.99); }
    .market-image {
      width: 40px;
      height: 40px;
      border-radius: 8px;
      object-fit: cover;
      flex-shrink: 0;
      background: var(--bg-secondary);
    }
    .market-image.hidden {
      display: none;
    }
    .market-info {
      flex: 1;
      min-width: 0;
    }
    .market-question {
      font-size: 14px;
      font-weight: 500;
      line-height: 1.4;
      margin-bottom: 6px;
      color: var(--text);
      display: -webkit-box;
      -webkit-line-clamp: 2;
      line-clamp: 2;
      -webkit-box-orient: vertical;
      overflow: hidden;
    }
    .market-meta {
      display: flex;
      align-items: center;
      gap: 12px;
      font-size: 12px;
      color: var(--text-muted);
    }
    .market-odds {
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      gap: 4px;
    }
    .odds-yes {
      background: var(--green);
      color: var(--text);
      padding: 6px 12px;
      border-radius: 20px;
      font-size: 13px;
      font-weight: 600;
    }
    .odds-vol {
      font-size: 11px;
      color: var(--text-muted);
    }

    /* Event Grouping (for NFL games) */
    .event-group {
      background: var(--bg);
      border-radius: var(--radius-sm);
      margin-bottom: 12px;
      overflow: hidden;
    }
    .event-header {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 14px;
      border-bottom: 1px solid var(--border);
      cursor: pointer;
      user-select: none;
      transition: background 0.2s;
      flex-wrap: nowrap;
      overflow: hidden;
    }
    .event-header:hover {
      background: var(--card);
    }
    .event-header.collapsed {
      border-bottom: none;
    }
    .event-info {
      flex: 1;
      min-width: 0;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    .event-title {
      font-size: 15px;
      font-weight: 600;
      line-height: 1.4;
      color: var(--text);
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: nowrap;
      word-break: keep-all;
      overflow-wrap: normal;
      white-space: nowrap;
      overflow: hidden;
      min-width: 0;
    }
    .event-title-text {
      display: inline-block;
      word-break: keep-all;
      overflow-wrap: normal;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      flex: 1;
      min-width: 0;
    }
    .event-meta {
      display: flex;
      align-items: center;
      gap: 12px;
      font-size: 12px;
      color: var(--text-muted);
    }
    .event-primary-prices {
      display: flex;
      gap: 6px;
      flex-shrink: 0;
      margin-left: auto;
      margin-right: 8px;
    }
    .event-price-btn {
      padding: 6px 12px;
      border-radius: 8px;
      border: none;
      font-weight: 600;
      font-size: 12px;
      cursor: pointer;
      white-space: nowrap;
      transition: opacity 0.2s;
      flex-shrink: 0;
    }
    @media (max-width: 480px) {
      .event-primary-prices {
        flex-direction: column;
        gap: 4px;
      }
      .event-price-btn {
        padding: 4px 8px;
        font-size: 11px;
      }
      .event-title {
        font-size: 14px;
      }
      .event-header {
        padding: 12px;
        gap: 8px;
      }
      .event-image {
        width: 40px;
        height: 40px;
      }
    }
    .event-collapse-icon {
      font-size: 18px;
      color: var(--text-muted);
      transition: transform 0.2s;
      flex-shrink: 0;
      width: 24px;
      height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .event-header.collapsed .event-collapse-icon {
      transform: rotate(-90deg);
    }
    .event-price-btn:hover {
      opacity: 0.8;
    }
    .event-price-btn-1 {
      background: var(--accent);
      color: white;
    }
    .event-price-btn-2 {
      background: var(--bg-secondary);
      color: var(--text);
      border: 1px solid var(--border);
    }
    .event-markets {
      padding: 0;
      max-height: 2000px;
      overflow: hidden;
      transition: max-height 0.3s ease, padding 0.3s ease;
    }
    .event-group.collapsed .event-markets {
      max-height: 0;
      padding: 0;
    }
    .event-image {
      width: 48px;
      height: 48px;
      border-radius: 8px;
      object-fit: cover;
      flex-shrink: 0;
      background: var(--bg-secondary);
    }
    .event-image.hidden {
      display: none;
    }
    .week-tag {
      background: var(--bg-secondary);
      color: var(--text-muted);
      padding: 2px 8px;
      border-radius: 12px;
      font-size: 11px;
      font-weight: 500;
      text-transform: uppercase;
      flex-shrink: 0;
    }
    .event-markets {
      padding: 0;
    }
    .market-item.nested {
      border-radius: 0;
      border-bottom: 1px solid var(--border);
      margin: 0;
    }
    .market-item.nested:last-child {
      border-bottom: none;
    }
    .market-item.nested .market-question {
      font-size: 13px;
    }

    /* Market Card (New Design) */
    .market-card {
      background: var(--card);
      border-radius: var(--radius-sm);
      padding: 16px;
      margin-bottom: 12px;
      transition: all 0.2s ease;
      cursor: pointer;
    }
    .market-card:active {
      transform: scale(0.99);
    }
    .market-card-header {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 16px;
    }
    .market-card-header .market-image {
      width: 48px;
      height: 48px;
      border-radius: 8px;
      object-fit: cover;
      flex-shrink: 0;
      background: var(--bg);
    }
    .market-title {
      flex: 1;
      font-size: 16px;
      font-weight: 600;
      color: var(--text);
      line-height: 1.4;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      word-break: keep-all;
    }
    .market-outcomes {
      display: flex;
      flex-direction: column;
      gap: 10px;
      margin-bottom: 12px;
    }
    .market-outcome-item {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .outcome-label {
      font-size: 14px;
      color: var(--text-muted);
      margin-bottom: 4px;
    }
    .outcome-buttons {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }
    .outcome-button-group {
      display: flex;
      align-items: center;
      gap: 8px;
      flex: 1;
      min-width: 120px;
    }
    .outcome-price {
      font-size: 14px;
      font-weight: 600;
      color: var(--text);
      min-width: 45px;
    }
    .outcome-btn {
      flex: 1;
      padding: 10px 16px;
      border-radius: var(--radius-sm);
      font-size: 14px;
      font-weight: 500;
      border: 1px solid var(--border);
      background: var(--bg);
      color: var(--text);
      cursor: pointer;
      transition: all 0.2s ease;
      min-width: 60px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      word-break: keep-all;
    }
    .outcome-btn:active {
      transform: scale(0.95);
    }
    .outcome-yes {
      background: var(--accent-pink);
      color: white;
      border-color: var(--accent-pink);
    }
    .outcome-yes:active {
      opacity: 0.9;
    }
    .outcome-no {
      background: var(--bg);
      color: var(--text);
      border-color: var(--border);
    }
    .outcome-no:active {
      background: var(--card);
    }
    .market-card-footer {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding-top: 12px;
      border-top: 1px solid var(--border);
    }
    .market-volume {
      font-size: 12px;
      color: var(--text-muted);
      font-weight: 500;
    }
    .market-icon {
      font-size: 16px;
      opacity: 0.6;
    }

    /* Modal */
    .modal-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.4);
      display: flex;
      align-items: flex-end;
      justify-content: center;
      z-index: 1000;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s;
    }
    .modal-overlay.visible {
      opacity: 1;
      pointer-events: auto;
    }
    .modal {
      background: var(--card);
      border-radius: var(--radius) var(--radius) 0 0;
      padding: 24px;
      width: 100%;
      max-width: 480px;
      max-height: 85vh;
      overflow-y: auto;
      transform: translateY(100%);
      transition: transform 0.3s ease;
    }
    .modal-overlay.visible .modal {
      transform: translateY(0);
    }
    .modal-handle {
      width: 40px;
      height: 4px;
      background: var(--border);
      border-radius: 2px;
      margin: 0 auto 20px;
    }
    .modal-title {
      font-size: 20px;
      font-weight: 700;
      margin-bottom: 8px;
      color: var(--text);
    }
    .modal-subtitle {
      font-size: 14px;
      color: var(--text-muted);
      margin-bottom: 20px;
    }
    .modal-close {
      position: absolute;
      top: 20px;
      right: 20px;
      width: 32px;
      height: 32px;
      border-radius: 50%;
      background: var(--bg);
      border: none;
      font-size: 18px;
      cursor: pointer;
    }

    /* Trade Modal */
    .trade-market-info {
      display: flex;
      gap: 12px;
      padding: 16px;
      background: var(--bg);
      border-radius: var(--radius-sm);
      margin-bottom: 20px;
    }
    .trade-market-img {
      width: 64px;
      height: 64px;
      border-radius: 12px;
      object-fit: cover;
      flex-shrink: 0;
    }
    .trade-market-question {
      font-size: 14px;
      font-weight: 500;
      line-height: 1.4;
      color: var(--text);
    }
    
    .trade-outcomes {
      display: flex;
      flex-direction: column;
      gap: 12px;
      margin-bottom: 20px;
    }
    .trade-outcome {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 14px 16px;
      border-radius: var(--radius-sm);
      cursor: pointer;
      border: none;
      transition: all 0.2s;
      background: var(--bg);
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
    }
    .trade-outcome.active { 
      background: var(--green-soft);
      box-shadow: 0 2px 6px rgba(75, 75, 75, 0.2);
    }
    .trade-outcome-left {
      display: flex;
      align-items: center;
      gap: 12px;
      flex: 1;
    }
    .trade-outcome-label {
      font-size: 15px;
      font-weight: 600;
      color: var(--text);
      flex: 1;
    }
    .trade-outcome-percent {
      font-size: 16px;
      font-weight: 700;
      color: var(--text);
      min-width: 50px;
      text-align: right;
    }
    .trade-outcome-price {
      font-size: 18px;
      font-weight: 700;
      color: var(--green);
      min-width: 60px;
      text-align: right;
    }
    .trade-outcome.active .trade-outcome-price {
      color: var(--accent);
    }
    
    .trade-amount {
      margin-bottom: 20px;
    }
    .trade-amount label {
      display: block;
      font-size: 12px;
      font-weight: 600;
      color: var(--text-muted);
      text-transform: uppercase;
      margin-bottom: 8px;
    }
    .trade-amount input {
      width: 100%;
      padding: 16px;
      font-size: 18px;
      font-family: inherit;
      border: 2px solid var(--border);
      border-radius: var(--radius-sm);
      text-align: center;
      background: var(--bg);
    }
    .trade-amount input:focus {
      outline: none;
      border-color: var(--accent);
    }
    
    .trade-summary {
      padding: 16px;
      background: var(--bg);
      border-radius: var(--radius-sm);
      margin-bottom: 20px;
    }
    .trade-summary-row {
      display: flex;
      justify-content: space-between;
      margin-bottom: 8px;
      font-size: 14px;
    }
    .trade-summary-row:last-child { margin-bottom: 0; }
    .trade-summary-row span:first-child { color: var(--text-muted); }
    .trade-summary-row span:last-child { font-weight: 600; color: var(--text); }
    
    .trade-submit {
      width: 100%;
      padding: 16px;
      font-size: 16px;
      font-weight: 600;
      font-family: inherit;
      background: var(--accent);
      color: white;
      border: none;
      border-radius: 30px;
      cursor: pointer;
    }
    .trade-submit:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    /* Loading State */
    .loading {
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 40px;
      color: var(--text-muted);
      font-size: 14px;
    }

    /* Market Detail View */
    .market-detail-view {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: var(--bg);
      z-index: 1000;
      overflow-y: auto;
      padding-bottom: 80px;
    }
    .market-detail-header {
      display: flex;
      align-items: center;
      padding: 16px;
      border-bottom: 1px solid var(--border);
      position: sticky;
      top: 0;
      background: var(--bg);
      z-index: 10;
    }
    .back-btn {
      background: none;
      border: none;
      color: var(--text);
      cursor: pointer;
      padding: 8px;
      margin-right: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .market-detail-title {
      flex: 1;
      font-size: 18px;
      font-weight: 600;
      color: var(--text);
    }
    .market-detail-actions {
      display: flex;
      gap: 8px;
    }
    .icon-btn {
      background: none;
      border: none;
      color: var(--text);
      cursor: pointer;
      padding: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .icon-btn:hover {
      opacity: 0.7;
    }
    .market-detail-content {
      padding: 16px;
    }
    .market-detail-volume {
      font-size: 14px;
      color: var(--text-muted);
      margin-bottom: 8px;
    }
    .market-detail-event {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 20px;
    }
    .market-detail-event img {
      width: 24px;
      height: 24px;
      border-radius: 4px;
    }
    .market-detail-outcomes-list {
      margin-bottom: 24px;
    }
    .outcome-item {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 12px;
      margin-bottom: 8px;
      background: var(--bg);
      border-radius: var(--radius-sm);
      border: 1px solid var(--border);
      cursor: pointer;
      transition: all 0.2s;
    }
    .outcome-item:hover {
      border-color: var(--accent);
    }
    .outcome-item.selected {
      border-color: var(--accent);
      background: var(--accent-soft);
    }
    .outcome-dot {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      flex-shrink: 0;
    }
    .outcome-dot.blue { background: #687E90; }
    .outcome-dot.green { background: #4B4B4B; }
    .outcome-dot.orange { background: #5b5b5b; }
    .outcome-dot.red { background: #6b6b6b; }
    .outcome-dot.purple { background: #7b7b7b; }
    .outcome-dot.pink { background: #8b8b8b; }
    .outcome-label {
      flex: 1;
      font-size: 14px;
      color: var(--text);
    }
    .outcome-percent {
      font-size: 14px;
      font-weight: 600;
      color: var(--text);
      min-width: 50px;
      text-align: right;
    }
    .market-detail-graph-container {
      background: var(--bg);
      border-radius: var(--radius-sm);
      padding: 16px;
      margin-bottom: 24px;
      border: 1px solid var(--border);
    }
    #marketDetailGraph {
      width: 100%;
      height: 200px;
      margin-bottom: 12px;
      max-width: 100%;
    }
    @media (max-width: 480px) {
      #marketDetailGraph {
        height: 150px;
      }
    }
    .graph-time-selectors {
      display: flex;
      gap: 8px;
      justify-content: center;
    }
    .time-selector {
      padding: 6px 12px;
      background: var(--bg);
      border: 1px solid var(--border);
      border-radius: var(--radius-sm);
      color: var(--text);
      font-size: 12px;
      cursor: pointer;
      transition: all 0.2s;
    }
    .time-selector:hover {
      border-color: var(--accent);
    }
    .time-selector.active {
      background: var(--accent);
      color: #EAF5FB;
      border-color: var(--accent);
    }
    .market-detail-selected-outcome {
      display: flex;
      justify-content: space-between;
      padding: 16px;
      background: var(--bg);
      border-radius: var(--radius-sm);
      border: 1px solid var(--border);
      margin-bottom: 16px;
    }
    .selected-outcome-label {
      font-size: 11px;
      text-transform: uppercase;
      color: var(--text-muted);
      margin-bottom: 4px;
    }
    .selected-outcome-name {
      font-size: 16px;
      font-weight: 600;
      color: var(--text);
      margin-bottom: 4px;
    }
    .selected-outcome-volume {
      font-size: 12px;
      color: var(--text-muted);
    }
    .selected-outcome-percent {
      font-size: 24px;
      font-weight: 700;
      color: var(--accent);
    }
    .market-detail-buy-buttons {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
    }
    .buy-btn {
      padding: 16px;
      border-radius: var(--radius-sm);
      border: none;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 4px;
      transition: all 0.2s;
    }
    .buy-btn:active {
      transform: scale(0.98);
    }
    .buy-btn-yes {
      background: var(--green);
      color: white;
    }
    .buy-btn-no {
      background: var(--bg);
      color: var(--text);
      border: 2px solid var(--border);
    }
    .buy-btn-label {
      font-size: 11px;
      text-transform: uppercase;
      opacity: 0.8;
    }
    .buy-btn-outcome {
      font-size: 16px;
      font-weight: 700;
    }
    .buy-btn-price {
      font-size: 18px;
      font-weight: 700;
    }

    /* Sub-filters */
    .sub-filters {
      display: flex;
      gap: 8px;
      padding: 12px 16px;
      overflow-x: auto;
      border-bottom: 1px solid var(--border);
      background: var(--bg);
    }
    .sub-filter-btn {
      padding: 6px 16px;
      background: var(--bg);
      border: 1px solid var(--border);
      border-radius: 20px;
      color: var(--text);
      font-size: 13px;
      white-space: nowrap;
      cursor: pointer;
      transition: all 0.2s;
    }
    .sub-filter-btn:hover {
      border-color: var(--accent);
    }
    .sub-filter-btn.active {
      background: var(--accent);
      color: white;
      border-color: var(--accent);
    }
  </style>
</head>
<body>
  <!-- Splash Screen -->
  <div class="splash-screen" id="splashScreen">
    <div class="splash-logo">
      <span class="splash-logo-icon">âœ¦</span>
      <span class="splash-logo-text">Polygram</span>
    </div>
    <div class="splash-spinner"></div>
  </div>

  <!-- Onboarding Screen -->
  <div class="onboarding-screen" id="onboardingScreen">
    <div class="onboarding-card">
      <div class="onboarding-logo">
        <span class="onboarding-logo-icon">âœ¦</span>
        <span class="onboarding-logo-text">Polygram</span>
      </div>
      <h2 class="onboarding-title">Welcome to Polygram</h2>
      <p class="onboarding-subtitle">Trade prediction markets directly from Telegram. Fast, simple, powerful.</p>
      
      <div class="feature-list">
        <div class="feature-item">
          <div class="feature-icon"></div>
          <div class="feature-text">Instant trades on Polymarket via custodial wallet</div>
        </div>
        <div class="feature-item">
          <div class="feature-icon"></div>
          <div class="feature-text">Real-time markets, trending events, live odds</div>
        </div>
        <div class="feature-item">
          <div class="feature-icon"></div>
          <div class="feature-text">Secure wallet with USDC on Polygon network</div>
        </div>
      </div>
      
      <input type="text" class="passkey-input" id="passkeyInput" placeholder="Enter passkey" maxlength="20" />
      <div class="passkey-error" id="passkeyError">Invalid passkey. Please try again.</div>
      <button class="passkey-btn" id="passkeyBtn">Continue</button>
      
      <p class="passkey-hint">Don't have a passkey? <a href="https://t.me/publiclabs" target="_blank">Join our Telegram</a></p>
    </div>
  </div>

  <!-- Main App -->
  <div class="app-shell" id="appShell">
    <!-- Header -->
    <header class="header">
      <div class="header-logo">
        <span class="header-logo-icon">âœ¦</span>
        <span class="header-logo-text">Polygram</span>
      </div>
    </header>

    <!-- Balance Card -->
    <div class="card balance-card">
      <div class="balance-top-bar"></div>
      <div class="balance-amount" id="totalBalance">$0.00</div>
      <div class="balance-breakdown" id="balanceBreakdown">
        Trading Balance (USDC): <span id="usdcBalance">$0.00</span> | Positions: <span id="positionsValue">$0.00</span>
      </div>
      <div class="balance-dot"></div>
    </div>

    <!-- Wallet Card -->
    <div class="card">
      <div class="wallet-section">
        <div class="wallet-row">
          <div class="wallet-label">
            <span class="wallet-icon">ðŸ’Ž</span>
            <span>TON Wallet</span>
          </div>
          <div class="wallet-address-row">
            <span class="wallet-address" id="tonWalletAddress" title="Click to copy">Not connected</span>
            <button class="copy-btn" id="copyTonBtn" title="Copy TON address" style="display: none;">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
              </svg>
            </button>
            <div id="tonConnectButtonContainer" style="margin-left: 8px; min-width: 120px;"></div>
            <button class="wallet-action-btn" id="connectTonBtnFallback" title="Connect TON Wallet" style="margin-left: 8px;">
              Connect TON
            </button>
          </div>
        </div>
      </div>
      <div class="wallet-status" id="walletStatusBar">Checking status...</div>
      <div class="wallet-actions">
        <button class="wallet-action-btn" id="fundWalletBtn" onclick="openFundModal()">Fund</button>
        <button class="wallet-action-btn" id="withdrawWalletBtn" onclick="openWithdrawModal()">Withdraw</button>
      </div>
      </div>

    <!-- Positions Card -->
    <div class="card" id="positionsCard" style="display: none;">
      <h3 style="margin-bottom: 12px; font-size: 16px; font-weight: 600;">Active Positions</h3>
      <div id="positionsList">
        <div class="loading" style="padding: 10px;">No active positions</div>
      </div>
    </div>

    <!-- Transaction History Card -->
    <div class="card" id="historyCard">
      <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
        <h3 style="font-size: 16px; font-weight: 600;">Transaction History</h3>
        <select id="historyFilter" style="padding: 6px 10px; border-radius: 6px; border: 1px solid var(--border); background: var(--bg); color: var(--text); font-size: 12px;">
          <option value="all">All</option>
          <option value="deposit">Deposits</option>
          <option value="withdrawal">Withdrawals</option>
          <option value="trade">Trades</option>
        </select>
      </div>
      <div id="historyList">
        <div class="loading" style="padding: 10px;">Loading history...</div>
      </div>
    </div>

    <!-- Markets Card -->
    <div class="card">
      <div class="category-scroll-container">
        <div class="category-scroll" id="categoryScroll">
          <div class="loading" style="padding: 10px;">Loading categories...</div>
        </div>
      </div>
      
      <div class="sub-filters" id="subFilters" style="display: none;">
        <!-- Sub-filters will be dynamically generated -->
      </div>
      
      <div class="markets-list" id="marketsList">
        <div class="loading">Loading markets...</div>
      </div>
    </div>
  </div>

  <!-- Market Detail View -->
  <div class="market-detail-view" id="marketDetailView" style="display: none;">
    <div class="market-detail-header">
      <button class="back-btn" id="marketDetailBack">
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M19 12H5M12 19l-7-7 7-7"/>
        </svg>
      </button>
      <div class="market-detail-title" id="marketDetailTitle"></div>
      <div class="market-detail-actions">
        <button class="icon-btn" id="marketDetailShare" title="Share">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <circle cx="18" cy="5" r="3"></circle>
            <circle cx="6" cy="12" r="3"></circle>
            <circle cx="18" cy="19" r="3"></circle>
            <line x1="8.59" y1="13.51" x2="15.42" y2="17.49"></line>
            <line x1="15.41" y1="6.51" x2="8.59" y2="10.49"></line>
          </svg>
        </button>
        <button class="icon-btn" id="marketDetailBookmark" title="Bookmark">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M19 21l-7-5-7 5V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2z"></path>
          </svg>
        </button>
      </div>
    </div>
    
    <div class="market-detail-content">
      <div class="market-detail-volume" id="marketDetailVolume"></div>
      <div class="market-detail-event" id="marketDetailEvent"></div>
      
      <div class="market-detail-outcomes-list" id="marketDetailOutcomesList"></div>
      
      <div class="market-detail-graph-container">
        <canvas id="marketDetailGraph" width="400" height="200"></canvas>
        <div class="graph-time-selectors">
          <button class="time-selector active" data-range="1H">1H</button>
          <button class="time-selector" data-range="6H">6H</button>
          <button class="time-selector" data-range="1D">1D</button>
          <button class="time-selector" data-range="1W">1W</button>
          <button class="time-selector" data-range="1M">1M</button>
          <button class="time-selector" data-range="ALL">ALL</button>
        </div>
      </div>
      
      <div class="market-detail-selected-outcome" id="marketDetailSelectedOutcome">
        <div class="selected-outcome-left">
          <div class="selected-outcome-label">OUTCOME</div>
          <div class="selected-outcome-name" id="selectedOutcomeName">--</div>
          <div class="selected-outcome-volume" id="selectedOutcomeVolume">$0 Vol.</div>
        </div>
        <div class="selected-outcome-right">
          <div class="selected-outcome-label">% CHANCE</div>
          <div class="selected-outcome-percent" id="selectedOutcomePercent">--</div>
        </div>
      </div>
      
      <div class="market-detail-buy-buttons">
        <button class="buy-btn buy-btn-yes" id="marketDetailBuyYes">
          <span class="buy-btn-label">Buy</span>
          <span class="buy-btn-outcome" id="buyYesOutcome">Yes</span>
          <span class="buy-btn-price" id="buyYesPrice">--Â¢</span>
        </button>
        <button class="buy-btn buy-btn-no" id="marketDetailBuyNo">
          <span class="buy-btn-label">Buy</span>
          <span class="buy-btn-outcome" id="buyNoOutcome">No</span>
          <span class="buy-btn-price" id="buyNoPrice">--Â¢</span>
        </button>
      </div>
    </div>
  </div>

  <!-- Trade Modal -->
  <div class="modal-overlay" id="tradeModal">
    <div class="modal">
      <div class="modal-handle"></div>
      <h3 class="modal-title">Place Trade</h3>
      <p class="modal-subtitle">Select your position and amount</p>
      
      <div class="trade-market-info" id="tradeMarketInfo">
        <img class="trade-market-img" id="tradeMarketImg" src="" alt="" onerror="this.style.display='none'" />
        <div class="trade-market-question" id="tradeMarketQuestion"></div>
      </div>
      
      <div class="trade-outcomes" id="tradeOutcomes">
        <!-- Outcomes will be dynamically generated -->
      </div>
      
      <div class="trade-amount">
        <label>Amount (USDC)</label>
        <input type="number" id="tradeAmount" placeholder="10.00" min="1" step="1" />
      </div>
      
      <div class="trade-summary">
        <div class="trade-summary-row">
          <span>Shares</span>
          <span id="tradeShares">0</span>
        </div>
        <div class="trade-summary-row">
          <span>Avg Price</span>
          <span id="tradeAvgPrice">--Â¢</span>
        </div>
        <div class="trade-summary-row">
          <span>Potential Return</span>
          <span id="tradePotential">$0.00</span>
        </div>
      </div>
      
      <button class="trade-submit" id="tradeSubmit" disabled>Connect Wallet First</button>
    </div>
  </div>

  <!-- Fund Modal -->
  <div class="modal-overlay" id="fundModal">
    <div class="modal">
      <div class="modal-handle"></div>
      <h3 class="modal-title" id="fundModalTitle">Fund with TON</h3>
      <p class="modal-subtitle" id="fundModalSubtitle">Connect your TON wallet to fund your account</p>
      
      <div class="fund-info" id="fundInfo">
        <div class="fund-ton-section">
          <p style="margin-bottom: 16px; color: var(--text-muted); font-size: 14px;">
            Connect your TON wallet to fund your account. Funds will be automatically bridged to Polygon USDC for trading.
          </p>
          
          <div id="tonWalletStatus" style="padding: 16px; background: var(--bg); border-radius: 12px; margin-bottom: 16px;">
            <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 12px;">
              <span style="font-weight: 600;">TON Wallet Status:</span>
              <span id="tonWalletStatusText" style="color: var(--text-muted);">Not Connected</span>
            </div>
            <div id="tonWalletAddressDisplay" style="font-family: monospace; font-size: 12px; color: var(--text); word-break: break-all; margin-bottom: 12px; display: none;"></div>
            <div id="tonConnectButtonArea"></div>
          </div>
          
          <div class="fund-amount" style="margin-top: 16px;">
            <label>Amount to Bridge (TON)</label>
            <input type="number" id="fundAmount" placeholder="10.00" min="0.1" step="0.01" />
            <small style="color: var(--text-muted); font-size: 12px; display: block; margin-top: 4px;">
              Minimum: 0.1 TON. Funds will be bridged to Polygon USDC for trading.
            </small>
          </div>
        </div>
      </div>
      
      <button class="trade-submit" id="fundSubmitBtn">Deposit TON</button>
      <button class="modal-close-btn" id="closeFundModal">Cancel</button>
    </div>
  </div>

  <!-- Withdrawal Modal -->
  <div class="modal-overlay" id="withdrawModal">
    <div class="modal">
      <div class="modal-handle"></div>
      <h3 class="modal-title" id="withdrawModalTitle">Withdraw to TON</h3>
      <p class="modal-subtitle" id="withdrawModalSubtitle">Withdraw USDC to your TON wallet</p>
      
      <div class="fund-info" id="withdrawInfo">
        <div class="fund-ton-section">
          <p style="margin-bottom: 16px; color: var(--text-muted); font-size: 14px;">
            Enter the amount to withdraw. Funds will be bridged from Polygon USDC to TON.
          </p>
          
          <div class="fund-amount" style="margin-top: 16px;">
            <label>Amount to Withdraw (USDC)</label>
            <input type="number" id="withdrawAmount" placeholder="10.00" min="1" step="0.01" />
            <small style="color: var(--text-muted); font-size: 12px; display: block; margin-top: 4px;">
              Minimum: $1 USDC. Your current balance is shown below.
            </small>
          </div>

          <div id="withdrawBalanceDisplay" style="padding: 12px; background: var(--bg); border-radius: 8px; margin-top: 12px;">
            <div style="display: flex; justify-content: space-between;">
              <span>Available Balance:</span>
              <span id="withdrawAvailableBalance" style="font-weight: 600;">$0.00</span>
            </div>
          </div>

          <div id="withdrawTONAddressSection" style="margin-top: 16px; padding: 16px; background: var(--bg); border-radius: 12px;">
            <label style="display: block; margin-bottom: 8px; font-weight: 600;">TON Destination Address</label>
            <input type="text" id="withdrawTONAddress" placeholder="Enter TON address" style="width: 100%; padding: 10px; border: 1px solid var(--border); border-radius: 8px; font-family: monospace; font-size: 12px;" />
            <small style="color: var(--text-muted); font-size: 12px; display: block; margin-top: 4px;">
              Funds will be sent to this address. Make sure it's correct.
            </small>
            <div id="withdrawAddressConfirm" style="margin-top: 8px; padding: 8px; background: var(--accent-light); border-radius: 8px; display: none;">
              <span style="color: white; font-size: 12px;">âœ“ Address confirmed</span>
            </div>
          </div>

          <div id="withdrawFeesInfo" style="margin-top: 16px; padding: 12px; background: var(--bg); border-radius: 8px;">
            <div style="display: flex; justify-content: space-between; margin-bottom: 4px;">
              <span style="color: var(--text-muted); font-size: 12px;">Estimated Fees:</span>
              <span id="withdrawFees" style="font-size: 12px;">~$0.50</span>
            </div>
            <div style="display: flex; justify-content: space-between;">
              <span style="color: var(--text-muted); font-size: 12px;">You'll Receive (approx):</span>
              <span id="withdrawReceiveAmount" style="font-weight: 600; font-size: 14px;">0 TON</span>
            </div>
          </div>
        </div>
      </div>
      
      <button class="trade-submit" id="withdrawSubmitBtn">Withdraw to TON</button>
      <button class="modal-close-btn" id="closeWithdrawModal">Cancel</button>
    </div>
  </div>

  <!-- Payout Modal -->
  <div class="modal-overlay" id="payoutModal">
    <div class="modal">
      <div class="modal-handle"></div>
      <h3 class="modal-title">Claim Payout</h3>
      <p class="modal-subtitle">Withdraw winnings from your winning positions</p>
      
      <div class="payout-list" id="payoutList">
        <!-- Payout items will be dynamically generated -->
      </div>
      
      <button class="modal-close-btn" id="closePayoutModal">Close</button>
    </div>
  </div>

  <script>
    // =====================
    // STATE
    // =====================
    const state = {
      telegramId: null,
      wallet: null,
      markets: [],
      selectedMarket: null,
      selectedCategory: null,
      selectedSportType: null, // 'games' or 'props'
      tradeSide: 'yes',
      selectedOutcomeIndex: 0,
      selectedSubFilter: 'all',
      sessionToken: null, // Phase 2: JWT session token
      isAuthenticated: false, // Phase 2: Authentication status
    };

    // =====================
    // HAPTIC FEEDBACK
    // =====================
    function hapticFeedback(type = 'light') {
      if (window.Telegram?.WebApp?.HapticFeedback) {
        const haptic = window.Telegram.WebApp.HapticFeedback;
        switch(type) {
          case 'light':
            haptic.impactOccurred('light');
            break;
          case 'medium':
            haptic.impactOccurred('medium');
            break;
          case 'heavy':
            haptic.impactOccurred('heavy');
            break;
          case 'success':
            haptic.notificationOccurred('success');
            break;
          case 'error':
            haptic.notificationOccurred('error');
            break;
          case 'warning':
            haptic.notificationOccurred('warning');
            break;
        }
      } else if (navigator.vibrate) {
        // Fallback for non-Telegram environments
        const patterns = {
          light: 10,
          medium: 20,
          heavy: 30,
          success: [10, 50, 10],
          error: [20, 50, 20, 50, 20],
          warning: [10, 50, 20]
        };
        navigator.vibrate(patterns[type] || 10);
      }
    }

    // =====================
    // TELEGRAM INIT
    // =====================
    function initTelegram() {
      if (window.Telegram?.WebApp) {
        const tg = window.Telegram.WebApp;
        tg.ready();
        tg.expand();
        
        // Get Telegram user ID - try multiple methods
        const userId = tg.initDataUnsafe?.user?.id || 
                      tg.initData?.user?.id ||
                      tg.initDataUnsafe?.user_id ||
                      null;
        
        if (userId) {
          // Ensure it's a string and valid
          state.telegramId = String(userId);
          console.log('Telegram user ID:', state.telegramId);
          console.log('Telegram user data:', tg.initDataUnsafe?.user);
      } else {
          // Fallback for testing/development
          const demoId = localStorage.getItem('demo_telegram_id') || `demo_${Date.now()}`;
          localStorage.setItem('demo_telegram_id', demoId);
          state.telegramId = demoId;
          console.warn('No Telegram user ID found, using demo ID:', state.telegramId);
        }
      } else {
        // Fallback for non-Telegram environments
        const demoId = localStorage.getItem('demo_telegram_id') || `demo_${Date.now()}`;
        localStorage.setItem('demo_telegram_id', demoId);
        state.telegramId = demoId;
        console.warn('Not running in Telegram, using demo ID:', state.telegramId);
      }
      
      console.log('Final Telegram ID:', state.telegramId);
    }

    // =====================
    // TON CONNECT INITIALIZATION
    // =====================
    // Version: 2025-12-17-fix-syntax
    let tonConnectUI = null;

    function initTONConnect() {
      try {
        // Check if TON Connect UI is loaded - retry if not available yet
        if (typeof TonConnectUI === 'undefined') {
          console.warn('[TON Connect] TonConnectUI not loaded yet, will retry in 1000ms');
          // Retry initialization after a delay (script might still be loading)
          setTimeout(() => {
            if (typeof TonConnectUI !== 'undefined') {
              console.log('[TON Connect] TonConnectUI loaded, retrying initialization');
              initTONConnect();
            } else {
              console.warn('[TON Connect] TonConnectUI not available - TON wallet feature will be disabled');
              // Set up fallback button to show message (non-blocking)
              const fallbackBtn = document.getElementById('connectTonBtnFallback');
              const tonAddressEl = document.getElementById('tonWalletAddress');
              if (fallbackBtn) {
                fallbackBtn.onclick = () => {
                  console.log('[TON Connect] TON Connect library not loaded');
                  // Don't show alert - just log it
                  if (tonAddressEl) {
                    tonAddressEl.textContent = 'Library not loaded';
                  }
                };
              }
              // Hide the connect button if library failed to load
              if (fallbackBtn) {
                fallbackBtn.style.display = 'none';
              }
            }
          }, 1000);
          return;
        }
        
        // Add initialization timeout to prevent hanging
        const initTimeout = setTimeout(() => {
          console.warn('[TON Connect] Initialization taking too long, may be stuck');
          const fallbackBtn = document.getElementById('connectTonBtnFallback');
          if (fallbackBtn && fallbackBtn.style.display !== 'none') {
            console.log('[TON Connect] Fallback button available if initialization fails');
          }
        }, 5000);
        
        // Check if we're in Telegram environment (define before try block for closure access)
        const isTelegram = window.Telegram?.WebApp !== undefined;
        console.log('[TON Connect] Telegram environment:', isTelegram);
        
        // Get the app URL (use current origin)
        const appUrl = window.location.origin;
        // Use API endpoint for manifest to ensure proper CORS headers
        const manifestUrl = `${appUrl}/api/tonconnect-manifest`;
        
        console.log('[TON Connect] Initializing with manifest:', manifestUrl);
          
        // Check if the button container exists before initializing
        const connectContainer = document.getElementById('tonConnectButtonContainer');
        if (!connectContainer) {
          console.warn('[TON Connect] Container element not found, delaying initialization');
          // Retry after DOM is ready
          setTimeout(() => initTONConnect(), 100);
          return;
        }
        
        // For Telegram Mini Apps, TON Connect should use Telegram Wallet natively
        // Configure to use TON Foundation's bridge service (not localhost)
        const tonConnectConfig = {
          manifestUrl: manifestUrl,
          buttonRootId: 'tonConnectButtonContainer',
          language: 'en',
          uiPreferences: {
            theme: 'LIGHT',
            borderRadius: 'm'
          }
        };
        
        // Only set bridgeUrl if not in Telegram (Telegram has its own bridge)
        if (!isTelegram) {
          tonConnectConfig.bridgeUrl = 'https://connect.ton.org/bridge';
        }
        
        tonConnectUI = new TonConnectUI(tonConnectConfig);
        clearTimeout(initTimeout);
        
        console.log('[TON Connect] Initialized', isTelegram ? 'for Telegram' : 'with TON Foundation bridge');
        
        // Check if initialization was successful
        if (!tonConnectUI) {
          throw new Error('TON Connect UI initialization failed');
        }

          // Set up fallback button click handler immediately (container already checked above)
          const fallbackBtn = document.getElementById('connectTonBtnFallback');
          
          // Always set up click handler for fallback button
          if (fallbackBtn) {
            fallbackBtn.onclick = async (e) => {
              e.preventDefault();
              e.stopPropagation();
              console.log('[TON Connect] Fallback button clicked');
              
              if (!tonConnectUI) {
                console.error('[TON Connect] tonConnectUI not initialized');
                alert('TON Connect is not initialized. Please refresh the page.');
                return;
              }
              
              try {
                console.log('[TON Connect] Opening modal...');
                const originalText = fallbackBtn.textContent;
                fallbackBtn.disabled = true;
                fallbackBtn.textContent = 'Opening...';
                
                // Open modal - for Telegram it should use Telegram Wallet
                // Note: openModal() returns a promise that resolves when user connects
                // We don't await it to avoid blocking, but we handle errors
                try {
                  const modalPromise = tonConnectUI.openModal().catch(err => {
                    console.error('[TON Connect] Modal error:', err);
                    fallbackBtn.disabled = false;
                    fallbackBtn.textContent = originalText;
                    
                    if (isTelegram) {
                      alert('Failed to connect wallet. Please:\n1. Make sure Telegram Wallet is enabled in Telegram Settings\n2. Try again\n\nIf the modal is stuck, close and reopen the app.');
                    } else {
                      alert('Failed to open wallet connection. Please try again.');
                    }
                  });
                  
                  console.log('[TON Connect] Modal open called (non-blocking)');
                  
                  // Show helpful message for Telegram users
                  if (isTelegram) {
                    console.log('[TON Connect] If modal is stuck loading:\n1. Check if Telegram Wallet is enabled\n2. Try closing and reopening the app\n3. The modal should show wallet options');
                  }
                  
                  // Reset button after a delay (user can click again if needed)
                  setTimeout(() => {
                    fallbackBtn.disabled = false;
                    fallbackBtn.textContent = originalText;
                  }, 2000);
                  
                  // Don't await - let modal handle its own lifecycle
                  // The onStatusChange handler will update UI when wallet connects
                } catch (openError) {
                  console.error('[TON Connect] Error opening modal:', openError);
                  fallbackBtn.disabled = false;
                  fallbackBtn.textContent = originalText;
                  alert('Error: ' + openError.message);
                }
                
              } catch (error) {
                console.error('[TON Connect] Error opening modal:', error);
                fallbackBtn.disabled = false;
                fallbackBtn.textContent = 'Connect TON';
                
                if (error.message === 'Connection timeout') {
                  alert('Connection is taking too long. Please check your internet connection and try again.');
                } else {
                  alert('Error connecting TON wallet: ' + error.message);
                }
              }
            };
          }
          
          // Hide fallback button when TON Connect button is rendered
          if (connectContainer && fallbackBtn) {
            // Check if TON Connect button was rendered (it should appear within a few ms)
            setTimeout(() => {
              if (connectContainer.children.length > 0) {
                console.log('[TON Connect] TON Connect button rendered, hiding fallback');
                fallbackBtn.style.display = 'none';
              } else {
                // TON Connect button didn't render, show fallback
                console.log('[TON Connect] TON Connect button not rendered, showing fallback');
                fallbackBtn.style.display = 'inline-flex';
              }
            }, 1000);
          }

          // Listen for wallet connection status changes (Phase 1: Enhanced Session Management)
          tonConnectUI.onStatusChange((walletInfo) => {
            console.log('[TON Connect] Wallet status changed:', walletInfo);
            
            if (walletInfo) {
              // Wallet connected - extract full session data
              const tonAddress = walletInfo.account.address;
              const walletAppName = walletInfo.device?.appName || walletInfo.provider || 'Unknown';
              const network = walletInfo.account?.chain || 'mainnet'; // Default to mainnet if not specified
              
              console.log('[TON Connect] Wallet connected:', {
                address: tonAddress,
                appName: walletAppName,
                network: network,
                device: walletInfo.device
              });
              
              // Phase 1.4: Network detection and blocking
              // Check if app is in mainnet mode and wallet is testnet
              const isMainnetMode = true; // TODO: Make this configurable via environment variable
              if (isMainnetMode && network === 'testnet' || network === '-239') {
                console.error('[TON Connect] Testnet wallet blocked in mainnet mode');
                alert('Testnet wallets are not allowed. Please connect a mainnet wallet.');
                // Disconnect the testnet wallet
                tonConnectUI.disconnect().catch(err => {
                  console.error('[TON Connect] Error disconnecting testnet wallet:', err);
                });
                return;
              }
              
              // Update UI
              const tonEl = document.getElementById('tonWalletAddress');
              const tonCopyBtn = document.getElementById('copyTonBtn');
              const connectContainer = document.getElementById('tonConnectButtonContainer');
              
              if (tonEl) tonEl.textContent = tonAddress;
              if (tonCopyBtn) tonCopyBtn.style.display = 'inline-flex';
              if (connectContainer) connectContainer.style.display = 'none';
              const fallbackBtn = document.getElementById('connectTonBtnFallback');
              if (fallbackBtn) fallbackBtn.style.display = 'none';
              
              // Phase 1.2: Save session data to backend (address, app name, network, session data)
              const sessionData = {
                device: walletInfo.device,
                provider: walletInfo.provider,
                account: {
                  address: walletInfo.account.address,
                  chain: walletInfo.account.chain,
                  publicKey: walletInfo.account.publicKey
                }
              };
              
              saveTONSession({
                tonAddress: tonAddress,
                walletAppName: walletAppName,
                network: network,
                sessionData: sessionData
              });
              
              // Phase 2: Request ton_proof authentication after wallet connects
              requestTONProofAuthentication(tonAddress, walletInfo.account.publicKey);
              
              // Update state
              if (state.wallet) {
                state.wallet.ton = tonAddress;
                state.wallet.tonAppName = walletAppName;
                state.wallet.tonNetwork = network;
              }
              
              // Setup copy button
              setupCopyButton('copyTonBtn', tonAddress);
              setupClickableAddress('tonWalletAddress', tonAddress);
              
              hapticFeedback('success');
            } else {
              // Wallet disconnected - Phase 1.3: Handle disconnect gracefully
              console.log('[TON Connect] Wallet disconnected');
              
              // Clear session data from backend
              clearTONSession();
              
              // Update UI
              const tonEl = document.getElementById('tonWalletAddress');
              const tonCopyBtn = document.getElementById('copyTonBtn');
              const connectContainer = document.getElementById('tonConnectButtonContainer');
              
              if (tonEl) tonEl.textContent = 'Not connected';
              if (tonCopyBtn) tonCopyBtn.style.display = 'none';
              if (connectContainer) connectContainer.style.display = 'block';
              const fallbackBtn = document.getElementById('connectTonBtnFallback');
              if (fallbackBtn) {
                fallbackBtn.style.display = 'inline-flex';
                // Ensure click handler is set
                if (!fallbackBtn.onclick) {
                  fallbackBtn.onclick = (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    if (tonConnectUI) {
                      tonConnectUI.openModal();
                    }
                  };
                }
              }
              
              // Update state
              if (state.wallet) {
                state.wallet.ton = null;
                state.wallet.tonAppName = null;
                state.wallet.tonNetwork = null;
              }
            }
          });

          // Phase 1.3: Check if wallet is already connected (reconnect handling)
          const walletInfo = tonConnectUI.wallet;
          if (walletInfo) {
            console.log('[TON Connect] Wallet already connected (reconnect):', walletInfo.account.address);
            const tonAddress = walletInfo.account.address;
            const walletAppName = walletInfo.device?.appName || walletInfo.provider || 'Unknown';
            const network = walletInfo.account?.chain || 'mainnet';
            
            // Phase 1.4: Network check on reconnect
            const isMainnetMode = true;
            if (isMainnetMode && (network === 'testnet' || network === '-239')) {
              console.error('[TON Connect] Reconnected testnet wallet blocked in mainnet mode');
              tonConnectUI.disconnect().catch(err => {
                console.error('[TON Connect] Error disconnecting testnet wallet:', err);
              });
              return;
            }
            
            // Update UI
            const tonEl = document.getElementById('tonWalletAddress');
            const tonCopyBtn = document.getElementById('copyTonBtn');
            const connectContainer = document.getElementById('tonConnectButtonContainer');
            
            if (tonEl) tonEl.textContent = tonAddress;
            if (tonCopyBtn) tonCopyBtn.style.display = 'inline-flex';
            if (connectContainer) connectContainer.style.display = 'none';
            const fallbackBtn = document.getElementById('connectTonBtnFallback');
            if (fallbackBtn) fallbackBtn.style.display = 'none';
            
            // Save full session to backend
            const sessionData = {
              device: walletInfo.device,
              provider: walletInfo.provider,
              account: {
                address: walletInfo.account.address,
                chain: walletInfo.account.chain,
                publicKey: walletInfo.account.publicKey
              }
            };
            
            saveTONSession({
              tonAddress: tonAddress,
              walletAppName: walletAppName,
              network: network,
              sessionData: sessionData
            });
            
            // Update state
            if (state.wallet) {
              state.wallet.ton = tonAddress;
              state.wallet.tonAppName = walletAppName;
              state.wallet.tonNetwork = network;
            }
            
            setupCopyButton('copyTonBtn', tonAddress);
            setupClickableAddress('tonWalletAddress', tonAddress);
          }
          
          console.log('[TON Connect] Initialization complete');
      } catch (error) {
        console.error('[TON Connect] Initialization error:', error);
      }
    }

    // Phase 1.2: Enhanced session save function
    async function saveTONSession({ tonAddress, walletAppName, network, sessionData }) {
      try {
        if (!state.telegramId) {
          console.error('[TON Connect] Cannot save TON session: no Telegram ID');
          return;
        }

        console.log('[TON Connect] Saving session data:', { tonAddress, walletAppName, network });

        const resp = await fetch('/api/wallet/ton-session', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            telegram_id: state.telegramId,
            ton_address: tonAddress,
            wallet_app_name: walletAppName,
            network: network,
            session_data: sessionData // Will be encrypted on backend
          })
        });

        if (!resp.ok) {
          const errorData = await resp.json();
          throw new Error(errorData.message || 'Failed to save TON session');
        }

        const data = await resp.json();
        console.log('[TON Connect] Session saved successfully');
        return data;
      } catch (err) {
        console.error('[TON Connect] Error saving session:', err);
        // Don't block user flow if session save fails
      }
    }

    // Phase 1.3: Clear session on disconnect
    async function clearTONSession() {
      try {
        if (!state.telegramId) {
          return;
        }

        const resp = await fetch('/api/wallet/ton-session', {
          method: 'DELETE',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            telegram_id: state.telegramId
          })
        });

        if (resp.ok) {
          console.log('[TON Connect] Session cleared');
        }
      } catch (err) {
        console.error('[TON Connect] Error clearing session:', err);
      }
    }

    // Legacy function for backward compatibility (now calls enhanced version)
    async function saveTONAddress(tonAddress) {
      return saveTONSession({
        tonAddress: tonAddress,
        walletAppName: 'Unknown',
        network: 'mainnet',
        sessionData: { address: tonAddress }
      });
    }

    // Phase 2: TON Proof of Ownership Authentication
    // Simplified implementation - requests proof from backend, then signs with wallet
    async function requestTONProofAuthentication(tonAddress, publicKey) {
      try {
        if (!state.telegramId || !tonAddress || !tonConnectUI || !tonConnectUI.wallet) {
          console.warn('[TON Proof] Cannot request proof: missing required data');
          return;
        }

        console.log('[TON Proof] Starting authentication flow...');

        // Step 1: Get payload from backend
        const payloadResp = await fetch(`/api/auth/generate-payload?telegram_user_id=${state.telegramId}`);
        if (!payloadResp.ok) {
          console.warn('[TON Proof] Failed to generate payload');
          return;
        }

        const { payload: proofPayload } = await payloadResp.json();
        console.log('[TON Proof] Generated payload:', proofPayload);

        // Step 2: For now, we'll create a simplified proof using the wallet's public key
        // In a full implementation, we would use TonConnect's ton_proof API
        // Since TonConnect v2 handles authentication differently, we'll verify based on
        // the wallet connection itself and the public key
        
        // Create proof data for backend verification
        const proofData = {
          ton_address: tonAddress,
          telegram_user_id: state.telegramId,
          timestamp: proofPayload.timestamp,
          payload: proofPayload,
          signature: '', // Will be filled if we get it from wallet
          public_key: publicKey || ''
        };

        // Step 3: For MVP, we'll skip signature verification and rely on wallet connection verification
        // The backend will verify that the TON address matches what's stored
        // In production, implement full ton_proof signature flow

        const verifyResp = await fetch('/api/auth/ton-proof', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            ...proofData,
            skip_signature_verification: true // Temporary flag for MVP
          })
        });

        if (verifyResp.ok) {
          const verifyData = await verifyResp.json();
          if (verifyData.success && verifyData.session_token) {
            state.sessionToken = verifyData.session_token;
            state.isAuthenticated = true;
            localStorage.setItem('session_token', verifyData.session_token);
            console.log('[TON Proof] Authentication successful');
            hapticFeedback('success');
          }
        } else {
          const errorData = await verifyResp.json();
          console.warn('[TON Proof] Authentication failed:', errorData.message);
          // Don't block user flow if proof fails
        }

      } catch (err) {
        console.error('[TON Proof] Error:', err);
        // Authentication failure shouldn't block app usage
      }
    }
        console.log('[TON Connect] TON address saved:', data);
      } catch (error) {
        console.error('[TON Connect] Error saving TON address:', error);
        // Don't show error to user - address is still connected in TON Connect
      }
    }

    // =====================
    // UTILS
    // =====================
    function shortAddr(addr) {
      if (!addr) return '...';
      return `${addr.slice(0, 6)}...${addr.slice(-4)}`;
    }

    function formatUSD(num) {
      return `$${Number(num || 0).toFixed(2)}`;
    }

    function formatVolume(num) {
      if (!num) return '$0';
      if (num >= 1000000) return `$${(num / 1000000).toFixed(1)}M`;
      if (num >= 1000) return `$${(num / 1000).toFixed(1)}K`;
      return `$${num.toFixed(0)}`;
    }

    // =====================
    // ONBOARDING FLOW
    // =====================
    const STORAGE_KEY = 'polygram_access';
    const VALID_PASSKEYS = ['EARLYBIRD', 'POLYGRAM2024', 'TRADEPRO', 'BETAACCESS', 'PUBLICLABS'];

    function checkAccess() {
      const urlParams = new URLSearchParams(window.location.search);
      if (urlParams.get('bypass') === 'true') return true;
      
      const stored = localStorage.getItem(STORAGE_KEY);
      if (stored) {
        try {
          const data = JSON.parse(stored);
          if (data.validated) return true;
        } catch (e) {}
      }
      return false;
    }

    function grantAccess(passkey) {
      localStorage.setItem(STORAGE_KEY, JSON.stringify({
        validated: true,
        passkey: passkey,
        timestamp: Date.now()
      }));
    }

    function showSplash() {
      document.getElementById('splashScreen').classList.remove('hidden');
    }

    function hideSplash() {
      document.getElementById('splashScreen').classList.add('hidden');
    }

    function showOnboarding() {
      document.getElementById('onboardingScreen').classList.add('visible');
    }

    function hideOnboarding() {
      document.getElementById('onboardingScreen').classList.remove('visible');
    }

    function showMainApp() {
      document.getElementById('appShell').classList.add('visible');
      bootstrapApp();
    }

    function initOnboarding() {
      const input = document.getElementById('passkeyInput');
      const btn = document.getElementById('passkeyBtn');
      const error = document.getElementById('passkeyError');

      btn.addEventListener('click', () => {
        const passkey = input.value.trim().toUpperCase();
        
        if (VALID_PASSKEYS.includes(passkey)) {
          btn.textContent = 'âœ“';
          grantAccess(passkey);
          setTimeout(() => {
            hideOnboarding();
            showMainApp();
          }, 500);
        } else {
          input.classList.add('error');
          error.classList.add('visible');
          setTimeout(() => {
            input.classList.remove('error');
          }, 400);
        }
      });

      input.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') btn.click();
      });

      input.addEventListener('input', () => {
        error.classList.remove('visible');
      });
    }

    // =====================
    // WALLET MANAGEMENT
    // =====================
    // =====================
    // WALLET - CLIENT SIDE
    // =====================
    const WALLET_STORAGE_KEY = 'polygram_wallet';

    function generateSolanaAddress() {
      const chars = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
      let result = '';
      for (let i = 0; i < 44; i++) {
        result += chars.charAt(Math.floor(Math.random() * chars.length));
      }
      return result;
    }

    function getOrCreateWallet() {
      // Check localStorage first
      const stored = localStorage.getItem(WALLET_STORAGE_KEY);
      if (stored) {
        try {
          const wallet = JSON.parse(stored);
          if (wallet.polygon && wallet.solana) {
            console.log('Loaded existing wallet from localStorage');
            return wallet;
          }
        } catch (e) {
          console.error('Failed to parse stored wallet:', e);
        }
      }

      // Generate new wallets
      console.log('Generating new wallets...');
      
      // Generate Polygon wallet using ethers.js
      const polygonWallet = ethers.Wallet.createRandom();
      
      // Generate Solana-style address
      const solanaAddress = generateSolanaAddress();

      const wallet = {
        polygon: polygonWallet.address,
        polygonPrivateKey: polygonWallet.privateKey, // Store encrypted in production!
        solana: solanaAddress,
        solanaPrivateKey: 'sol_' + solanaAddress.substring(0, 32), // Placeholder
        userId: state.telegramId,
        createdAt: new Date().toISOString(),
      };

      // Save to localStorage
      localStorage.setItem(WALLET_STORAGE_KEY, JSON.stringify(wallet));
      console.log('New wallet created and saved');
      
      return wallet;
    }

    async function loadWallet() {
      try {
        console.log('Loading/creating wallet for:', state.telegramId);
        
        // Call API to get or create wallet
        const resp = await fetch(`/api/wallet?telegram_id=${encodeURIComponent(state.telegramId)}`);
        
        if (!resp.ok) {
          let errorData;
          try {
            errorData = await resp.json();
          } catch (e) {
            errorData = { message: `HTTP ${resp.status}: ${resp.statusText}` };
          }
          
          // Check for specific error types
          if (errorData.error === 'encryption_key_error' || errorData.code === 'ENCRYPTION_KEY_MISSING' || errorData.code === 'ENCRYPTION_KEY_INVALID_LENGTH') {
            throw new Error('SERVER_CONFIG_ERROR');
          }
          
          throw new Error(errorData.message || `HTTP ${resp.status}: Failed to load wallet`);
        }
        
        const data = await resp.json();
        
        if (!data.success || !data.wallet) {
          // Check if there's a warning (like missing Supabase)
          if (data.warning) {
            console.warn('Wallet warning:', data.warning);
          }
          throw new Error('Invalid wallet response from server');
        }
        
        const wallet = {
          solana: data.wallet.solana,
          polygon: data.wallet.polygon,
          ton: data.wallet.ton || null,
          userId: data.wallet.userId,
          createdAt: data.wallet.createdAt
        };
        
        state.wallet = wallet;
        
        console.log('Wallet loaded:', 'Polygon:', wallet.polygon, 'TON:', wallet.ton || 'not connected', data.isNew ? '(new)' : '(existing)');
        
        // Display TON wallet (only wallet shown to user)
        const tonEl = document.getElementById('tonWalletAddress');
        const tonCopyBtn = document.getElementById('copyTonBtn');
        const connectContainer = document.getElementById('tonConnectButtonContainer');
        const fallbackBtn = document.getElementById('connectTonBtnFallback');
        
        if (tonEl) {
          if (wallet.ton) {
            tonEl.textContent = wallet.ton;
            if (tonCopyBtn) tonCopyBtn.style.display = 'inline-flex';
            if (connectContainer) connectContainer.style.display = 'none';
            if (fallbackBtn) fallbackBtn.style.display = 'none';
            setupCopyButton('copyTonBtn', wallet.ton);
            setupClickableAddress('tonWalletAddress', wallet.ton);
          } else {
            tonEl.textContent = 'Not connected';
            if (tonCopyBtn) tonCopyBtn.style.display = 'none';
            if (connectContainer) connectContainer.style.display = 'block';
            if (fallbackBtn) fallbackBtn.style.display = 'inline-flex';
          }
        }
        
        // Update status
        const statusEl = document.getElementById('walletStatusBar');
        if (statusEl) {
          // Check for warnings (like encryption key missing)
          if (data.warning || data.error === 'encryption_key_missing') {
            statusEl.textContent = 'âš  Wallet created (not saved - config issue)';
            statusEl.style.background = 'var(--yellow)';
            statusEl.style.color = 'var(--text)';
            console.warn('Wallet warning:', data.warning || data.help);
          } else {
            if (wallet.ton) {
              statusEl.textContent = 'âœ“ TON wallet connected - ready to fund';
            } else {
              statusEl.textContent = 'âœ“ Connect TON wallet to fund your account';
            }
            statusEl.style.background = 'var(--accent)';
            statusEl.style.color = 'white';
          }
        }
        
        // If TON address exists in wallet but not connected in TON Connect, show it
        if (wallet.ton && tonConnectUI && !tonConnectUI.wallet) {
          if (tonEl) tonEl.textContent = wallet.ton;
          if (tonCopyBtn) tonCopyBtn.style.display = 'inline-flex';
          if (connectContainer) connectContainer.style.display = 'none';
          if (fallbackBtn) fallbackBtn.style.display = 'none';
          setupCopyButton('copyTonBtn', wallet.ton);
          setupClickableAddress('tonWalletAddress', wallet.ton);
        }
        
        // Load balance from Supabase and on-chain
        await loadBalance();
        
      } catch (err) {
        console.error('Wallet error:', err);
        const tonEl = document.getElementById('tonWalletAddress');
        const statusEl = document.getElementById('walletStatusBar');
        
        if (tonEl) tonEl.textContent = 'Error loading';
        
        // Show user-friendly error message
        let errorMsg = 'Error loading wallet';
        let isConfigError = false;
        
        if (err.message) {
          // Check for specific error types
          if (err.message === 'SERVER_CONFIG_ERROR' || 
              err.message.includes('ENCRYPTION_KEY') || 
              err.message.includes('encryption_key_error') ||
              err.message.includes('ENCRYPTION_KEY must be exactly 64')) {
            errorMsg = 'Server configuration error. Please contact support.';
            isConfigError = true;
          } else if (err.message.includes('database_not_configured') || err.message.includes('Supabase not configured')) {
            errorMsg = 'Database not configured. Please contact support.';
            isConfigError = true;
          } else if (err.message.includes('missing_user_id') || err.message.includes('telegram_id is required')) {
            errorMsg = 'Unable to identify user. Please refresh the page.';
          } else if (err.message.includes('Failed to fetch') || err.message.includes('NetworkError')) {
            errorMsg = 'Network error. Please check your connection.';
          } else {
            // Show shortened error message
            const shortMsg = err.message.length > 60 ? err.message.substring(0, 60) + '...' : err.message;
            errorMsg = shortMsg;
          }
        }
        
        if (statusEl) {
          statusEl.textContent = errorMsg;
          if (isConfigError) {
            statusEl.style.background = 'var(--red)';
            statusEl.style.color = 'white';
          } else {
            statusEl.style.background = 'var(--accent)';
            statusEl.style.color = 'white';
          }
        }
        
        // Log full error for debugging
        console.error('Full wallet error:', err);
        console.error('Error stack:', err.stack);
      }
    }

    async function copyToClipboard(text) {
      try {
        await navigator.clipboard.writeText(text);
        hapticFeedback('light');
        return true;
      } catch (err) {
        console.error('Copy failed:', err);
        // Fallback for older browsers
        const textArea = document.createElement('textarea');
        textArea.value = text;
        textArea.style.position = 'fixed';
        textArea.style.opacity = '0';
        document.body.appendChild(textArea);
        textArea.select();
        document.execCommand('copy');
        document.body.removeChild(textArea);
        hapticFeedback('light');
        return true;
      }
    }

    function setupCopyButton(btnId, address) {
      const btn = document.getElementById(btnId);
      if (!btn || !address) return;
      
      btn.onclick = async () => {
        const success = await copyToClipboard(address);
        if (success) {
          btn.classList.add('copied');
          btn.innerHTML = `<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="20 6 9 17 4 12"></polyline></svg>`;
          
          setTimeout(() => {
            btn.classList.remove('copied');
            btn.innerHTML = `<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>`;
          }, 2000);
        }
      };
    }

    function setupClickableAddress(elementId, address) {
      const el = document.getElementById(elementId);
      if (!el || !address) return;
      
      el.onclick = async () => {
        const success = await copyToClipboard(address);
        if (success) {
          // Visual feedback
          const originalBg = el.style.background;
          el.style.background = 'var(--green-soft)';
          el.textContent = 'Copied!';
          
          setTimeout(() => {
            el.style.background = originalBg;
            el.textContent = address;
          }, 1500);
        }
      };
    }

    async function loadBalance() {
      if (!state.wallet) {
      document.getElementById('usdcBalance').textContent = '$0.00';
      document.getElementById('positionsValue').textContent = '$0.00';
      document.getElementById('totalBalance').textContent = '$0.00';
        return;
      }

      try {
        // Try to fetch balance from API
        const resp = await fetch(`/api/balances?telegram_id=${encodeURIComponent(state.telegramId)}`);
        if (resp.ok) {
          const data = await resp.json();
          if (data.success) {
            document.getElementById('usdcBalance').textContent = `$${data.usdc.toFixed(2)}`;
            document.getElementById('positionsValue').textContent = `$${data.positions.toFixed(2)}`;
            document.getElementById('totalBalance').textContent = `$${data.total.toFixed(2)}`;
            
            // Update wallet status if available
            if (data.walletStatus) {
              const statusEl = document.getElementById('walletStatusBar');
              if (statusEl) {
                if (data.walletStatus.exists) {
                  if (data.walletStatus.clobRegistered && data.walletStatus.usdcApproved) {
                    statusEl.textContent = 'âœ“ Wallet ready for trading';
                  } else if (data.walletStatus.clobRegistered) {
                    statusEl.textContent = 'âš  CLOB registered - approve USDC to trade';
                  } else {
                    statusEl.textContent = 'âš  Register with CLOB to trade';
                  }
                } else {
                  statusEl.textContent = 'âœ“ Wallets ready - fund to trade';
                }
              }
            }
            return;
          }
        }
      } catch (err) {
        console.log('[loadBalance] API not available, using defaults:', err.message);
      }

      // Fallback: show zero balances
      document.getElementById('usdcBalance').textContent = '$0.00';
      document.getElementById('positionsValue').textContent = '$0.00';
      document.getElementById('totalBalance').textContent = '$0.00';
    }

    // =====================
    // CATEGORIES
    // =====================
    function showSubFilters(category) {
      const subFiltersContainer = document.getElementById('subFilters');
      
      // Define sub-filters for each category (based on popular tags)
      const subFiltersMap = {
        'politics': ['All', 'Trump', 'Biden', 'Election', 'Breaking News'],
        'sports': ['All', 'NFL', 'NBA', 'MLB', 'NHL'],
        'crypto': ['All', 'Bitcoin', 'Ethereum', 'Solana', 'DeFi'],
        'finance': ['All', 'Fed', 'Stocks', 'Economy', 'Earnings'],
        'tech': ['All', 'AI', 'Apple', 'Google', 'Meta'],
        'geopolitics': ['All', 'Ukraine', 'Middle East', 'China', 'Russia'],
      };
      
      const filters = subFiltersMap[category.toLowerCase()];
      if (filters && filters.length > 0) {
        subFiltersContainer.innerHTML = filters.map((filter, index) => `
          <button class="sub-filter-btn ${index === 0 ? 'active' : ''}" 
                  data-filter="${filter.toLowerCase()}">
            ${filter}
          </button>
        `).join('');
        
        subFiltersContainer.style.display = 'flex';
        
        // Add click handlers
        subFiltersContainer.querySelectorAll('.sub-filter-btn').forEach(btn => {
          btn.addEventListener('click', () => {
            hapticFeedback('light');
            subFiltersContainer.querySelectorAll('.sub-filter-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            state.selectedSubFilter = btn.dataset.filter;
            // Re-fetch markets with sub-filter
            fetchMarkets(category);
          });
        });
      } else {
        subFiltersContainer.style.display = 'none';
      }
    }

    async function fetchCategories() {
      try {
        const resp = await fetch('/api/categories');
        if (resp.ok) {
          const data = await resp.json();
          return data.categories || [];
        }
      } catch (err) {
        console.error('[fetchCategories] Error:', err);
      }
      return [];
    }

    function renderCategories(categories) {
      const container = document.getElementById('categoryScroll');
      if (!container) return;

      container.innerHTML = categories.map(cat => {
        const isActive = state.selectedCategory === cat.slug;
        return `
          <button class="category-chip ${isActive ? 'active' : ''}" 
                  data-kind="${cat.slug}" 
                  data-id="${cat.id}">
            ${cat.icon} ${cat.label}
          </button>
        `;
      }).join('');

      // Add click handlers
          container.querySelectorAll('.category-chip').forEach(chip => {
            chip.addEventListener('click', () => {
              hapticFeedback('light');
              const kind = chip.dataset.kind;
              state.selectedCategory = kind;
              
              // Update active state
              container.querySelectorAll('.category-chip').forEach(c => c.classList.remove('active'));
              chip.classList.add('active');
              
              // Scroll to active chip (center it if possible)
              chip.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'center' });
              
              // If sports is clicked, show subcategories instead of markets
              if (kind === 'sports') {
                showSportsSubcategories();
              } else {
                // Fetch markets for this category
                fetchMarkets(kind);
                // Show sub-filters if available for this category
                showSubFilters(kind);
              }
            });
          });
    }

    async function showSportsSubcategories() {
      // Show Games and Props as top-level sports subcategories
      const list = document.getElementById('marketsList');
      list.innerHTML = `
        <div style="margin-bottom: 16px; font-size: 14px; color: var(--text-muted);">
          Select a category:
        </div>
        <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px;">
          <button class="category-chip" 
                  data-sport-type="games" 
                  style="width: 100%; justify-content: flex-start; padding: 12px 16px;">
            Games
          </button>
          <button class="category-chip" 
                  data-sport-type="props" 
                  style="width: 100%; justify-content: flex-start; padding: 12px 16px;">
            Props
          </button>
        </div>
      `;
      
      // Add click handlers for Games and Props
          list.querySelectorAll('.category-chip').forEach(btn => {
            btn.addEventListener('click', () => {
              hapticFeedback('light');
              const sportType = btn.dataset.sportType;
              state.selectedSportType = sportType;
              showSportsByType(sportType);
            });
          });
    }

    async function showSportsByType(type) {
      // type is either "games" or "props"
      try {
        const resp = await fetch('/api/sports-subcategories');
        if (resp.ok) {
          const data = await resp.json();
          const subcategories = data.subcategories || [];
          
          if (subcategories.length > 0) {
            // Render sports subcategories in the markets list area
            const list = document.getElementById('marketsList');
            list.innerHTML = `
              <div style="margin-bottom: 16px; font-size: 14px; color: var(--text-muted);">
                Select a sport:
              </div>
              <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px;">
                ${subcategories.map(sub => `
                  <button class="category-chip" 
                          data-sport="${sub.slug}" 
                          data-sport-type="${type}"
                          style="width: 100%; justify-content: flex-start; padding: 12px 16px;">
                    ${sub.label}
                  </button>
                `).join('')}
              </div>
            `;
            
            // Add click handlers for sports subcategories
            list.querySelectorAll('.category-chip').forEach(btn => {
              btn.addEventListener('click', () => {
                hapticFeedback('light');
                const sportSlug = btn.dataset.sport;
                const sportType = btn.dataset.sportType;
                state.selectedCategory = sportSlug;
                state.selectedSportType = sportType;
                // Fetch markets for this sport, passing sportType to filter games vs props
                fetchMarkets(sportSlug, sportType);
              });
            });
          } else {
            // Fallback: fetch sports markets directly
            fetchMarkets('sports');
          }
        } else {
          // Fallback: fetch sports markets directly
          fetchMarkets('sports');
        }
      } catch (err) {
        console.error('[showSportsByType] Error:', err);
        // Fallback: fetch sports markets directly
        fetchMarkets('sports');
      }
    }

    // =====================
    // MARKETS
    // =====================
    async function fetchMarkets(kind = 'trending', sportType = null) {
      const list = document.getElementById('marketsList');
      list.innerHTML = '<div class="loading">Loading markets...</div>';

      try {
        // #region agent log
        fetch('http://127.0.0.1:7243/ingest/cf0ac01b-cbf1-4c16-aaa3-32490620eb9e',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'index.html:2588',message:'fetchMarkets called',data:{kind, sportType, selectedCategory: state.selectedCategory},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'A'})}).catch(()=>{});
        // #endregion
        console.log('[fetchMarkets] Fetching:', kind, 'sportType:', sportType);
        // Reduce limit for faster loading - 1000 markets is plenty for initial display
        // Only show markets with volume - filter out zero-volume markets (use $0.01 minimum)
        let apiUrl = `/api/markets?kind=${kind}&limit=1000&minVolume=0.01`;
        if (sportType) {
          apiUrl += `&sportType=${sportType}`;
        }
        console.log('[fetchMarkets] URL:', apiUrl);
        
        // #region agent log
        fetch('http://127.0.0.1:7243/ingest/cf0ac01b-cbf1-4c16-aaa3-32490620eb9e',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'index.html:2596',message:'API request URL',data:{apiUrl},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'B'})}).catch(()=>{});
        // #endregion
        const resp = await fetch(apiUrl);
        console.log('[fetchMarkets] Status:', resp.status, resp.statusText);
        
        if (!resp.ok) {
          const errorText = await resp.text();
          console.error('[fetchMarkets] Error response:', errorText);
          throw new Error(`HTTP ${resp.status}: ${errorText.substring(0, 100)}`);
        }
        
        const data = await resp.json();
        // #region agent log
        fetch('http://127.0.0.1:7243/ingest/cf0ac01b-cbf1-4c16-aaa3-32490620eb9e',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'index.html:2611',message:'API response received',data:{marketCount: data.markets?.length || 0, meta: data.meta, firstMarketQuestion: data.markets?.[0]?.question, firstMarketCategory: data.markets?.[0]?.eventTitle},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'C'})}).catch(()=>{});
        // #endregion
        console.log('[fetchMarkets] Response data:', data);
        console.log('[fetchMarkets] Markets count:', data.markets?.length || 0);
        
        const markets = data.markets || [];
        
        if (markets.length > 0) {
          // #region agent log
          fetch('http://127.0.0.1:7243/ingest/cf0ac01b-cbf1-4c16-aaa3-32490620eb9e',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'index.html:2617',message:'Markets before render',data:{marketCount: markets.length, sampleMarkets: markets.slice(0, 3).map(m => ({question: m.question, eventTitle: m.eventTitle, volume: m.volume24hr}))},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'D'})}).catch(()=>{});
          // #endregion
          console.log('[fetchMarkets] First market:', markets[0]);
          state.markets = markets;
          renderMarkets(markets);
        } else {
          console.log('[fetchMarkets] No markets in response');
          list.innerHTML = `<div class="loading">No markets found. <br><small style="color:var(--text-muted)">API responded but returned 0 markets</small></div>`;
        }
      } catch (err) {
        // #region agent log
        fetch('http://127.0.0.1:7243/ingest/cf0ac01b-cbf1-4c16-aaa3-32490620eb9e',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'index.html:2625',message:'fetchMarkets error',data:{error: err.message, stack: err.stack},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'E'})}).catch(()=>{});
        // #endregion
        console.error('[fetchMarkets] Error:', err);
        list.innerHTML = `
          <div class="loading" style="color:#d97777;">
            Failed to load markets<br>
            <small style="color:var(--text-muted)">${err.message}</small>
          </div>
        `;
      }
    }

    function renderMarkets(markets) {
      const list = document.getElementById('marketsList');
      
      // Check if we should group by events (for NFL games)
      const shouldGroupByEvent = state.selectedCategory === 'nfl' && 
                                  markets.some(m => m.eventId && m.eventTitle);
      
      if (shouldGroupByEvent && markets.length > 0) {
        // Group markets by event
        const eventsMap = new Map();
        markets.forEach(m => {
          const eventId = m.eventId || 'ungrouped';
          const eventTitle = m.eventTitle || 'Other Markets';
          
          if (!eventsMap.has(eventId)) {
            eventsMap.set(eventId, {
              eventId: eventId,
              eventTitle: eventTitle,
              eventImage: m.eventImage || m.image,
              eventVolume: m.eventVolume || 0,
              eventStartDate: m.eventStartDate,
              markets: []
            });
          }
          eventsMap.get(eventId).markets.push(m);
        });
        
        // Sort events by volume (highest first) before rendering
        const sortedEvents = Array.from(eventsMap.values()).sort((a, b) => {
          const volA = a.eventVolume || a.markets.reduce((sum, m) => sum + (m.volume24hr || m.volume || 0), 0);
          const volB = b.eventVolume || b.markets.reduce((sum, m) => sum + (m.volume24hr || m.volume || 0), 0);
          return volB - volA;
        });
        
        // Render events with their markets
        list.innerHTML = sortedEvents.map(event => {
          const eventVol = event.eventVolume || 
                          event.markets.reduce((sum, m) => sum + (m.volume24hr || m.volume || 0), 0);
          const eventImg = event.eventImage || event.markets[0]?.image || '';
          const hasImage = eventImg && eventImg.trim() !== '';
          
          // Get week tag if available
          const weekTag = event.markets[0]?.eventTags?.find(t => 
            (typeof t === 'string' ? t : (t.slug || t.label || '')).toLowerCase().includes('week')
          );
          const weekLabel = weekTag ? (typeof weekTag === 'string' ? weekTag : (weekTag.label || weekTag.slug || '')) : '';
          
          // Find primary moneyline market (the main game outcome)
          const moneylineMarket = event.markets.find(m => {
            const q = (m.question || '').toLowerCase();
            return q.includes('moneyline') || q.includes('ml') || 
                   (q.includes(' vs ') && !q.includes('spread') && !q.includes('total') && !q.includes('o/u'));
          }) || event.markets[0];
          
          // Get primary prices for moneyline (first two outcomes)
          const primaryPrices = moneylineMarket?.outcomePrices || [];
          const primaryOutcomes = moneylineMarket?.outcomes || [];
          const price1 = primaryPrices[0] !== undefined ? (parseFloat(primaryPrices[0]) * 100).toFixed(0) + 'Â¢' : '--';
          const price2 = primaryPrices[1] !== undefined ? (parseFloat(primaryPrices[1]) * 100).toFixed(0) + 'Â¢' : '--';
          const outcome1 = primaryOutcomes[0] || 'Yes';
          const outcome2 = primaryOutcomes[1] || 'No';
          
          return `
            <div class="event-group collapsed" data-event-id="${event.eventId}">
              <div class="event-header collapsed" data-collapse-target="${event.eventId}">
                ${hasImage ? `<img class="event-image" src="${eventImg}" alt="" onerror="this.classList.add('hidden')" />` : ''}
                <div class="event-info">
                  <div class="event-title">
                    ${weekLabel ? `<span class="week-tag">${weekLabel}</span>` : ''}
                    <span class="event-title-text">${event.eventTitle}</span>
                  </div>
                  <div class="event-meta">
                    <span>Vol: ${formatVolume(eventVol)}</span>
                    <span>${event.markets.length} market${event.markets.length !== 1 ? 's' : ''}</span>
                  </div>

                </div>
                <div class="event-primary-prices">
                  ${primaryPrices.length >= 2 ? `
                    <button class="event-price-btn event-price-btn-1" 
                            data-market-id="${moneylineMarket?.id}" 
                            data-outcome-index="0">
                      ${outcome1} ${price1}
                    </button>
                    <button class="event-price-btn event-price-btn-2" 
                            data-market-id="${moneylineMarket?.id}" 
                            data-outcome-index="1">
                      ${outcome2} ${price2}
                    </button>
                  ` : ''}
                </div>
                <div class="event-collapse-icon">â–¼</div>
              </div>
              <div class="event-markets" data-event-markets="${event.eventId}">
                ${event.markets.map(m => {
                  const prices = m.outcomePrices || [];
                  const outcomes = m.outcomes || ["Yes", "No"];
                  const vol = m.volume24hr || m.volume || 0;
                  
                  return `
                    <div class="market-outcome-item" data-id="${m.id}" data-market-id="${m.id}" style="cursor: pointer;">
                      <div class="outcome-label">${m.question}</div>
                      <div class="outcome-buttons">
                        ${outcomes.map((outcome, idx) => {
                          const price = prices[idx] !== undefined ? (parseFloat(prices[idx]) * 100).toFixed(0) + 'Â¢' : '--';
                          const isYes = outcome.toLowerCase() === 'yes' || idx === 0;
                          return `
                            <div class="outcome-button-group">
                              <span class="outcome-price">${price}</span>
                              <button class="outcome-btn ${isYes ? 'outcome-yes' : 'outcome-no'}" 
                                      data-market-id="${m.id}" 
                                      data-outcome-index="${idx}">
                                ${outcome}
                              </button>
                            </div>
                          `;
                        }).join('')}
                      </div>
                    </div>
                  `;
                }).join('')}
              </div>
            </div>
          `;
        }).join('');
      } else {
        // Render as flat list (original behavior)
      list.innerHTML = markets.map(m => {
        const prices = m.outcomePrices || [];
          const outcomes = m.outcomes || ["Yes", "No"];
        const vol = m.volume24hr || m.volume || 0;
          const imgUrl = m.image || m.eventImage || m.icon || '';
          const hasImage = imgUrl && imgUrl.trim() !== '';
        
        return `
            <div class="market-card" data-id="${m.id}">
              <div class="market-card-header">
                ${hasImage ? `<img class="market-image" src="${imgUrl}" alt="" onerror="this.classList.add('hidden')" />` : ''}
                <div class="market-title">${m.question}</div>
              </div>
              <div class="market-outcomes">
                ${outcomes.map((outcome, idx) => {
                  const price = prices[idx] !== undefined ? (parseFloat(prices[idx]) * 100).toFixed(0) + 'Â¢' : '--';
                  const isYes = outcome.toLowerCase() === 'yes' || idx === 0;
                  return `
                    <div class="outcome-button-group">
                      <span class="outcome-price">${price}</span>
                      <button class="outcome-btn ${isYes ? 'outcome-yes' : 'outcome-no'}" 
                              data-market-id="${m.id}" 
                              data-outcome-index="${idx}">
                        ${outcome}
                      </button>
            </div>
                  `;
                }).join('')}
              </div>
              <div class="market-card-footer">
                <span class="market-volume">${formatVolume(vol)} Vol.</span>
                <span class="market-icon">ðŸŽ</span>
            </div>
          </div>
        `;
      }).join('');
      }

      // Add click handlers for event price buttons
      list.querySelectorAll('.event-price-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.stopPropagation();
          hapticFeedback('light');
          const marketId = btn.dataset.marketId;
          const outcomeIndex = parseInt(btn.dataset.outcomeIndex, 10);
          const market = markets.find(m => String(m.id) === String(marketId));
          if (market) {
            openTradeModal(market, outcomeIndex);
          }
        });
      });
      
      // Add click handlers for event price buttons - open detail view
      list.querySelectorAll('.event-price-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.stopPropagation();
          hapticFeedback('light');
          const marketId = btn.dataset.marketId;
          const market = markets.find(m => String(m.id) === String(marketId));
          if (market) {
            openMarketDetail(market);
          }
        });
      });
      
      // Add click handlers for market cards - open detail view
      list.querySelectorAll('.market-card, .market-outcome-item').forEach(item => {
        item.addEventListener('click', (e) => {
          // Don't open detail if clicking on outcome buttons
          if (e.target.closest('.outcome-btn')) {
            return;
          }
          hapticFeedback('light');
          const marketId = item.dataset.id || item.dataset.marketId;
          const market = markets.find(m => String(m.id) === String(marketId));
          if (market) {
            openMarketDetail(market);
          }
        });
      });
      
      // Add click handlers for event header collapse/expand
      list.querySelectorAll('.event-header').forEach(header => {
        header.addEventListener('click', (e) => {
          // Don't collapse if clicking on interactive elements
          if (e.target.closest('.outcome-btn') || e.target.closest('.event-price-btn') || e.target.closest('button') || e.target.closest('a')) {
            return;
          }
          
          hapticFeedback('light');
          const eventId = header.dataset.collapseTarget;
          const eventGroup = header.closest('.event-group');
          
          if (eventGroup) {
            eventGroup.classList.toggle('collapsed');
            header.classList.toggle('collapsed');
          }
        });
      });
      
      // Prevent nested market clicks from collapsing
      list.querySelectorAll('.event-markets .market-outcome-item').forEach(item => {
        item.addEventListener('click', (e) => {
          e.stopPropagation();
        });
      });

      // Add click handlers for outcome buttons
      list.querySelectorAll('.outcome-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.stopPropagation();
          hapticFeedback('light');
          const marketId = btn.dataset.marketId;
          const outcomeIndex = parseInt(btn.dataset.outcomeIndex);
          const market = markets.find(m => String(m.id) === marketId || String(m.conditionId) === marketId);
          if (market) {
            state.selectedOutcomeIndex = outcomeIndex;
            openTradeModal(market);
          }
        });
      });

      // Add click handlers for market cards (fallback)
      list.querySelectorAll('.market-card, .market-item').forEach(item => {
        item.addEventListener('click', (e) => {
          if (!e.target.closest('.outcome-btn')) {
            hapticFeedback('light');
            const itemId = String(item.dataset.id);
            const market = markets.find(m => String(m.id) === itemId || String(m.conditionId) === itemId);
          if (market) openTradeModal(market);
          }
        });
      });
    }

    // =====================
    // TRADE MODAL
    // =====================
    function openMarketDetail(market) {
      hapticFeedback('medium');
      state.selectedMarket = market;
      
      // Hide main app, show detail view
      document.getElementById('appShell').style.display = 'none';
      document.getElementById('marketDetailView').style.display = 'block';
      
      // Populate detail view
      const title = document.getElementById('marketDetailTitle');
      title.textContent = market.question || market.eventTitle || 'Market Details';
      
      const volume = document.getElementById('marketDetailVolume');
      const vol = market.volume24hr || market.volume || 0;
      volume.textContent = `$${formatVolume(vol)} Vol.`;
      
      const event = document.getElementById('marketDetailEvent');
      if (market.eventTitle) {
        event.innerHTML = `
          ${market.eventImage ? `<img src="${market.eventImage}" alt="" />` : ''}
          <span>${market.eventTitle}</span>
        `;
      } else {
        event.innerHTML = '';
      }
      
      // Render outcomes list
      const outcomesList = document.getElementById('marketDetailOutcomesList');
      const outcomes = market.outcomes || ["Yes", "No"];
      const prices = market.outcomePrices || [];
      const colors = ['blue', 'green', 'orange', 'red', 'purple', 'pink'];
      
      outcomesList.innerHTML = outcomes.map((outcome, index) => {
        const price = prices[index] !== undefined ? parseFloat(prices[index]) : 0.5;
        const percent = (price * 100).toFixed(1);
        const color = colors[index % colors.length];
        const isSelected = index === 0;
        
        return `
          <div class="outcome-item ${isSelected ? 'selected' : ''}" 
               data-outcome-index="${index}"
               data-outcome="${outcome}">
            <div class="outcome-dot ${color}"></div>
            <div class="outcome-label">${outcome}</div>
            <div class="outcome-percent">${percent}%</div>
          </div>
        `;
      }).join('');
      
      // Add click handlers for outcomes
      outcomesList.querySelectorAll('.outcome-item').forEach(item => {
        item.addEventListener('click', () => {
          outcomesList.querySelectorAll('.outcome-item').forEach(i => i.classList.remove('selected'));
          item.classList.add('selected');
          updateMarketDetailSelectedOutcome(market, parseInt(item.dataset.outcomeIndex));
        });
      });
      
      // Set default selected outcome
      if (outcomes.length > 0) {
        updateMarketDetailSelectedOutcome(market, 0);
      }
      
      // Initialize graph
      initializeMarketGraph(market);
      
      // Setup buy buttons
      setupMarketDetailBuyButtons(market);
    }
    
    function updateMarketDetailSelectedOutcome(market, outcomeIndex) {
      const outcomes = market.outcomes || ["Yes", "No"];
      const prices = market.outcomePrices || [];
      const outcome = outcomes[outcomeIndex] || 'Yes';
      const price = prices[outcomeIndex] !== undefined ? parseFloat(prices[outcomeIndex]) : 0.5;
      const percent = (price * 100).toFixed(1);
      
      document.getElementById('selectedOutcomeName').textContent = outcome;
      document.getElementById('selectedOutcomePercent').textContent = `${percent}%`;
      document.getElementById('selectedOutcomeVolume').textContent = '$0 Vol.'; // TODO: Get actual volume for this outcome
    }
    
    function initializeMarketGraph(market) {
      const canvas = document.getElementById('marketDetailGraph');
      if (!canvas) return;
      
      const ctx = canvas.getContext('2d');
      const outcomes = market.outcomes || ["Yes", "No"];
      const prices = market.outcomePrices || [];
      
      // Set canvas size based on container
      const container = canvas.parentElement;
      canvas.width = container.clientWidth - 32; // Account for padding
      canvas.height = 200;
      
      let currentRange = 'ALL';
      let historicalData = null;
      
      // Fetch historical data from API
      async function fetchHistoricalData(range = 'ALL') {
        try {
          const marketId = market.id || market.conditionId;
          if (!marketId) {
            console.log("[market-detail] No market ID, using mock data");
            return null;
          }
          
          const resp = await fetch(`/api/market-history?marketId=${marketId}&range=${range}`);
          if (resp.ok) {
            const data = await resp.json();
            // Store current prices from API response for graph
            if (data.currentPrices && Array.isArray(data.currentPrices)) {
              // Update prices array to match API response
              data.currentPrices.forEach((price, idx) => {
                if (prices[idx] !== undefined) {
                  prices[idx] = price;
                }
              });
            }
            return data.history || null;
          } else {
            console.log("[market-detail] Historical data API failed, using mock data");
            return null;
          }
        } catch (err) {
          console.log("[market-detail] Error fetching historical data:", err);
          return null;
        }
      }
      
      function drawGraph(range = 'ALL', historyData = null) {
        const width = canvas.width;
        const height = canvas.height;
        
        // Resize canvas if needed
        if (canvas.width !== container.clientWidth - 32) {
          canvas.width = container.clientWidth - 32;
        }
        
        ctx.clearRect(0, 0, width, height);
        
        // Get current market prices (these are the "now" values)
        const currentPrices = prices.map(p => parseFloat(p) || 0);
        
        // Draw grid
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
        ctx.lineWidth = 1;
        for (let i = 0; i <= 10; i++) {
          const y = (height / 10) * i;
          ctx.beginPath();
          ctx.moveTo(0, y);
          ctx.lineTo(width, y);
          ctx.stroke();
        }
        
        // Draw Y-axis labels (percentages)
        ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
        ctx.font = '10px sans-serif';
        for (let i = 0; i <= 10; i++) {
          const percent = 100 - (i * 10);
          const y = (height / 10) * i;
          ctx.fillText(`${percent}%`, 4, y + 4);
        }
        
        // Draw lines for each outcome (using new color scheme)
        const colors = ['#687E90', '#4B4B4B', '#5b5b5b', '#6b6b6b', '#7b7b7b', '#8b8b8b'];
        
        if (historyData && historyData.length > 0) {
          // Use real historical data from API
          historyData.forEach((outcomeHistory, index) => {
            const color = colors[index % colors.length];
            const dataPoints = outcomeHistory.data || [];
            const currentPrice = currentPrices[index] || 0;
            
            if (dataPoints.length === 0) {
              // No history, draw flat line at current price
              const y = height - (currentPrice * height);
              ctx.strokeStyle = color;
              ctx.lineWidth = 2;
              ctx.beginPath();
              ctx.moveTo(0, y);
              ctx.lineTo(width, y);
              ctx.stroke();
              return;
            }
            
            // Find min/max timestamps for scaling
            const timestamps = dataPoints.map(p => p.timestamp);
            const minTime = Math.min(...timestamps);
            const maxTime = Math.max(...timestamps);
            const timeRange = maxTime - minTime || 1; // Avoid division by zero
            
            // Ensure the graph ends at current price (rightmost point)
            const now = Date.now();
            const historicalPoints = [...dataPoints];
            
            // Add current price as the final point (rightmost)
            historicalPoints.push({
              timestamp: now,
              price: currentPrice,
              volume: 0,
              liquidity: 0
            });
            
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            historicalPoints.forEach((point, i) => {
              // Scale X: 0 to width, with current time at the right edge
              const x = timeRange > 0 
                ? ((point.timestamp - minTime) / (now - minTime)) * width
                : width; // If no time range, put at end
              
              // Scale Y: price (0-1) to canvas height (0 at top, 100% at bottom)
              const y = height - (point.price * height);
              
              // Clamp to canvas bounds
              const clampedX = Math.max(0, Math.min(width, x));
              const clampedY = Math.max(0, Math.min(height, y));
              
              if (i === 0) {
                ctx.moveTo(clampedX, clampedY);
              } else {
                ctx.lineTo(clampedX, clampedY);
              }
            });
            
            ctx.stroke();
            
            // Draw current price indicator (rightmost point)
            const currentY = height - (currentPrice * height);
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(width, currentY, 4, 0, Math.PI * 2);
            ctx.fill();
          });
        } else {
          // Fallback: Draw lines that end at current market prices
          outcomes.forEach((outcome, index) => {
            const color = colors[index % colors.length];
            const currentPrice = currentPrices[index] || 0.5;
            
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            const points = 100;
            for (let i = 0; i < points; i++) {
              const x = (width / points) * i;
              // Simulate price movement that trends toward current price
              const progress = i / points;
              // Start from a reasonable baseline (around 0.5 or opposite of current)
              const startPrice = index === 0 ? 0.5 : (1 - currentPrice);
              // Interpolate from start to current price
              const price = startPrice + (currentPrice - startPrice) * progress;
              // Add some realistic variation
              const variation = (Math.sin(i / 10) * 0.05) * (1 - progress); // Less variation near end
              const finalPrice = Math.max(0.01, Math.min(0.99, price + variation));
              const y = height - (finalPrice * height);
              
              if (i === 0) {
                ctx.moveTo(x, y);
              } else {
                ctx.lineTo(x, y);
              }
            }
            
            ctx.stroke();
            
            // Draw current price indicator (rightmost point)
            const currentY = height - (currentPrice * height);
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(width, currentY, 4, 0, Math.PI * 2);
            ctx.fill();
          });
        }
        
        // Draw current price labels on right side
        ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
        ctx.font = '11px sans-serif';
        ctx.textAlign = 'right';
        outcomes.forEach((outcome, index) => {
          const currentPrice = currentPrices[index] || 0;
          const percent = (currentPrice * 100).toFixed(0);
          const y = height - (currentPrice * height);
          // Offset label slightly above/below the point
          const labelY = index % 2 === 0 ? y - 8 : y + 16;
          ctx.fillText(`${percent}%`, width - 4, labelY);
        });
        ctx.textAlign = 'left'; // Reset alignment
      }
      
      // Time range selector handlers
      document.querySelectorAll('.time-selector').forEach(btn => {
        btn.addEventListener('click', async () => {
          document.querySelectorAll('.time-selector').forEach(b => b.classList.remove('active'));
          btn.classList.add('active');
          currentRange = btn.dataset.range;
          
          // Fetch new historical data for selected range
          historicalData = await fetchHistoricalData(currentRange);
          drawGraph(currentRange, historicalData);
        });
      });
      
      // Initial load
      (async () => {
        historicalData = await fetchHistoricalData(currentRange);
        drawGraph(currentRange, historicalData);
      })();
    }
    
    function setupMarketDetailBuyButtons(market) {
      const outcomes = market.outcomes || ["Yes", "No"];
      const prices = market.outcomePrices || [];
      
      // Setup Yes button (first outcome)
      const buyYesBtn = document.getElementById('marketDetailBuyYes');
      const yesPrice = prices[0] !== undefined ? (parseFloat(prices[0]) * 100).toFixed(0) : '50';
      document.getElementById('buyYesOutcome').textContent = outcomes[0] || 'Yes';
      document.getElementById('buyYesPrice').textContent = `${yesPrice}Â¢`;
      
      buyYesBtn.addEventListener('click', () => {
        hapticFeedback('medium');
        state.selectedOutcomeIndex = 0;
        state.tradeSide = outcomes[0] || 'Yes';
        closeMarketDetail();
        openTradeModal(market);
      });
      
      // Setup No button (second outcome if exists, otherwise opposite)
      const buyNoBtn = document.getElementById('marketDetailBuyNo');
      const noIndex = outcomes.length > 1 ? 1 : 0;
      const noPrice = prices[noIndex] !== undefined ? (parseFloat(prices[noIndex]) * 100).toFixed(0) : '50';
      document.getElementById('buyNoOutcome').textContent = outcomes[noIndex] || 'No';
      document.getElementById('buyNoPrice').textContent = `${noPrice}Â¢`;
      
      buyNoBtn.addEventListener('click', () => {
        hapticFeedback('medium');
        state.selectedOutcomeIndex = noIndex;
        state.tradeSide = outcomes[noIndex] || 'No';
        closeMarketDetail();
        openTradeModal(market);
      });
    }
    
    function closeMarketDetail() {
      document.getElementById('marketDetailView').style.display = 'none';
      document.getElementById('appShell').style.display = 'block';
    }
    
    // Back button handler
    document.getElementById('marketDetailBack')?.addEventListener('click', () => {
      hapticFeedback('light');
      closeMarketDetail();
    });
    
    // Share button handler
    document.getElementById('marketDetailShare')?.addEventListener('click', () => {
      hapticFeedback('light');
      if (navigator.share && state.selectedMarket) {
        navigator.share({
          title: state.selectedMarket.question,
          text: `Check out this market on Polygram`,
          url: window.location.href
        }).catch(() => {
          // Fallback: copy to clipboard
          navigator.clipboard.writeText(window.location.href);
        });
      } else {
        navigator.clipboard.writeText(window.location.href);
      }
    });
    
    // Bookmark button handler
    document.getElementById('marketDetailBookmark')?.addEventListener('click', () => {
      hapticFeedback('light');
      // TODO: Implement bookmark functionality
      const btn = document.getElementById('marketDetailBookmark');
      btn.classList.toggle('bookmarked');
    });

    function openTradeModal(market, outcomeIndex) {
      hapticFeedback('medium');
      state.selectedMarket = market;
      
      // Use provided outcomeIndex or default
      if (outcomeIndex !== undefined) {
        state.selectedOutcomeIndex = outcomeIndex;
      }

      // Get all outcomes and prices
      const outcomes = market.outcomes || ["Yes", "No"];
      const prices = market.outcomePrices || [];
      
      // Set market image and question
      const marketImg = document.getElementById('tradeMarketImg');
      const imgUrl = market.image || market.icon || '';
      if (imgUrl) {
        marketImg.src = imgUrl;
        marketImg.style.display = 'block';
      } else {
        marketImg.style.display = 'none';
      }
      document.getElementById('tradeMarketQuestion').textContent = market.question;
      
      // Render all outcomes with percentages
      const outcomesContainer = document.getElementById('tradeOutcomes');
      outcomesContainer.innerHTML = outcomes.map((outcome, index) => {
        // Use 0.5 as fallback to match updateTradeSummary logic
        const price = prices[index] ? parseFloat(prices[index]) : 0.5;
        const percent = (price * 100).toFixed(0);
        const priceCents = (price * 100).toFixed(0);
        const isActive = index === 0; // Default to first outcome
        
        return `
          <div class="trade-outcome ${isActive ? 'active' : ''}" 
               data-outcome-index="${index}" 
               data-outcome="${outcome}">
            <div class="trade-outcome-left">
              <div class="trade-outcome-label">${outcome}</div>
              <div class="trade-outcome-percent">${percent}%</div>
            </div>
            <div class="trade-outcome-price">${priceCents}Â¢</div>
          </div>
        `;
      }).join('');
      
      // Set default selected outcome
      if (outcomes.length > 0) {
        state.tradeSide = outcomes[0];
        state.selectedOutcomeIndex = 0;
      }
      
      // Add click handlers for outcomes
      outcomesContainer.querySelectorAll('.trade-outcome').forEach(outcomeEl => {
        outcomeEl.addEventListener('click', () => {
          // Remove active from all
          outcomesContainer.querySelectorAll('.trade-outcome').forEach(o => o.classList.remove('active'));
          // Add active to clicked
          outcomeEl.classList.add('active');
          
          state.selectedOutcomeIndex = parseInt(outcomeEl.dataset.outcomeIndex);
          state.tradeSide = outcomeEl.dataset.outcome;
          
          updateTradeSummary();
        });
      });
      
      document.getElementById('tradeAmount').value = '';
      updateTradeSummary();
      
      document.getElementById('tradeModal').classList.add('visible');
    }

    function closeTradeModal() {
      hapticFeedback('light');
      document.getElementById('tradeModal').classList.remove('visible');
      state.selectedMarket = null;
    }

    function updateTradeSummary() {
      const amount = parseFloat(document.getElementById('tradeAmount').value) || 0;
      const prices = state.selectedMarket?.outcomePrices || [];
      const priceIdx = state.selectedOutcomeIndex !== undefined 
        ? state.selectedOutcomeIndex 
        : (state.tradeSide === 'yes' ? 0 : 1);
      const price = prices[priceIdx] ? parseFloat(prices[priceIdx]) : 0.5;
      const outcomeLabel = state.selectedMarket?.outcomes?.[priceIdx] || state.tradeSide || 'Yes';
      
      const shares = price > 0 ? (amount / price).toFixed(2) : 0;
      const potential = (shares * 1).toFixed(2);
      
      document.getElementById('tradeShares').textContent = shares;
      document.getElementById('tradeAvgPrice').textContent = `${(price * 100).toFixed(0)}Â¢`;
      document.getElementById('tradePotential').textContent = `$${potential}`;
      
      const btn = document.getElementById('tradeSubmit');
      if (state.wallet && amount > 0) {
        btn.disabled = false;
        btn.textContent = `Buy ${outcomeLabel} Â· $${amount.toFixed(2)}`;
      } else if (!state.wallet) {
        btn.disabled = true;
        btn.textContent = 'Create Wallet First';
      } else {
        btn.disabled = true;
        btn.textContent = 'Enter Amount';
      }
    }

    // =====================
    // FUNDING
    // =====================
    function openFundModal() {
      hapticFeedback('medium');
      const modal = document.getElementById('fundModal');
      
      // Check if TON wallet is connected
      if (!state.wallet || !state.wallet.ton) {
        alert('Please connect your TON wallet first. Click "Connect TON" in the wallet section.');
        return;
      }

      // Update TON wallet status in modal
      const tonStatusText = document.getElementById('tonWalletStatusText');
      const tonAddressDisplay = document.getElementById('tonWalletAddressDisplay');
      const tonConnectArea = document.getElementById('tonConnectButtonArea');
      
      if (tonStatusText) {
        tonStatusText.textContent = 'Connected';
        tonStatusText.style.color = 'var(--green)';
      }
      
      if (tonAddressDisplay && state.wallet.ton) {
        tonAddressDisplay.textContent = state.wallet.ton;
        tonAddressDisplay.style.display = 'block';
      }
      
      if (tonConnectArea) {
        tonConnectArea.innerHTML = '<p style="color: var(--text-muted); font-size: 12px;">âœ“ TON wallet connected</p>';
      }

      document.getElementById('fundAmount').value = '';
      modal.classList.add('visible');
    }

    function closeFundModal() {
      hapticFeedback('light');
      document.getElementById('fundModal').classList.remove('visible');
    }

    // =====================
    // WITHDRAWAL
    // =====================
    // Epic 5.1: Withdraw Funds to TON
    function openWithdrawModal() {
      hapticFeedback('medium');
      const modal = document.getElementById('withdrawModal');
      
      // Check if user is authenticated
      if (!state.sessionToken && !localStorage.getItem('session_token')) {
        alert('Please connect your TON wallet and authenticate first.');
        return;
      }

      // Update balance display
      updateWithdrawBalance();
      
      // Pre-fill TON address if wallet is connected
      const tonAddressInput = document.getElementById('withdrawTONAddress');
      if (state.wallet && state.wallet.ton && tonAddressInput) {
        tonAddressInput.value = state.wallet.ton;
      }

      document.getElementById('withdrawAmount').value = '';
      modal.classList.add('visible');
    }

    function closeWithdrawModal() {
      hapticFeedback('light');
      document.getElementById('withdrawModal').classList.remove('visible');
    }

    async function updateWithdrawBalance() {
      try {
        // Get balance from state or API
        const balanceEl = document.getElementById('withdrawAvailableBalance');
        if (balanceEl) {
          // Try to get from already loaded balance
          const usdcBalanceEl = document.getElementById('usdcBalance');
          if (usdcBalanceEl) {
            const balanceText = usdcBalanceEl.textContent.replace('$', '').replace(',', '');
            balanceEl.textContent = `$${parseFloat(balanceText || 0).toFixed(2)}`;
          } else {
            balanceEl.textContent = '$0.00';
          }
        }

        // Update fees and receive amount estimates
        const amountInput = document.getElementById('withdrawAmount');
        if (amountInput) {
          amountInput.addEventListener('input', () => {
            const amount = parseFloat(amountInput.value) || 0;
            const fees = 0.50; // Mock fees
            const receiveTON = (amount - fees) / 2.5; // Mock conversion rate: 1 TON = $2.50
            
            const feesEl = document.getElementById('withdrawFees');
            const receiveEl = document.getElementById('withdrawReceiveAmount');
            
            if (feesEl) feesEl.textContent = `~$${fees.toFixed(2)}`;
            if (receiveEl) receiveEl.textContent = amount > 0 ? `~${receiveTON.toFixed(4)} TON` : '0 TON';
          });
        }
      } catch (err) {
        console.error('[updateWithdrawBalance] Error:', err);
      }
    }

    async function submitWithdrawal() {
      const amount = parseFloat(document.getElementById('withdrawAmount').value);
      const tonAddress = document.getElementById('withdrawTONAddress')?.value?.trim();

      if (!amount || amount <= 0) {
        hapticFeedback('error');
        alert('Please enter a valid amount');
        return;
      }

      if (amount < 1) {
        hapticFeedback('error');
        alert('Minimum withdrawal amount is $1 USDC');
        return;
      }

      if (!tonAddress) {
        hapticFeedback('error');
        alert('Please enter a TON destination address');
        return;
      }

      // Basic TON address validation
      if (!tonAddress.match(/^[0-9A-Za-z_-]{48}$/)) {
        hapticFeedback('error');
        alert('Invalid TON address format');
        return;
      }

      const submitBtn = document.getElementById('withdrawSubmitBtn');
      const originalText = submitBtn.textContent;
      submitBtn.disabled = true;
      submitBtn.textContent = 'Processing...';
      hapticFeedback('medium');

      try {
        const sessionToken = state.sessionToken || localStorage.getItem('session_token');
        if (!sessionToken) {
          throw new Error('Session expired. Please reconnect your TON wallet.');
        }

        // Generate idempotency key
        const idempotencyKey = `withdraw_${state.telegramId}_${Date.now()}`;

        const resp = await fetch('/api/withdraw/request', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${sessionToken}`
          },
          body: JSON.stringify({
            amount_usdc: amount,
            ton_destination_address: tonAddress,
            idempotency_key: idempotencyKey
            // TODO: Add address signature confirmation (Epic 5.2)
          })
        });

        const data = await resp.json();

        if (!resp.ok) {
          if (resp.status === 401) {
            throw new Error('Session expired. Please reconnect your TON wallet.');
          } else if (resp.status === 429) {
            throw new Error('Too many withdrawal requests. Please wait a moment.');
          } else if (resp.status === 400 && data.error === 'insufficient_balance') {
            throw new Error(data.message || 'Insufficient balance for this withdrawal.');
          } else if (resp.status === 400 && data.error === 'address_not_confirmed') {
            throw new Error('Destination address must be confirmed. Please sign the address confirmation.');
          }
          throw new Error(data.message || data.error || 'Withdrawal failed');
        }

        if (data.success) {
          hapticFeedback('success');
          
          const statusMsg = data.withdrawal.status === 'pending_review'
            ? 'Withdrawal submitted for review (large amount). You will be notified once processed.'
            : 'Withdrawal submitted successfully! Processing may take a few minutes.';
          
          alert(`${statusMsg}\n\nRequest ID: ${data.withdrawal.request_id}\nAmount: $${amount.toFixed(2)} USDC\nDestination: ${tonAddress.substring(0, 20)}...`);
          
          closeWithdrawModal();
          
          // Reload balance and history
          setTimeout(async () => {
            await loadBalance();
            loadTransactionHistory('all');
          }, 2000);
        } else {
          throw new Error(data.message || 'Withdrawal failed');
        }

      } catch (err) {
        console.error('[submitWithdrawal] Error:', err);
        hapticFeedback('error');
        alert(`Withdrawal failed: ${err.message}`);
      } finally {
        submitBtn.disabled = false;
        submitBtn.textContent = originalText;
      }
    }

    // Epic 3.1: Submit TON Deposit
    async function submitFunding() {
      const amount = parseFloat(document.getElementById('fundAmount').value);

      if (!amount || amount <= 0) {
        hapticFeedback('error');
        alert('Please enter a valid amount');
        return;
      }

      const minAmount = 0.1; // Minimum 0.1 TON
      if (amount < minAmount) {
        hapticFeedback('error');
        alert(`Minimum deposit amount is ${minAmount} TON`);
        return;
      }

      // Check TON wallet is connected
      if (!state.wallet || !state.wallet.ton || !tonConnectUI || !tonConnectUI.wallet) {
        hapticFeedback('error');
        alert('Please connect your TON wallet first');
        return;
      }

      const submitBtn = document.getElementById('fundSubmitBtn');
      const originalText = submitBtn.textContent;
      submitBtn.disabled = true;
      submitBtn.textContent = 'Preparing...';
      hapticFeedback('medium');

      try {
        // Epic 3.1: Request TON transaction signature from wallet
        // For now, we'll use the deposit detection endpoint which simulates deposit
        // In production, this would request user to sign a transaction to a deposit address
        
        const tonAddress = state.wallet.ton;
        const amountNanotons = Math.floor(amount * 1e9); // Convert TON to nanotons

        // Generate a mock transaction hash for now
        // In production, this would be the actual transaction hash from TonConnect
        const mockTxHash = `mock_${Date.now()}_${crypto.getRandomValues(new Uint8Array(8)).join('')}`;

        // Record deposit via detection endpoint (simulates deposit detection)
        const sessionToken = state.sessionToken || localStorage.getItem('session_token');
        const headers = {
          'Content-Type': 'application/json'
        };
        if (sessionToken) {
          headers['Authorization'] = `Bearer ${sessionToken}`;
        }

        const detectResp = await fetch('/api/deposit/detect', {
          method: 'POST',
          headers: headers,
          body: JSON.stringify({
            ton_tx_hash: mockTxHash,
            ton_address: tonAddress,
            amount_ton: amount,
            confirmations: 1 // Mock: assume 1 confirmation
          })
        });

        if (!detectResp.ok) {
          const errorData = await detectResp.json();
          throw new Error(errorData.message || 'Deposit detection failed');
        }

        const detectData = await detectResp.json();
        
        submitBtn.textContent = 'Processing...';
        
        // Show success message
        hapticFeedback('success');
        alert(`Deposit submitted!\n\nAmount: ${amount} TON\nTransaction: ${mockTxHash.substring(0, 20)}...\n\nYour deposit is being processed and will be credited after confirmation.`);
        
        closeFundModal();
        
        // Poll for deposit status
        setTimeout(async () => {
          await loadBalance();
        }, 3000);

      } catch (err) {
        console.error('[submitFunding] Error:', err);
        hapticFeedback('error');
        alert(`Deposit failed: ${err.message}`);
      } finally {
        submitBtn.disabled = false;
        submitBtn.textContent = originalText;
      }
    }

    // =====================
    // POSITIONS & PAYOUTS
    // =====================
    async function loadPositions() {
      // In production, fetch from API
      // For now, show empty or mock positions
      const positionsCard = document.getElementById('positionsCard');
      const positionsList = document.getElementById('positionsList');

      try {
        // In production: const resp = await fetch(`/api/positions?telegram_id=${state.telegramId}`);
        // For now, show empty
        positionsList.innerHTML = '<div class="loading" style="padding: 10px;">No active positions</div>';
        positionsCard.style.display = 'none';
      } catch (err) {
        console.error('[loadPositions] Error:', err);
      }
    }

    async function loadPayouts() {
      try {
        const resp = await fetch(`/api/payout?telegram_id=${encodeURIComponent(state.telegramId)}`);
        if (resp.ok) {
          const data = await resp.json();
          if (data.success && data.pending_payouts && data.pending_payouts.length > 0) {
            // Show payout modal or notification
            openPayoutModal(data.pending_payouts);
          }
        }
      } catch (err) {
        console.error('[loadPayouts] Error:', err);
      }
    }

    // =====================
    // TRANSACTION HISTORY (Epic 6.2)
    // =====================
    async function loadTransactionHistory(filterType = 'all') {
      try {
        const historyList = document.getElementById('historyList');
        if (!historyList) return;

        historyList.innerHTML = '<div class="loading" style="padding: 10px;">Loading history...</div>';

        const sessionToken = state.sessionToken || localStorage.getItem('session_token');
        if (!sessionToken) {
          historyList.innerHTML = '<div style="padding: 10px; color: var(--text-muted);">Please connect your wallet to view history</div>';
          return;
        }

        const queryParams = new URLSearchParams({
          limit: '20'
        });
        if (filterType !== 'all') {
          queryParams.append('type', filterType);
        }

        const resp = await fetch(`/api/ledger/history?${queryParams}`, {
          headers: {
            'Authorization': `Bearer ${sessionToken}`
          }
        });

        if (!resp.ok) {
          throw new Error('Failed to load history');
        }

        const data = await resp.json();
        
        if (!data.success || !data.entries || data.entries.length === 0) {
          historyList.innerHTML = '<div style="padding: 10px; color: var(--text-muted);">No transactions yet</div>';
          return;
        }

        // Format and display entries
        historyList.innerHTML = data.entries.map(entry => {
          const date = new Date(entry.timestamp);
          const dateStr = date.toLocaleDateString('en-US', { month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit' });
          
          const amountColor = entry.direction === 'credit' ? 'var(--green)' : 'var(--text)';
          const amountSign = entry.direction === 'credit' ? '+' : '-';
          const statusColor = entry.status === 'completed' ? 'var(--green)' : 
                             entry.status === 'pending' ? 'var(--accent)' : 
                             entry.status === 'failed' ? 'var(--red)' : 'var(--text-muted)';
          
          const typeLabels = {
            deposit: 'Deposit',
            withdrawal: 'Withdrawal',
            trade: 'Trade',
            bridge: 'Bridge',
            fee: 'Fee',
            payout: 'Payout'
          };

          return `
            <div style="padding: 12px; border-bottom: 1px solid var(--border); display: flex; justify-content: space-between; align-items: center;">
              <div style="flex: 1;">
                <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 4px;">
                  <span style="font-weight: 600; font-size: 14px;">${typeLabels[entry.type] || entry.type}</span>
                  <span style="font-size: 11px; color: ${statusColor}; padding: 2px 6px; border-radius: 4px; background: ${statusColor}20;">
                    ${entry.status}
                  </span>
                </div>
                <div style="font-size: 11px; color: var(--text-muted);">${dateStr}</div>
                ${entry.metadata?.market_id ? `<div style="font-size: 11px; color: var(--text-muted); margin-top: 2px;">Market: ${entry.metadata.market_id.substring(0, 20)}...</div>` : ''}
              </div>
              <div style="text-align: right;">
                <div style="font-weight: 600; font-size: 14px; color: ${amountColor};">
                  ${amountSign}$${entry.amount.toFixed(2)} ${entry.currency}
                </div>
                ${entry.balance_after !== null ? `<div style="font-size: 11px; color: var(--text-muted);">Balance: $${entry.balance_after.toFixed(2)}</div>` : ''}
              </div>
            </div>
          `;
        }).join('');

      } catch (err) {
        console.error('[loadTransactionHistory] Error:', err);
        const historyList = document.getElementById('historyList');
        if (historyList) {
          historyList.innerHTML = '<div style="padding: 10px; color: var(--red);">Error loading history</div>';
        }
      }
    }

    // Initialize history filter
    document.addEventListener('DOMContentLoaded', () => {
      const historyFilter = document.getElementById('historyFilter');
      if (historyFilter) {
        historyFilter.addEventListener('change', (e) => {
          loadTransactionHistory(e.target.value);
        });
      }
    });

    function openPayoutModal(payouts) {
      const modal = document.getElementById('payoutModal');
      const list = document.getElementById('payoutList');

      if (!payouts || payouts.length === 0) {
        list.innerHTML = '<div class="loading" style="padding: 10px;">No pending payouts</div>';
        return;
      }

      list.innerHTML = payouts.map(payout => `
        <div class="payout-item">
          <div class="payout-header">
            <div>
              <div class="position-question">${payout.market_question || 'Winning Position'}</div>
              <div style="font-size: 11px; color: var(--text-muted); margin-top: 4px;">
                Position ID: ${payout.position_id}
              </div>
            </div>
            <div class="payout-amount">$${payout.amount.toFixed(2)}</div>
          </div>
          <button class="payout-btn" 
                  data-position-id="${payout.position_id}"
                  data-amount="${payout.amount}">
            Claim Payout
          </button>
        </div>
      `).join('');

      // Add click handlers
      list.querySelectorAll('.payout-btn').forEach(btn => {
        btn.addEventListener('click', async () => {
          await claimPayout(btn.dataset.positionId, parseFloat(btn.dataset.amount));
        });
      });

      modal.classList.add('visible');
    }

    function closePayoutModal() {
      hapticFeedback('light');
      document.getElementById('payoutModal').classList.remove('visible');
    }

    async function claimPayout(positionId, amount) {
      hapticFeedback('medium');

      try {
        const resp = await fetch('/api/payout', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            telegram_id: state.telegramId,
            position_id: positionId,
            amount: amount,
            wallet_address: state.wallet.polygon
          })
        });

        const data = await resp.json();

        if (!resp.ok) {
          throw new Error(data.message || data.error || 'Payout failed');
        }

        if (data.success) {
          hapticFeedback('success');
          alert(`Payout initiated!\n\nAmount: $${amount.toFixed(2)}\n\n${data.message || 'Funds will arrive in your wallet shortly.'}`);
          closePayoutModal();
          await loadBalance();
        } else {
          throw new Error(data.message || 'Payout failed');
        }

      } catch (err) {
        console.error('[claimPayout] Error:', err);
        hapticFeedback('error');
        alert(`Payout failed: ${err.message}`);
      }
    }

    // =====================
    // TRADE EXECUTION
    // =====================
    async function executeTrade() {
      if (!state.selectedMarket) {
        hapticFeedback('error');
        alert('No market selected');
        return;
      }

      if (!state.wallet) {
        hapticFeedback('error');
        alert('Please create a wallet first');
        return;
      }

      const amountInput = document.getElementById('tradeAmount');
      const amount = parseFloat(amountInput.value);
      
      if (!amount || amount <= 0) {
        hapticFeedback('error');
        alert('Please enter a valid amount');
        return;
      }

      const submitBtn = document.getElementById('tradeSubmit');
      const originalText = submitBtn.textContent;
      
      // Disable button and show loading
      submitBtn.disabled = true;
      submitBtn.textContent = 'Processing...';
      hapticFeedback('medium');

      try {
        const market = state.selectedMarket;
        const side = state.tradeSide;
        const outcomeIndex = state.selectedOutcomeIndex || 0;
        
        // Get market ID (could be id, conditionId, or condition_id)
        const marketId = market.id || market.conditionId || market.condition_id;
        
        if (!marketId) {
          throw new Error('Market ID not found');
        }

        console.log('[executeTrade] Executing trade:', {
          marketId,
          side,
          amount,
          outcomeIndex,
          wallet: state.wallet.polygon
        });

        // Generate idempotency key for duplicate request prevention
        const idempotencyKey = `trade_${state.telegramId}_${marketId}_${side}_${amount}_${Date.now()}`;
        
        // Generate nonce for replay protection
        const nonce = crypto.getRandomValues(new Uint8Array(32));
        const nonceBase64 = btoa(String.fromCharCode(...nonce));
        
        // Get session token (if authenticated)
        const sessionToken = state.sessionToken || localStorage.getItem('session_token');
        
        // Prepare headers with session token
        const headers = {
          'Content-Type': 'application/json'
        };
        if (sessionToken) {
          headers['Authorization'] = `Bearer ${sessionToken}`;
        }
        
        // Call trade API with session token and security keys
        const resp = await fetch('/api/trade', {
          method: 'POST',
          headers: headers,
          body: JSON.stringify({
            // Include telegram_id as fallback (will be deprecated in favor of session token)
            telegram_id: state.telegramId,
            market_id: marketId,
            condition_id: marketId,
            outcome_index: outcomeIndex,
            side: side,
            amount: amount,
            idempotency_key: idempotencyKey,
            nonce: nonceBase64
          })
        });

        const data = await resp.json();

        if (!resp.ok) {
          // Handle specific error cases
          if (resp.status === 401) {
            throw new Error('Session expired. Please reconnect your TON wallet.');
          } else if (resp.status === 429) {
            throw new Error('Too many requests. Please wait a moment and try again.');
          } else if (resp.status === 400 && data.error === 'insufficient_balance') {
            throw new Error(data.message || 'Insufficient balance for this trade.');
          }
          throw new Error(data.message || data.error || 'Trade failed');
        }

        if (data.success) {
          hapticFeedback('success');
          
          // Show success message
          const successMsg = `Trade executed!\n\n` +
            `Market: ${market.question.substring(0, 50)}...\n` +
            `Side: ${side.toUpperCase()}\n` +
            `Amount: $${amount.toFixed(2)}\n` +
            `Shares: ${data.shares.toFixed(2)}\n` +
            `Trade ID: ${data.trade_id}`;
          
          alert(successMsg);
          
          // Close modal
          closeTradeModal();
          
          // Reload balance
          await loadBalance();
          
          // Optionally refresh markets to show updated prices
          // fetchMarkets(state.selectedCategory, state.selectedSportType);
        } else {
          throw new Error(data.message || 'Trade failed');
        }

      } catch (err) {
        console.error('[executeTrade] Error:', err);
        hapticFeedback('error');
        alert(`Trade failed: ${err.message}`);
      } finally {
        // Re-enable button
        submitBtn.disabled = false;
        submitBtn.textContent = originalText;
      }
    }

    // =====================
    // INIT
    // =====================
    function initModeChips() {
      // Legacy support for old mode-chips if they exist
      document.querySelectorAll('.mode-chip[data-kind]').forEach(chip => {
        chip.addEventListener('click', () => {
          document.querySelectorAll('.mode-chip').forEach(c => c.classList.remove('active'));
          chip.classList.add('active');
          fetchMarkets(chip.dataset.kind);
        });
      });
    }

    async function initCategories() {
      const categories = await fetchCategories();
      if (categories.length > 0) {
        renderCategories(categories);
        // Set default to first category (usually "trending")
        if (!state.selectedCategory && categories.length > 0) {
          state.selectedCategory = categories[0].slug;
          fetchMarkets(categories[0].slug);
        }
      } else {
        // Fallback to default categories if API fails
        const fallbackCategories = [
          { slug: 'trending', label: 'Trending', icon: '' },
          { slug: 'volume', label: 'Volume', icon: '' },
          { slug: 'new', label: 'New', icon: '' },
          { slug: 'sports', label: 'Sports', icon: '' },
        ];
        renderCategories(fallbackCategories);
        state.selectedCategory = 'trending';
        fetchMarkets('trending');
      }
    }

    function initTradeModal() {
      // Close on backdrop click
      document.getElementById('tradeModal').addEventListener('click', (e) => {
        if (e.target.id === 'tradeModal') closeTradeModal();
      });

      // Amount input
      document.getElementById('tradeAmount').addEventListener('input', updateTradeSummary);

      // Submit
      document.getElementById('tradeSubmit').addEventListener('click', async () => {
        await executeTrade();
      });
    }

    function initFundModal() {
      // Close on backdrop click
      document.getElementById('fundModal').addEventListener('click', (e) => {
        if (e.target.id === 'fundModal') closeFundModal();
      });

      // Close button
      document.getElementById('closeFundModal')?.addEventListener('click', () => {
        closeFundModal();
      });

      // Currency selector removed - only TON funding now

      // Withdrawal modal initialization
      const withdrawModal = document.getElementById('withdrawModal');
      if (withdrawModal) {
        withdrawModal.addEventListener('click', (e) => {
          if (e.target.id === 'withdrawModal') closeWithdrawModal();
        });
      }

      document.getElementById('closeWithdrawModal')?.addEventListener('click', () => {
        closeWithdrawModal();
      });

      document.getElementById('withdrawSubmitBtn')?.addEventListener('click', () => {
        submitWithdrawal();
      });

      // Copy fund address button
      document.getElementById('copyFundAddressBtn')?.addEventListener('click', async () => {
        const addressEl = document.getElementById('fundAddress');
        if (addressEl && addressEl.textContent) {
          await copyToClipboard(addressEl.textContent);
          const btn = document.getElementById('copyFundAddressBtn');
          btn.classList.add('copied');
          setTimeout(() => btn.classList.remove('copied'), 2000);
        }
      });

      // Submit button
      document.getElementById('fundSubmitBtn')?.addEventListener('click', async () => {
        await submitFunding();
      });

      // Payout modal close
      document.getElementById('closePayoutModal')?.addEventListener('click', () => {
        closePayoutModal();
      });

      // Payout modal backdrop
      document.getElementById('payoutModal')?.addEventListener('click', (e) => {
        if (e.target.id === 'payoutModal') closePayoutModal();
      });
    }

    async function bootstrapApp() {
      console.log('Bootstrapping app...');
      initTelegram();
      initTONConnect(); // Initialize TON Connect
      initModeChips();
      initTradeModal();
      initFundModal();
      await initCategories();


      await loadWallet();
      
      // Load transaction history
      loadTransactionHistory('all');
      
      // Markets will be fetched by initCategories()
      console.log('Bootstrap complete');
    }

    // =====================
    // START
    // =====================
    document.addEventListener('DOMContentLoaded', () => {
      initOnboarding();
      showSplash();

      setTimeout(() => {
        hideSplash();
        if (checkAccess()) {
          showMainApp();
        } else {
          showOnboarding();
        }
      }, 1500);
    });
  </script>
</body>
</html>

